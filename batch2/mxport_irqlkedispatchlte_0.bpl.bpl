var {:scalar} alloc: int;

var {:scalar} yogi_error: int;

var {:scalar} sdv_irql_previous_5: int;

var {:scalar} sdv_irql_previous_2: int;

var {:scalar} sdv_irql_current: int;

var {:scalar} sdv_irql_previous: int;

var {:scalar} sdv_irql_previous_4: int;

var {:scalar} sdv_irql_previous_3: int;

var {:scalar} Mem_T.CancelIrql__IRP: [int]int;

var {:scalar} Mem_T.CancelRoutine__IRP: [int]int;

var {:scalar} Mem_T.CurrentStackLocation_unnamed_tag_7: [int]int;

var {:scalar} Mem_T.INT4: [int]int;

var {:scalar} Mem_T.MinorFunction__IO_STACK_LOCATION: [int]int;

var {:scalar} Mem_T.Type_unnamed_tag_38: [int]int;

procedure corral_nondet() returns ({:scalar} x: int);



procedure boogie_si_record_li2bpl_int(x: int);



const alloc_init: int;

procedure {:allocator} __HAVOC_malloc(size: int) returns (ret: int);
  free requires size >= 0;
  modifies alloc;
  free ensures ret == old(alloc);
  free ensures alloc >= old(alloc) + size;



procedure {:allocator "full"} __HAVOC_malloc_or_null(size: int) returns (ret: int);
  free requires size >= 0;
  modifies alloc;
  free ensures ret == old(alloc) || ret == 0;
  free ensures alloc >= old(alloc) + size;



const {:allocated} NULL: int;

axiom NULL == 0;

function BAND(a: int, b: int) : int;

function BOR(a: int, b: int) : int;

function BNOT(a: int) : int;

function INTDIV(a: int, b: int) : int;

function INTMOD(a: int, b: int) : int;

const sdv_cancelFptr: int;

const WHEA_ERROR_PACKET_SECTION_GUID: int;

const LIbuff: int;

const LIwptr: int;

const LIofs: int;

const LIrptr: int;

const LIbase: int;

const LIdataBuffer: int;

const MoxaPortModemStatusGuid: int;

const SerialPortNameGuid: int;

const SerailPortPerfGuid: int;

const MoxaGlobalData: int;

const SerialPortPropertiesGuid: int;

const SerialPortHWGuid: int;

const SerialPortCommGuid: int;

const pollTimer: int;

const pollDpc: int;

const PDrptr: int;

const PBrptr: int;

const PDbuff: int;

const PDwptr: int;

const PBbase: int;

const PDofs: int;

const PBbuff: int;

const PBofs: int;

const PDbase: int;

const PDwriteChar: int;

const PBwptr: int;

const PBwriteChar: int;

const MoxaPhysicalZero: int;

const GUID_DEVINTERFACE_COMPORT: int;

const KeTickCount: int;

const sdv_IoBuildSynchronousFsdRequest_irp: int;

const sdv_harnessStackLocation_next: int;

const sdv_other_irp: int;

const sdv_IoBuildDeviceIoControlRequest_irp: int;

const sdv_harnessDeviceExtension_two: int;

const sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock: int;

const sdv_pv3: int;

const sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX: int;

const sdv_IoBuildAsynchronousFsdRequest_harnessIrp: int;

const sdv_p_devobj_pdo: int;

const sdv_kinterrupt: int;

const sdv_start_irp_already_issued: int;

const sdv_IoGetDeviceToVerify_DEVICE_OBJECT: int;

const sdv_p_devobj_child_pdo: int;

const sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next: int;

const sdv_IoBuildAsynchronousFsdRequest_irp: int;

const sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock: int;

const sdv_ControllerIrp: int;

const sdv_devobj_pdo: int;

const sdv_Io_Removelock_release_wait_returned: int;

const sdv_IoGetDmaAdapter_DMA_ADAPTER: int;

const sdv_IoInitializeIrp_harnessIrp: int;

const sdv_ke_dpc: int;

const sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT: int;

const sdv_irp: int;

const sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next: int;

const sdv_IoCreateSynchronizationEvent_KEVENT: int;

const sdv_ControllerPirp: int;

const sdv_harnessStackLocation: int;

const sdv_other_harnessStackLocation_next: int;

const sdv_IoCreateController_CONTROLLER_OBJECT: int;

const sdv_devobj_top: int;

const sdv_pv2: int;

const sdv_kdpc_val3: int;

const sdv_IoBuildSynchronousFsdRequest_harnessIrp: int;

const sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT: int;

const sdv_MapRegisterBase_val: int;

const sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING: int;

const sdv_IoMakeAssociatedIrp_harnessIrp: int;

const sdv_power_irp: int;

const sdv_devobj_child_pdo: int;

const sdv_harnessIrp: int;

const sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next: int;

const sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock: int;

const sdv_io_dpc: int;

const sdv_kinterrupt_val: int;

const sdv_StartIopirp: int;

const sdv_devobj_fdo: int;

const sdv_harnessDeviceExtension: int;

const sdv_DpcContext: int;

const sdv_StartIoIrp: int;

const igdoe: int;

const sdv_p_devobj_fdo: int;

const sdv_MapRegisterBase: int;

const sdv_apc_disabled: int;

const sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock: int;

const sdv_p_devobj_top: int;

const sicrni: int;

const sdv_PowerIrp: int;

const sdv_IoBuildDeviceIoControlRequest_harnessIrp: int;

const sdv_io_create_device_called: int;

const sdv_IoMakeAssociatedIrp_irp: int;

const sdv_other_harnessIrp: int;

const sdv_IoBuildSynchronousFsdRequest_IoStatusBlock: int;

const sdv_IoInitializeIrp_irp: int;

const sdv_inside_init_entrypoint: int;

const sdv_IoCreateNotificationEvent_KEVENT: int;

const sdv_other_harnessStackLocation: int;

const sdv_maskedEflags: int;

const sdv_MmMapIoSpace_int: int;

procedure {:origName "SLIC_KeClearEvent_entry"} {:osmodel} SLIC_KeClearEvent_entry(actual_caller_6: int);
  modifies yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_KeClearEvent_entry"} {:osmodel} SLIC_KeClearEvent_entry(actual_caller_6: int)
{
  var {:pointer} caller_6: int;

  anon0:
    caller_6 := actual_caller_6;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} sdv_irql_current != 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} sdv_irql_current != 1;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} sdv_irql_current != 2;
    call {:si_unique_call 0} SLIC_ABORT_3_0(caller_6);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L2;

  L2:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon10_Then:
    assume {:partition} sdv_irql_current == 2;
    goto L2;

  anon11_Then:
    assume {:partition} sdv_irql_current == 1;
    goto L2;

  anon9_Then:
    assume {:partition} sdv_irql_current == 0;
    goto L2;
}



procedure {:origName "SLIC_ABORT_3_0"} SLIC_ABORT_3_0(actual_caller_9: int);
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_ABORT_3_0"} SLIC_ABORT_3_0(actual_caller_9: int)
{
  var {:pointer} caller_9: int;

  anon0:
    caller_9 := actual_caller_9;
    call {:si_unique_call 1} SLIC_ERROR_ROUTINE(strConst__li2bpl4);
    return;
}



procedure {:origName "SLIC_sdv_KeAcquireSpinLock_entry"} {:osmodel} SLIC_sdv_KeAcquireSpinLock_entry(actual_caller_11: int);
  modifies yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_sdv_KeAcquireSpinLock_entry"} {:osmodel} SLIC_sdv_KeAcquireSpinLock_entry(actual_caller_11: int)
{
  var {:pointer} caller_11: int;

  anon0:
    caller_11 := actual_caller_11;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} sdv_irql_current != 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} sdv_irql_current != 1;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} sdv_irql_current != 2;
    call {:si_unique_call 2} SLIC_ABORT_31_0(caller_11);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L2;

  L2:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon10_Then:
    assume {:partition} sdv_irql_current == 2;
    goto L2;

  anon11_Then:
    assume {:partition} sdv_irql_current == 1;
    goto L2;

  anon9_Then:
    assume {:partition} sdv_irql_current == 0;
    goto L2;
}



procedure {:origName "SLIC_ABORT_1_0"} SLIC_ABORT_1_0(actual_caller_19: int);
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_ABORT_1_0"} SLIC_ABORT_1_0(actual_caller_19: int)
{
  var {:pointer} caller_19: int;

  anon0:
    caller_19 := actual_caller_19;
    call {:si_unique_call 3} SLIC_ERROR_ROUTINE(strConst__li2bpl10);
    return;
}



procedure {:origName "SLIC_ABORT_27_0"} SLIC_ABORT_27_0(actual_caller_22: int);
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_ABORT_27_0"} SLIC_ABORT_27_0(actual_caller_22: int)
{
  var {:pointer} caller_22: int;

  anon0:
    caller_22 := actual_caller_22;
    call {:si_unique_call 4} SLIC_ERROR_ROUTINE(strConst__li2bpl12);
    return;
}



procedure {:origName "SLIC_KeSetTimer_entry"} {:osmodel} SLIC_KeSetTimer_entry(actual_caller_26: int);
  modifies yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_KeSetTimer_entry"} {:osmodel} SLIC_KeSetTimer_entry(actual_caller_26: int)
{
  var {:pointer} caller_26: int;

  anon0:
    caller_26 := actual_caller_26;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} sdv_irql_current != 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} sdv_irql_current != 1;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} sdv_irql_current != 2;
    call {:si_unique_call 5} SLIC_ABORT_27_0(caller_26);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L2;

  L2:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon10_Then:
    assume {:partition} sdv_irql_current == 2;
    goto L2;

  anon11_Then:
    assume {:partition} sdv_irql_current == 1;
    goto L2;

  anon9_Then:
    assume {:partition} sdv_irql_current == 0;
    goto L2;
}



procedure {:origName "_sdv_init20"} _sdv_init20();
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init20"} _sdv_init20()
{

  anon0:
    yogi_error := 0;
    assume sdv_cancelFptr == 0;
    return;
}



procedure {:origName "SLIC_ABORT_31_0"} SLIC_ABORT_31_0(actual_caller_28: int);
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_ABORT_31_0"} SLIC_ABORT_31_0(actual_caller_28: int)
{
  var {:pointer} caller_28: int;

  anon0:
    caller_28 := actual_caller_28;
    call {:si_unique_call 6} SLIC_ERROR_ROUTINE(strConst__li2bpl14);
    return;
}



procedure {:origName "SLIC_ERROR_ROUTINE"} SLIC_ERROR_ROUTINE(actual_msg: int);
  modifies yogi_error;
  free ensures {:va_keep} yogi_error == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_ERROR_ROUTINE"} SLIC_ERROR_ROUTINE(actual_msg: int)
{

  anon0:
    yogi_error := 1;
    return;
}



procedure {:origName "SLIC_KeCancelTimer_entry"} {:osmodel} SLIC_KeCancelTimer_entry(actual_caller_33: int);
  modifies yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "SLIC_KeCancelTimer_entry"} {:osmodel} SLIC_KeCancelTimer_entry(actual_caller_33: int)
{
  var {:pointer} caller_33: int;

  anon0:
    caller_33 := actual_caller_33;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} sdv_irql_current != 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} sdv_irql_current != 1;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} sdv_irql_current != 2;
    call {:si_unique_call 7} SLIC_ABORT_1_0(caller_33);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L2;

  L2:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon10_Then:
    assume {:partition} sdv_irql_current == 2;
    goto L2;

  anon11_Then:
    assume {:partition} sdv_irql_current == 1;
    goto L2;

  anon9_Then:
    assume {:partition} sdv_irql_current == 0;
    goto L2;
}



procedure {:origName "MoxaCompleteRead"} MoxaCompleteRead(actual_Dpc: int, actual_DeferredContext: int, actual_SystemContext1: int, actual_SystemContext2: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCompleteRead"} MoxaCompleteRead(actual_Dpc: int, actual_DeferredContext: int, actual_SystemContext1: int, actual_SystemContext2: int)
{
  var {:pointer} Tmp_7: int;
  var {:scalar} oldIrql: int;
  var {:pointer} extension: int;
  var {:pointer} Dpc: int;
  var {:pointer} DeferredContext: int;
  var vslice_dummy_var_0: int;

  anon0:
    call {:si_unique_call 8} vslice_dummy_var_0 := __HAVOC_malloc(4);
    Dpc := actual_Dpc;
    DeferredContext := actual_DeferredContext;
    extension := DeferredContext;
    call {:si_unique_call 9} Tmp_7 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_7 != 0;
    assume Tmp_7 > 0;
    Mem_T.INT4[Tmp_7] := oldIrql;
    call {:si_unique_call 10} IoAcquireCancelSpinLock(Tmp_7);
    assume {:nonnull} Tmp_7 != 0;
    assume Tmp_7 > 0;
    oldIrql := Mem_T.INT4[Tmp_7];
    assume {:nonnull} extension != 0;
    assume extension > 0;
    assume {:nonnull} extension != 0;
    assume extension > 0;
    call {:si_unique_call 11} MoxaTryToCompleteCurrent(extension, 0, oldIrql, 0, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension), ReadQueue__MOXA_DEVICE_EXTENSION(extension), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 12} MoxaDpcEpilogue(extension, Dpc);
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init2"} _sdv_init2();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init2"} _sdv_init2()
{
  var vslice_dummy_var_1: int;

  anon0:
    call {:si_unique_call 13} vslice_dummy_var_1 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaGetData"} MoxaGetData(actual_Extension: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetData"} MoxaGetData(actual_Extension: int)
{
  var {:scalar} Tmp_11: int;
  var {:scalar} Tmp_12: int;
  var {:pointer} Tmp_13: int;
  var {:scalar} Tmp_15: int;
  var {:scalar} Tmp_16: int;
  var {:scalar} Tmp_17: int;
  var {:scalar} Tmp_18: int;
  var {:pointer} Tmp_19: int;
  var {:pointer} Tmp_20: int;
  var {:pointer} Tmp_21: int;
  var {:pointer} Tmp_22: int;
  var {:scalar} Tmp_23: int;
  var {:pointer} Tmp_24: int;
  var {:scalar} Tmp_25: int;
  var {:scalar} Tmp_27: int;
  var {:pointer} Tmp_28: int;
  var {:pointer} Tmp_29: int;
  var {:pointer} Tmp_30: int;
  var {:scalar} Tmp_31: int;
  var {:scalar} Tmp_32: int;
  var {:pointer} Tmp_33: int;
  var {:scalar} Tmp_34: int;
  var {:scalar} Tmp_35: int;
  var {:scalar} Tmp_36: int;
  var {:pointer} Extension: int;
  var vslice_dummy_var_2: int;
  var vslice_dummy_var_1151: int;
  var vslice_dummy_var_1152: int;
  var vslice_dummy_var_1153: int;
  var vslice_dummy_var_1154: int;

  anon0:
    call {:si_unique_call 14} vslice_dummy_var_2 := __HAVOC_malloc(4);
    Extension := actual_Extension;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    havoc Tmp_20;
    assume {:nonnull} Tmp_20 != 0;
    assume Tmp_20 > 0;
    havoc Tmp_13;
    assume {:nonnull} Tmp_13 != 0;
    assume Tmp_13 > 0;
    havoc Tmp_30;
    assume {:nonnull} Tmp_30 != 0;
    assume Tmp_30 > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    goto anon43_Then, anon43_Else;

  anon43_Else:
    havoc Tmp_17;
    goto L18;

  L18:
    goto anon44_Then, anon44_Else;

  anon44_Else:
    goto anon37_Then, anon37_Else;

  anon37_Else:
    havoc Tmp_24;
    assume {:nonnull} Tmp_24 != 0;
    assume Tmp_24 > 0;
    goto anon45_Then, anon45_Else;

  anon45_Else:
    goto L25;

  L25:
    havoc Mem_T.INT4;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    havoc Tmp_35;
    havoc Tmp_36;
    havoc Mem_T.INT4;
    goto L30;

  L30:
    call {:si_unique_call 15} vslice_dummy_var_1151 := corral_nondet();
    goto L34;

  L34:
    call {:si_unique_call 16} Tmp_12, Tmp_19, Tmp_21, Tmp_34 := MoxaGetData_loop_L34(Tmp_12, Tmp_19, Tmp_21, Tmp_34);
    goto L34_last;

  L34_last:
    havoc Tmp_34;
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} Tmp_34 != 0;
    havoc Tmp_21;
    havoc Tmp_12;
    havoc Tmp_19;
    assume {:nonnull} Tmp_19 != 0;
    assume Tmp_19 > 0;
    assume {:nonnull} Tmp_21 != 0;
    assume Tmp_21 > 0;
    Mem_T.INT4[Tmp_21] := Mem_T.INT4[Tmp_19];
    goto anon47_Else_dummy;

  anon47_Else_dummy:
    assume false;
    return;

  anon47_Then:
    assume {:partition} Tmp_34 == 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    havoc Tmp_15;
    havoc Tmp_23;
    havoc Mem_T.INT4;
    goto L39;

  L39:
    havoc Mem_T.INT4;
    goto L42;

  L42:
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    havoc Tmp_33;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    havoc Tmp_29;
    assume {:nonnull} Tmp_29 != 0;
    assume Tmp_29 > 0;
    assume {:nonnull} Tmp_33 != 0;
    assume Tmp_33 > 0;
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    goto anon48_Then, anon48_Else;

  anon48_Else:
    goto anon40_Then, anon40_Else;

  anon40_Else:
    havoc Tmp_27;
    goto L50;

  L50:
    assume {:nonnull} Extension != 0;
    assume Extension > 0;
    goto anon49_Then, anon49_Else;

  anon49_Else:
    havoc vslice_dummy_var_1152;
    call {:si_unique_call 17} MoxaFuncWithDumbWait(vslice_dummy_var_1152, 16, 0);
    goto L1;

  L1:
    return;

  anon49_Then:
    goto L1;

  anon40_Then:
    havoc Tmp_27;
    goto L50;

  anon48_Then:
    goto L1;

  anon39_Then:
    goto L39;

  anon46_Then:
    goto L30;

  anon45_Then:
    goto L25;

  anon37_Then:
    goto anon38_Then, anon38_Else;

  anon38_Else:
    goto L55;

  L55:
    call {:si_unique_call 18} vslice_dummy_var_1153 := corral_nondet();
    goto L60;

  L60:
    call {:si_unique_call 19} Tmp_11, Tmp_16, Tmp_18, Tmp_22, Tmp_25, Tmp_28, Tmp_31, Tmp_32 := MoxaGetData_loop_L60(Tmp_11, Tmp_16, Tmp_18, Tmp_22, Tmp_25, Tmp_28, Tmp_31, Tmp_32);
    goto L60_last;

  L60_last:
    goto anon50_Then, anon50_Else;

  anon50_Else:
    goto L62;

  L62:
    goto anon51_Then, anon51_Else;

  anon51_Else:
    havoc Mem_T.INT4;
    goto anon52_Then, anon52_Else;

  anon52_Else:
    havoc Tmp_16;
    Tmp_31 := Tmp_16;
    havoc Mem_T.INT4;
    goto L68;

  L68:
    call {:si_unique_call 20} vslice_dummy_var_1154 := corral_nondet();
    goto L71;

  L71:
    call {:si_unique_call 21} Tmp_22, Tmp_25, Tmp_28, Tmp_32 := MoxaGetData_loop_L71(Tmp_22, Tmp_25, Tmp_28, Tmp_32);
    goto L71_last;

  L71_last:
    havoc Tmp_25;
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} Tmp_25 != 0;
    havoc Tmp_28;
    havoc Tmp_32;
    havoc Tmp_22;
    assume {:nonnull} Tmp_22 != 0;
    assume Tmp_22 > 0;
    assume {:nonnull} Tmp_28 != 0;
    assume Tmp_28 > 0;
    Mem_T.INT4[Tmp_28] := Mem_T.INT4[Tmp_22];
    goto anon53_Else_dummy;

  anon53_Else_dummy:
    assume false;
    return;

  anon53_Then:
    assume {:partition} Tmp_25 == 0;
    goto anon42_Then, anon42_Else;

  anon42_Else:
    havoc Tmp_11;
    Tmp_18 := Tmp_11;
    havoc Mem_T.INT4;
    goto L65;

  L65:
    goto anon41_Then, anon41_Else;

  anon41_Else:
    havoc Mem_T.INT4;
    goto L42;

  anon41_Then:
    goto anon54_Then, anon54_Else;

  anon54_Else:
    goto L78;

  L78:
    goto L78_dummy;

  L78_dummy:
    assume false;
    return;

  anon54_Then:
    goto L78;

  anon42_Then:
    goto L65;

  anon52_Then:
    goto L68;

  anon51_Then:
    goto L65;

  anon50_Then:
    goto L62;

  anon38_Then:
    goto L55;

  anon44_Then:
    goto L1;

  anon43_Then:
    havoc Tmp_17;
    goto L18;
}



procedure {:origName "MoxaIntervalReadTimeout"} MoxaIntervalReadTimeout(actual_Dpc_1: int, actual_DeferredContext_1: int, actual_SystemContext1_1: int, actual_SystemContext2_1: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIntervalReadTimeout"} MoxaIntervalReadTimeout(actual_Dpc_1: int, actual_DeferredContext_1: int, actual_SystemContext1_1: int, actual_SystemContext2_1: int)
{
  var {:pointer} Tmp_37: int;
  var {:scalar} count: int;
  var {:pointer} Tmp_38: int;
  var {:pointer} Tmp_40: int;
  var {:pointer} Tmp_41: int;
  var {:scalar} Tmp_42: int;
  var {:pointer} Tmp_43: int;
  var {:scalar} currentTime: int;
  var {:pointer} Tmp_44: int;
  var {:scalar} oldIrql_1: int;
  var {:scalar} sdv_9: int;
  var {:pointer} sdv_10: int;
  var {:pointer} Tmp_45: int;
  var {:scalar} Tmp_46: int;
  var {:pointer} extension_1: int;
  var {:pointer} Dpc_1: int;
  var {:pointer} DeferredContext_1: int;
  var vslice_dummy_var_3: int;
  var vslice_dummy_var_4: int;
  var vslice_dummy_var_5: int;
  var vslice_dummy_var_6: int;
  var vslice_dummy_var_7: int;
  var vslice_dummy_var_1155: int;
  var vslice_dummy_var_1156: int;
  var vslice_dummy_var_1157: int;
  var vslice_dummy_var_1158: int;

  anon0:
    call {:si_unique_call 22} currentTime := __HAVOC_malloc(20);
    call {:si_unique_call 23} vslice_dummy_var_3 := __HAVOC_malloc(4);
    Dpc_1 := actual_Dpc_1;
    DeferredContext_1 := actual_DeferredContext_1;
    extension_1 := DeferredContext_1;
    call {:si_unique_call 24} Tmp_41 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_41 != 0;
    assume Tmp_41 > 0;
    Mem_T.INT4[Tmp_41] := oldIrql_1;
    call {:si_unique_call 25} IoAcquireCancelSpinLock(Tmp_41);
    assume {:nonnull} Tmp_41 != 0;
    assume Tmp_41 > 0;
    oldIrql_1 := Mem_T.INT4[Tmp_41];
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    call {:si_unique_call 26} MoxaTryToCompleteCurrent(extension_1, li2bplFunctionConstant147, oldIrql_1, 258, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_1), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:partition} yogi_error != 1;
    goto L15;

  L15:
    call {:si_unique_call 27} MoxaDpcEpilogue(extension_1, Dpc_1);
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon46_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon39_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    call {:si_unique_call 28} MoxaTryToCompleteCurrent(extension_1, 0, oldIrql_1, 0, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_1), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} yogi_error != 1;
    goto L15;

  anon47_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon40_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    call {:si_unique_call 29} MoxaTryToCompleteCurrent(extension_1, li2bplFunctionConstant147, oldIrql_1, -1073741536, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_1), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} yogi_error != 1;
    goto L15;

  anon48_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon41_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc Tmp_40;
    assume {:nonnull} Tmp_40 != 0;
    assume Tmp_40 > 0;
    goto anon49_Then, anon49_Else;

  anon49_Else:
    havoc Tmp_46;
    goto L34;

  L34:
    count := Tmp_46;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon50_Then, anon50_Else;

  anon50_Else:
    assume {:nonnull} currentTime != 0;
    assume currentTime > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon43_Then, anon43_Else;

  anon43_Else:
    call {:si_unique_call 30} sdv_9 := MoxaCheckInQueue(extension_1);
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} sdv_9 != 0;
    call {:si_unique_call 31} vslice_dummy_var_4 := KeSynchronizeExecution(0, li2bplFunctionConstant151, 0);
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc vslice_dummy_var_1155;
    call {:si_unique_call 32} sdv_10 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1155);
    assume {:nonnull} sdv_10 != 0;
    assume sdv_10 > 0;
    Tmp_37 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_10)));
    assume {:nonnull} sdv_10 != 0;
    assume sdv_10 > 0;
    assume {:nonnull} Tmp_37 != 0;
    assume Tmp_37 > 0;
    assume {:nonnull} sdv_10 != 0;
    assume sdv_10 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    call {:si_unique_call 33} MoxaTryToCompleteCurrent(extension_1, 0, oldIrql_1, 0, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_1), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 34} MoxaDpcEpilogue(extension_1, Dpc_1);
    goto L1;

  anon53_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon45_Then:
    goto L58;

  L58:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    call {:si_unique_call 35} MoxaTryToCompleteCurrent(extension_1, li2bplFunctionConstant147, oldIrql_1, 258, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_1), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon52_Then, anon52_Else;

  anon52_Else:
    assume {:partition} yogi_error != 1;
    goto L15;

  anon52_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon44_Then:
    assume {:partition} sdv_9 == 0;
    goto L58;

  anon43_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc Tmp_44;
    assume {:nonnull} Tmp_44 != 0;
    assume Tmp_44 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc vslice_dummy_var_1156;
    call {:si_unique_call 36} vslice_dummy_var_6 := MoxaSetTimer(ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), vslice_dummy_var_1156, IntervalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(extension_1), extension_1);
    goto anon54_Then, anon54_Else;

  anon54_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 37} IoReleaseCancelSpinLock(oldIrql_1);
    goto L15;

  anon54_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon50_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc Tmp_38;
    assume {:nonnull} Tmp_38 != 0;
    assume Tmp_38 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc vslice_dummy_var_1157;
    call {:si_unique_call 38} vslice_dummy_var_5 := MoxaSetTimer(ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), vslice_dummy_var_1157, IntervalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(extension_1), extension_1);
    goto anon51_Then, anon51_Else;

  anon51_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 39} IoReleaseCancelSpinLock(oldIrql_1);
    goto L15;

  anon51_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon49_Then:
    havoc Tmp_46;
    goto L34;

  anon42_Then:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc Tmp_45;
    assume {:nonnull} Tmp_45 != 0;
    assume Tmp_45 > 0;
    goto anon55_Then, anon55_Else;

  anon55_Else:
    havoc Tmp_42;
    goto L86;

  L86:
    count := Tmp_42;
    goto anon56_Then, anon56_Else;

  anon56_Else:
    assume {:partition} count != 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    goto L88;

  L88:
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc Tmp_43;
    assume {:nonnull} Tmp_43 != 0;
    assume Tmp_43 > 0;
    assume {:nonnull} extension_1 != 0;
    assume extension_1 > 0;
    havoc vslice_dummy_var_1158;
    call {:si_unique_call 40} vslice_dummy_var_7 := MoxaSetTimer(ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_1), vslice_dummy_var_1158, IntervalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(extension_1), extension_1);
    goto anon57_Then, anon57_Else;

  anon57_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 41} IoReleaseCancelSpinLock(oldIrql_1);
    goto L15;

  anon57_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon56_Then:
    assume {:partition} count == 0;
    goto L88;

  anon55_Then:
    havoc Tmp_42;
    goto L86;
}



procedure {:origName "MoxaStartRead"} MoxaStartRead(actual_Extension_1: int) returns (Tmp_48: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_5) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartRead"} MoxaStartRead(actual_Extension_1: int) returns (Tmp_48: int)
{
  var {:pointer} Tmp_49: int;
  var {:pointer} Tmp_50: int;
  var {:pointer} Tmp_51: int;
  var {:pointer} Tmp_52: int;
  var {:pointer} irpSp: int;
  var {:scalar} totalTime_1: int;
  var {:scalar} os2ssreturn: int;
  var {:scalar} timeoutsForIrp: int;
  var {:pointer} Tmp_53: int;
  var {:pointer} Tmp_54: int;
  var {:scalar} setFirstStatus: int;
  var {:pointer} Tmp_55: int;
  var {:pointer} newIrp: int;
  var {:scalar} useTotalTimer: int;
  var {:pointer} Tmp_57: int;
  var {:scalar} multiplierVal: int;
  var {:pointer} sdv_15: int;
  var {:scalar} crunchDownToOne: int;
  var {:pointer} sdv_16: int;
  var {:pointer} sdv_17: int;
  var {:pointer} sdv_18: int;
  var {:pointer} Tmp_58: int;
  var {:scalar} oldIrql_2: int;
  var {:pointer} Tmp_59: int;
  var {:pointer} sdv_21: int;
  var {:scalar} constantVal: int;
  var {:pointer} Tmp_60: int;
  var {:scalar} ioControlCode: int;
  var {:pointer} Tmp_61: int;
  var {:scalar} controlIrql: int;
  var {:pointer} Tmp_62: int;
  var {:scalar} returnWithWhatsPresent: int;
  var {:scalar} useIntervalTimer: int;
  var {:scalar} firstStatus: int;
  var {:pointer} Extension_1: int;
  var vslice_dummy_var_8: int;
  var vslice_dummy_var_9: int;
  var vslice_dummy_var_10: int;
  var vslice_dummy_var_11: int;
  var vslice_dummy_var_12: int;
  var vslice_dummy_var_13: int;
  var vslice_dummy_var_1159: int;
  var vslice_dummy_var_1160: int;
  var vslice_dummy_var_1161: int;
  var vslice_dummy_var_1162: int;
  var vslice_dummy_var_1163: int;
  var vslice_dummy_var_1164: int;
  var vslice_dummy_var_1165: int;

  anon0:
    call {:si_unique_call 42} totalTime_1 := __HAVOC_malloc(20);
    call {:si_unique_call 43} timeoutsForIrp := __HAVOC_malloc(20);
    call {:si_unique_call 44} newIrp := __HAVOC_malloc(4);
    Extension_1 := actual_Extension_1;
    setFirstStatus := 0;
    goto L20;

  L20:
    call {:si_unique_call 45} Tmp_49, Tmp_50, Tmp_51, Tmp_52, irpSp, os2ssreturn, Tmp_53, Tmp_54, setFirstStatus, useTotalTimer, multiplierVal, crunchDownToOne, sdv_16, sdv_17, oldIrql_2, Tmp_59, sdv_21, constantVal, Tmp_60, ioControlCode, Tmp_61, controlIrql, Tmp_62, returnWithWhatsPresent, useIntervalTimer, firstStatus, vslice_dummy_var_8, vslice_dummy_var_9, vslice_dummy_var_10, vslice_dummy_var_11 := MoxaStartRead_loop_L20(Tmp_49, Tmp_50, Tmp_51, Tmp_52, irpSp, totalTime_1, os2ssreturn, timeoutsForIrp, Tmp_53, Tmp_54, setFirstStatus, newIrp, useTotalTimer, multiplierVal, crunchDownToOne, sdv_16, sdv_17, oldIrql_2, Tmp_59, sdv_21, constantVal, Tmp_60, ioControlCode, Tmp_61, controlIrql, Tmp_62, returnWithWhatsPresent, useIntervalTimer, firstStatus, Extension_1, vslice_dummy_var_8, vslice_dummy_var_9, vslice_dummy_var_10, vslice_dummy_var_11);
    goto L20_last;

  L20_last:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1165;
    call {:si_unique_call 82} irpSp := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1165);
    assume {:nonnull} irpSp != 0;
    assume irpSp > 0;
    goto anon75_Then, anon75_Else;

  anon75_Else:
    call {:si_unique_call 46} Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    Mem_T.INT4[Tmp_50] := controlIrql;
    call {:si_unique_call 47} sdv_KeAcquireSpinLock(0, Tmp_50);
    goto anon102_Then, anon102_Else;

  anon102_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    controlIrql := Mem_T.INT4[Tmp_50];
    call {:si_unique_call 48} Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    Mem_T.INT4[Tmp_50] := oldIrql_2;
    call {:si_unique_call 49} IoAcquireCancelSpinLock(Tmp_50);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    oldIrql_2 := Mem_T.INT4[Tmp_50];
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_52;
    assume {:nonnull} Tmp_52 != 0;
    assume Tmp_52 > 0;
    goto anon103_Then, anon103_Else;

  anon103_Else:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_54;
    assume {:nonnull} Tmp_54 != 0;
    assume Tmp_54 > 0;
    call {:si_unique_call 50} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 51} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon76_Then, anon76_Else;

  anon76_Else:
    assume {:partition} setFirstStatus != 0;
    goto L45;

  L45:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    call {:si_unique_call 52} MoxaGetNextIrp(CurrentReadIrp__MOXA_DEVICE_EXTENSION(Extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(Extension_1), newIrp, 1, Extension_1);
    assume {:nonnull} newIrp != 0;
    assume newIrp > 0;
    goto anon77_Then, anon77_Else;

  anon77_Else:
    Tmp_48 := firstStatus;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon77_Then:
    goto anon77_Then_dummy;

  anon77_Then_dummy:
    assume false;
    return;

  anon76_Then:
    assume {:partition} setFirstStatus == 0;
    firstStatus := -1073741536;
    setFirstStatus := 1;
    goto L45;

  anon103_Then:
    assume {:nonnull} irpSp != 0;
    assume irpSp > 0;
    havoc ioControlCode;
    goto anon104_Then, anon104_Else;

  anon104_Else:
    assume {:partition} ioControlCode == 1777688;
    call {:si_unique_call 53} vslice_dummy_var_9 := KeSynchronizeExecution(0, li2bplFunctionConstant141, 0);
    goto L58;

  L58:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_61;
    assume {:nonnull} Tmp_61 != 0;
    assume Tmp_61 > 0;
    call {:si_unique_call 54} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 55} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon78_Then, anon78_Else;

  anon78_Else:
    assume {:partition} setFirstStatus == 0;
    firstStatus := 0;
    setFirstStatus := 1;
    goto L45;

  anon78_Then:
    assume {:partition} setFirstStatus != 0;
    goto L45;

  anon104_Then:
    assume {:partition} ioControlCode != 1777688;
    call {:si_unique_call 56} vslice_dummy_var_8 := KeSynchronizeExecution(0, li2bplFunctionConstant142, 0);
    goto L58;

  anon102_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon75_Then:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1159;
    call {:si_unique_call 57} sdv_17 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1159);
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} sdv_17 != 0;
    assume sdv_17 > 0;
    useTotalTimer := 0;
    returnWithWhatsPresent := 0;
    os2ssreturn := 0;
    crunchDownToOne := 0;
    useIntervalTimer := 0;
    call {:si_unique_call 58} Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    Mem_T.INT4[Tmp_50] := controlIrql;
    call {:si_unique_call 59} sdv_KeAcquireSpinLock(0, Tmp_50);
    goto anon105_Then, anon105_Else;

  anon105_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    controlIrql := Mem_T.INT4[Tmp_50];
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    call {:si_unique_call 60} sdv_KeReleaseSpinLock(0, controlIrql);
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    useIntervalTimer := 1;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    goto anon106_Then, anon106_Else;

  anon106_Else:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    goto L82;

  L82:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    goto L92;

  L92:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon87_Then, anon87_Else;

  anon87_Else:
    useTotalTimer := 1;
    os2ssreturn := 1;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    havoc multiplierVal;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    havoc constantVal;
    goto L99;

  L99:
    goto anon88_Then, anon88_Else;

  anon88_Else:
    assume {:partition} useTotalTimer != 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} totalTime_1 != 0;
    assume totalTime_1 > 0;
    goto L100;

  L100:
    call {:si_unique_call 61} Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    Mem_T.INT4[Tmp_50] := controlIrql;
    call {:si_unique_call 62} sdv_KeAcquireSpinLock(0, Tmp_50);
    goto anon107_Then, anon107_Else;

  anon107_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    controlIrql := Mem_T.INT4[Tmp_50];
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1160;
    call {:si_unique_call 63} sdv_21 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1160);
    assume {:nonnull} sdv_21 != 0;
    assume sdv_21 > 0;
    call {:si_unique_call 64} Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    Mem_T.INT4[Tmp_50] := oldIrql_2;
    call {:si_unique_call 65} IoAcquireCancelSpinLock(Tmp_50);
    assume {:nonnull} Tmp_50 != 0;
    assume Tmp_50 > 0;
    oldIrql_2 := Mem_T.INT4[Tmp_50];
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_53;
    assume {:nonnull} Tmp_53 != 0;
    assume Tmp_53 > 0;
    goto anon108_Then, anon108_Else;

  anon108_Else:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_59;
    assume {:nonnull} Tmp_59 != 0;
    assume Tmp_59 > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_51;
    assume {:nonnull} Tmp_51 != 0;
    assume Tmp_51 > 0;
    call {:si_unique_call 66} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 67} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon89_Then, anon89_Else;

  anon89_Else:
    assume {:partition} setFirstStatus == 0;
    firstStatus := -1073741536;
    setFirstStatus := 1;
    goto L45;

  anon89_Then:
    assume {:partition} setFirstStatus != 0;
    goto L45;

  anon108_Then:
    call {:si_unique_call 68} vslice_dummy_var_10 := KeSynchronizeExecution(0, li2bplFunctionConstant143, 0);
    goto anon90_Then, anon90_Else;

  anon90_Else:
    assume {:partition} returnWithWhatsPresent != 0;
    goto L128;

  L128:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_49;
    assume {:nonnull} Tmp_49 != 0;
    assume Tmp_49 > 0;
    call {:si_unique_call 69} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 70} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon92_Then, anon92_Else;

  anon92_Else:
    assume {:partition} setFirstStatus == 0;
    firstStatus := 0;
    setFirstStatus := 1;
    goto L45;

  anon92_Then:
    assume {:partition} setFirstStatus != 0;
    goto L45;

  anon90_Then:
    assume {:partition} returnWithWhatsPresent == 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    goto anon91_Then, anon91_Else;

  anon91_Else:
    goto anon93_Then, anon93_Else;

  anon93_Else:
    assume {:partition} os2ssreturn != 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_62;
    assume {:nonnull} Tmp_62 != 0;
    assume Tmp_62 > 0;
    goto anon109_Then, anon109_Else;

  anon109_Else:
    goto L139;

  L139:
    goto anon94_Then, anon94_Else;

  anon94_Else:
    assume {:partition} crunchDownToOne != 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1161;
    call {:si_unique_call 71} sdv_16 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1161);
    assume {:nonnull} sdv_16 != 0;
    assume sdv_16 > 0;
    goto L141;

  L141:
    call {:si_unique_call 72} vslice_dummy_var_11 := KeSynchronizeExecution(0, li2bplFunctionConstant145, 0);
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    goto anon95_Then, anon95_Else;

  anon95_Else:
    goto anon96_Then, anon96_Else;

  anon96_Else:
    assume {:partition} useTotalTimer != 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1162;
    call {:si_unique_call 73} sdv_15 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1162);
    assume {:nonnull} sdv_15 != 0;
    assume sdv_15 > 0;
    Tmp_55 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_15)));
    assume {:nonnull} sdv_15 != 0;
    assume sdv_15 > 0;
    assume {:nonnull} Tmp_55 != 0;
    assume Tmp_55 > 0;
    assume {:nonnull} sdv_15 != 0;
    assume sdv_15 > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    call {:si_unique_call 74} vslice_dummy_var_12 := MoxaSetTimer(ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(Extension_1), totalTime_1, TotalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(Extension_1), Extension_1);
    goto anon110_Then, anon110_Else;

  anon110_Else:
    assume {:partition} yogi_error != 1;
    goto L152;

  L152:
    goto anon97_Then, anon97_Else;

  anon97_Else:
    assume {:partition} useIntervalTimer != 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc vslice_dummy_var_1163;
    call {:si_unique_call 75} sdv_18 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1163);
    assume {:nonnull} sdv_18 != 0;
    assume sdv_18 > 0;
    Tmp_58 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_18)));
    assume {:nonnull} sdv_18 != 0;
    assume sdv_18 > 0;
    assume {:nonnull} Tmp_58 != 0;
    assume Tmp_58 > 0;
    assume {:nonnull} sdv_18 != 0;
    assume sdv_18 > 0;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_57;
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    assume {:nonnull} Tmp_57 != 0;
    assume Tmp_57 > 0;
    havoc vslice_dummy_var_1164;
    call {:si_unique_call 76} vslice_dummy_var_13 := MoxaSetTimer(ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(Extension_1), vslice_dummy_var_1164, IntervalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(Extension_1), Extension_1);
    goto anon111_Then, anon111_Else;

  anon111_Else:
    assume {:partition} yogi_error != 1;
    goto L160;

  L160:
    call {:si_unique_call 77} sdv_IoMarkIrpPending(0);
    call {:si_unique_call 78} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 79} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon98_Then, anon98_Else;

  anon98_Else:
    assume {:partition} setFirstStatus != 0;
    goto L181;

  L181:
    Tmp_48 := firstStatus;
    goto L1;

  anon98_Then:
    assume {:partition} setFirstStatus == 0;
    firstStatus := 259;
    goto L181;

  anon111_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon97_Then:
    assume {:partition} useIntervalTimer == 0;
    goto L160;

  anon110_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon96_Then:
    assume {:partition} useTotalTimer == 0;
    goto L152;

  anon95_Then:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    havoc Tmp_60;
    assume {:nonnull} Tmp_60 != 0;
    assume Tmp_60 > 0;
    call {:si_unique_call 80} IoReleaseCancelSpinLock(oldIrql_2);
    call {:si_unique_call 81} sdv_KeReleaseSpinLock(0, controlIrql);
    goto anon99_Then, anon99_Else;

  anon99_Else:
    assume {:partition} setFirstStatus == 0;
    firstStatus := 0;
    setFirstStatus := 1;
    goto L45;

  anon99_Then:
    assume {:partition} setFirstStatus != 0;
    goto L45;

  anon94_Then:
    assume {:partition} crunchDownToOne == 0;
    goto L141;

  anon109_Then:
    goto L128;

  anon93_Then:
    assume {:partition} os2ssreturn == 0;
    goto L139;

  anon91_Then:
    goto L128;

  anon107_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon88_Then:
    assume {:partition} useTotalTimer == 0;
    goto L100;

  anon87_Then:
    goto L93;

  L93:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon100_Then, anon100_Else;

  anon100_Else:
    useTotalTimer := 1;
    os2ssreturn := 1;
    crunchDownToOne := 1;
    multiplierVal := 0;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    havoc constantVal;
    goto L99;

  anon100_Then:
    goto L99;

  anon86_Then:
    goto L99;

  anon85_Then:
    goto L93;

  anon83_Then:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon84_Then, anon84_Else;

  anon84_Else:
    returnWithWhatsPresent := 1;
    goto L99;

  anon84_Then:
    goto L92;

  anon80_Then:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    goto L199;

  L199:
    useTotalTimer := 1;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    havoc multiplierVal;
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    havoc constantVal;
    goto L99;

  anon82_Then:
    assume {:nonnull} timeoutsForIrp != 0;
    assume timeoutsForIrp > 0;
    goto anon101_Then, anon101_Else;

  anon101_Else:
    goto L199;

  anon101_Then:
    goto L99;

  anon106_Then:
    assume {:nonnull} Extension_1 != 0;
    assume Extension_1 > 0;
    goto L82;

  anon81_Then:
    goto L82;

  anon79_Then:
    goto L82;

  anon105_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaCheckInQueue"} MoxaCheckInQueue(actual_Extension_2: int) returns (Tmp_64: int);
  free ensures {:va_keep} Tmp_64 == 1 || Tmp_64 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCheckInQueue"} MoxaCheckInQueue(actual_Extension_2: int) returns (Tmp_64: int)
{
  var {:pointer} ofs: int;
  var {:pointer} Extension_2: int;

  anon0:
    Extension_2 := actual_Extension_2;
    assume {:nonnull} Extension_2 != 0;
    assume Extension_2 > 0;
    havoc ofs;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_64 := 1;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_64 := 0;
    goto L1;
}



procedure {:origName "MoxaReadTimeout"} MoxaReadTimeout(actual_Dpc_2: int, actual_DeferredContext_2: int, actual_SystemContext1_2: int, actual_SystemContext2_2: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaReadTimeout"} MoxaReadTimeout(actual_Dpc_2: int, actual_DeferredContext_2: int, actual_SystemContext1_2: int, actual_SystemContext2_2: int)
{
  var {:pointer} Tmp_66: int;
  var {:scalar} sdv_24: int;
  var {:pointer} Tmp_68: int;
  var {:scalar} oldIrql_3: int;
  var {:pointer} sdv_26: int;
  var {:pointer} extension_2: int;
  var {:pointer} Dpc_2: int;
  var {:pointer} DeferredContext_2: int;
  var vslice_dummy_var_14: int;
  var vslice_dummy_var_15: int;
  var vslice_dummy_var_1166: int;

  anon0:
    call {:si_unique_call 83} vslice_dummy_var_14 := __HAVOC_malloc(4);
    Dpc_2 := actual_Dpc_2;
    DeferredContext_2 := actual_DeferredContext_2;
    extension_2 := DeferredContext_2;
    call {:si_unique_call 84} Tmp_68 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_68 != 0;
    assume Tmp_68 > 0;
    Mem_T.INT4[Tmp_68] := oldIrql_3;
    call {:si_unique_call 85} IoAcquireCancelSpinLock(Tmp_68);
    assume {:nonnull} Tmp_68 != 0;
    assume Tmp_68 > 0;
    oldIrql_3 := Mem_T.INT4[Tmp_68];
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    call {:si_unique_call 86} MoxaTryToCompleteCurrent(extension_2, 0, oldIrql_3, 0, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_2), ReadQueue__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_2), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 87} MoxaDpcEpilogue(extension_2, Dpc_2);
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon16_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon13_Then:
    call {:si_unique_call 88} sdv_24 := MoxaCheckInQueue(extension_2);
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} sdv_24 != 0;
    call {:si_unique_call 89} vslice_dummy_var_15 := KeSynchronizeExecution(0, li2bplFunctionConstant151, 0);
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    havoc vslice_dummy_var_1166;
    call {:si_unique_call 90} sdv_26 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1166);
    assume {:nonnull} sdv_26 != 0;
    assume sdv_26 > 0;
    Tmp_66 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_26)));
    assume {:nonnull} sdv_26 != 0;
    assume sdv_26 > 0;
    assume {:nonnull} Tmp_66 != 0;
    assume Tmp_66 > 0;
    assume {:nonnull} sdv_26 != 0;
    assume sdv_26 > 0;
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    call {:si_unique_call 91} MoxaTryToCompleteCurrent(extension_2, 0, oldIrql_3, 0, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_2), ReadQueue__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_2), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 92} MoxaDpcEpilogue(extension_2, Dpc_2);
    goto L1;

  anon18_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon15_Then:
    goto L21;

  L21:
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    assume {:nonnull} extension_2 != 0;
    assume extension_2 > 0;
    call {:si_unique_call 93} MoxaTryToCompleteCurrent(extension_2, li2bplFunctionConstant147, oldIrql_3, 258, CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_2), ReadQueue__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(extension_2), ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_2), li2bplFunctionConstant140, li2bplFunctionConstant148);
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 94} MoxaDpcEpilogue(extension_2, Dpc_2);
    goto L1;

  anon17_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon14_Then:
    assume {:partition} sdv_24 == 0;
    goto L21;
}



procedure {:origName "MoxaRead"} MoxaRead(actual_DeviceObject: int, actual_Irp: int) returns (Tmp_70: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, Mem_T.CancelIrql__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaRead"} MoxaRead(actual_DeviceObject: int, actual_Irp: int) returns (Tmp_70: int)
{
  var {:scalar} sdv_28: int;
  var {:pointer} sdv_29: int;
  var {:scalar} status: int;
  var {:pointer} extension_3: int;
  var {:pointer} DeviceObject: int;
  var {:pointer} Irp: int;

  anon0:
    DeviceObject := actual_DeviceObject;
    Irp := actual_Irp;
    assume {:nonnull} DeviceObject != 0;
    assume DeviceObject > 0;
    havoc extension_3;
    assume {:nonnull} extension_3 != 0;
    assume extension_3 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    goto L8;

  L8:
    assume {:nonnull} Irp != 0;
    assume Irp > 0;
    assume {:nonnull} Irp != 0;
    assume Irp > 0;
    call {:si_unique_call 95} sdv_IoCompleteRequest(0, 0);
    Tmp_70 := -1073741536;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon22_Then:
    assume {:nonnull} extension_3 != 0;
    assume extension_3 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} extension_3 != 0;
    assume extension_3 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    call {:si_unique_call 96} status := MoxaIRPPrologue(Irp, extension_3);
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} yogi_error != 1;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:partition} status != 0;
    call {:si_unique_call 97} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 98} MoxaIRPEpilogue(extension_3);
    Tmp_70 := status;
    goto L1;

  anon19_Then:
    assume {:partition} status == 0;
    call {:si_unique_call 99} sdv_28 := MoxaCompleteIfError(DeviceObject, Irp);
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:partition} sdv_28 != 0;
    Tmp_70 := -1073741536;
    goto L1;

  anon20_Then:
    assume {:partition} sdv_28 == 0;
    assume {:nonnull} Irp != 0;
    assume Irp > 0;
    call {:si_unique_call 100} sdv_29 := sdv_IoGetCurrentIrpStackLocation(Irp);
    assume {:nonnull} sdv_29 != 0;
    assume sdv_29 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:nonnull} extension_3 != 0;
    assume extension_3 > 0;
    call {:si_unique_call 101} Tmp_70 := MoxaStartOrQueue(extension_3, Irp, ReadQueue__MOXA_DEVICE_EXTENSION(extension_3), CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_3), li2bplFunctionConstant140);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon24_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon21_Then:
    assume {:nonnull} Irp != 0;
    assume Irp > 0;
    call {:si_unique_call 102} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 103} MoxaIRPEpilogue(extension_3);
    Tmp_70 := 0;
    goto L1;

  anon23_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon18_Then:
    goto L8;

  anon17_Then:
    goto L8;
}



procedure {:origName "_sdv_init8"} _sdv_init8();
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init8"} _sdv_init8()
{
  var vslice_dummy_var_16: int;

  anon0:
    call {:si_unique_call 104} vslice_dummy_var_16 := __HAVOC_malloc(4);
    havoc Mem_T.INT4;
    havoc Mem_T.INT4;
    havoc Mem_T.INT4;
    havoc Mem_T.INT4;
    havoc Mem_T.INT4;
    havoc Mem_T.INT4;
    return;
}



procedure {:origName "_sdv_init7"} _sdv_init7();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init7"} _sdv_init7()
{
  var vslice_dummy_var_17: int;

  anon0:
    call {:si_unique_call 105} vslice_dummy_var_17 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaGetRegistryKeyValue"} MoxaGetRegistryKeyValue(actual_Handle: int, actual_KeyNameString: int, actual_KeyNameStringLength: int, actual_Data: int, actual_DataLength: int, actual_ActualLength: int) returns (Tmp_76: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} Tmp_76 == -1073741811 || Tmp_76 == -1073741823 || Tmp_76 == 0 || Tmp_76 == 5 || Tmp_76 == -1073741789 || Tmp_76 == -1073741670;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetRegistryKeyValue"} MoxaGetRegistryKeyValue(actual_Handle: int, actual_KeyNameString: int, actual_KeyNameStringLength: int, actual_Data: int, actual_DataLength: int, actual_ActualLength: int) returns (Tmp_76: int)
{
  var {:pointer} fullInfo: int;
  var {:scalar} length: int;
  var {:pointer} sdv_31: int;
  var {:pointer} Tmp_77: int;
  var {:scalar} ntStatus: int;
  var {:scalar} keyName: int;
  var {:pointer} KeyNameString: int;
  var {:scalar} KeyNameStringLength: int;
  var {:scalar} DataLength: int;
  var {:pointer} ActualLength: int;
  var vslice_dummy_var_1167: int;
  var vslice_dummy_var_1168: int;

  anon0:
    call {:si_unique_call 106} keyName := __HAVOC_malloc(12);
    KeyNameString := actual_KeyNameString;
    KeyNameStringLength := actual_KeyNameStringLength;
    DataLength := actual_DataLength;
    ActualLength := actual_ActualLength;
    ntStatus := -1073741670;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} ActualLength != 0;
    assume {:nonnull} ActualLength != 0;
    assume ActualLength > 0;
    Mem_T.INT4[ActualLength] := 0;
    goto L9;

  L9:
    call {:si_unique_call 107} RtlInitUnicodeString(keyName, KeyNameString);
    length := 24 + KeyNameStringLength + DataLength;
    call {:si_unique_call 108} sdv_31 := ExAllocatePoolWithTag(1, length, -261523379);
    fullInfo := sdv_31;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} fullInfo != 0;
    call {:si_unique_call 109} Tmp_77 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_77 != 0;
    assume Tmp_77 > 0;
    Mem_T.INT4[Tmp_77] := length;
    call {:si_unique_call 110} ntStatus := ZwQueryValueKey(0, 0, 1, 0, length, Tmp_77);
    assume {:nonnull} Tmp_77 != 0;
    assume Tmp_77 > 0;
    length := Mem_T.INT4[Tmp_77];
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} ntStatus >= 0;
    assume {:nonnull} fullInfo != 0;
    assume fullInfo > 0;
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:nonnull} fullInfo != 0;
    assume fullInfo > 0;
    havoc vslice_dummy_var_1167;
    call {:si_unique_call 111} sdv_RtlCopyMemory(0, 0, vslice_dummy_var_1167);
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} ActualLength != 0;
    assume {:nonnull} ActualLength != 0;
    assume ActualLength > 0;
    assume {:nonnull} fullInfo != 0;
    assume fullInfo > 0;
    havoc vslice_dummy_var_1168;
    Mem_T.INT4[ActualLength] := vslice_dummy_var_1168;
    goto L25;

  L25:
    call {:si_unique_call 112} sdv_ExFreePool(0);
    goto L19;

  L19:
    Tmp_76 := ntStatus;
    return;

  anon13_Then:
    assume {:partition} ActualLength == 0;
    goto L25;

  anon12_Then:
    goto L25;

  anon11_Then:
    assume {:partition} 0 > ntStatus;
    goto L25;

  anon15_Then:
    assume {:partition} fullInfo == 0;
    goto L19;

  anon14_Then:
    assume {:partition} ActualLength == 0;
    goto L9;
}



procedure {:origName "MoxaGetProperties"} MoxaGetProperties(actual_Extension_3: int, actual_Properties: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetProperties"} MoxaGetProperties(actual_Extension_3: int, actual_Properties: int)
{
  var {:pointer} Extension_3: int;
  var {:pointer} Properties: int;
  var vslice_dummy_var_18: int;

  anon0:
    call {:si_unique_call 113} vslice_dummy_var_18 := __HAVOC_malloc(4);
    Extension_3 := actual_Extension_3;
    Properties := actual_Properties;
    call {:si_unique_call 114} sdv_RtlZeroMemory(0, 64);
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Extension_3 != 0;
    assume Extension_3 > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Extension_3 != 0;
    assume Extension_3 > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Extension_3 != 0;
    assume Extension_3 > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Extension_3 != 0;
    assume Extension_3 > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    assume {:nonnull} Extension_3 != 0;
    assume Extension_3 > 0;
    assume {:nonnull} Properties != 0;
    assume Properties > 0;
    return;
}



procedure {:origName "_sdv_init13"} _sdv_init13();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init13"} _sdv_init13()
{
  var vslice_dummy_var_19: int;

  anon0:
    call {:si_unique_call 115} vslice_dummy_var_19 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaIoControl"} MoxaIoControl(actual_DeviceObject_1: int, actual_Irp_1: int) returns (Tmp_83: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, Mem_T.CancelIrql__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIoControl"} MoxaIoControl(actual_DeviceObject_1: int, actual_Irp_1: int) returns (Tmp_83: int)
{
  var {:scalar} lStop: int;
  var {:pointer} Tmp_84: int;
  var {:scalar} Tmp_85: int;
  var {:scalar} card: int;
  var {:scalar} Tmp_86: int;
  var {:pointer} Tmp_87: int;
  var {:scalar} size: int;
  var {:pointer} Bh: int;
  var {:pointer} Tmp_88: int;
  var {:pointer} Tmp_89: int;
  var {:scalar} Tmp_90: int;
  var {:pointer} Tmp_91: int;
  var {:pointer} irpSp_1: int;
  var {:scalar} Tmp_92: int;
  var {:scalar} Tmp_93: int;
  var {:pointer} Tmp_94: int;
  var {:pointer} Tmp_95: int;
  var {:pointer} Tmp_96: int;
  var {:scalar} len: int;
  var {:scalar} newMask: int;
  var {:scalar} Tmp_97: int;
  var {:scalar} ndx: int;
  var {:scalar} port: int;
  var {:scalar} sdv_33: int;
  var {:pointer} Tmp_98: int;
  var {:pointer} Br: int;
  var {:scalar} Tmp_99: int;
  var {:pointer} Tmp_100: int;
  var {:scalar} Tmp_101: int;
  var {:scalar} Tmp_102: int;
  var {:scalar} sdv_35: int;
  var {:scalar} cardNo: int;
  var {:scalar} Tmp_103: int;
  var {:pointer} Tmp_104: int;
  var {:scalar} Tmp_105: int;
  var {:scalar} Tmp_106: int;
  var {:scalar} Tmp_107: int;
  var {:scalar} Tmp_108: int;
  var {:scalar} Tmp_109: int;
  var {:pointer} Tmp_110: int;
  var {:dopa} {:scalar} data: int;
  var {:scalar} Tmp_112: int;
  var {:scalar} card_1: int;
  var {:pointer} Tmp_113: int;
  var {:scalar} Tmp_114: int;
  var {:scalar} Tmp_115: int;
  var {:pointer} Gd: int;
  var {:pointer} Tmp_116: int;
  var {:pointer} Tmp_117: int;
  var {:scalar} Tmp_118: int;
  var {:scalar} mode: int;
  var {:scalar} mask: int;
  var {:pointer} Tmp_119: int;
  var {:scalar} Tmp_120: int;
  var {:scalar} Tmp_121: int;
  var {:pointer} Tmp_122: int;
  var {:pointer} Tmp_123: int;
  var {:pointer} Tmp_124: int;
  var {:pointer} ext: int;
  var {:scalar} portNo: int;
  var {:scalar} Tmp_125: int;
  var {:scalar} Tmp_126: int;
  var {:scalar} nn: int;
  var {:scalar} i: int;
  var {:scalar} count_1: int;
  var {:scalar} lParity: int;
  var {:scalar} old_1: int;
  var {:pointer} St: int;
  var {:pointer} Tmp_127: int;
  var {:pointer} Tmp_128: int;
  var {:pointer} Tmp_129: int;
  var {:pointer} buff: int;
  var {:pointer} Tmp_130: int;
  var {:pointer} Tmp_131: int;
  var {:scalar} Tmp_132: int;
  var {:pointer} Tmp_133: int;
  var {:pointer} ofs_1: int;
  var {:pointer} Tmp_134: int;
  var {:scalar} len_1: int;
  var {:pointer} Tmp_135: int;
  var {:pointer} ofs_2: int;
  var {:scalar} Tmp_136: int;
  var {:pointer} Tmp_137: int;
  var {:scalar} Tmp_138: int;
  var {:pointer} Tmp_139: int;
  var {:scalar} S: int;
  var {:scalar} ndx_1: int;
  var {:pointer} Tmp_140: int;
  var {:pointer} Gd_1: int;
  var {:pointer} Tmp_141: int;
  var {:pointer} Tmp_142: int;
  var {:scalar} Tmp_143: int;
  var {:scalar} Tmp_144: int;
  var {:pointer} Tmp_145: int;
  var {:pointer} Tmp_146: int;
  var {:scalar} Tmp_147: int;
  var {:pointer} Tmp_148: int;
  var {:scalar} ofs_3: int;
  var {:scalar} ofs_4: int;
  var {:pointer} Tmp_149: int;
  var {:scalar} modemControl: int;
  var {:pointer} Tmp_150: int;
  var {:scalar} Tmp_151: int;
  var {:pointer} Tmp_152: int;
  var {:scalar} Tmp_153: int;
  var {:scalar} Tmp_154: int;
  var {:pointer} Tmp_155: int;
  var {:scalar} lData: int;
  var {:scalar} Tmp_156: int;
  var {:pointer} Gd_2: int;
  var {:scalar} Tmp_157: int;
  var {:pointer} base: int;
  var {:pointer} com: int;
  var {:scalar} Tmp_159: int;
  var {:scalar} status_1: int;
  var {:scalar} Tmp_160: int;
  var {:scalar} Tmp_161: int;
  var {:scalar} sdv_42: int;
  var {:scalar} Tmp_162: int;
  var {:pointer} Tmp_163: int;
  var {:pointer} Tmp_164: int;
  var {:scalar} Tmp_165: int;
  var {:scalar} Tmp_166: int;
  var {:pointer} Gd_3: int;
  var {:scalar} Tmp_167: int;
  var {:pointer} Ps: int;
  var {:pointer} Tmp_168: int;
  var {:scalar} card_2: int;
  var {:pointer} Tmp_169: int;
  var {:pointer} Tmp_170: int;
  var {:scalar} Tmp_171: int;
  var {:scalar} count_2: int;
  var {:pointer} Ms: int;
  var {:scalar} Tmp_172: int;
  var {:pointer} ofs_5: int;
  var {:scalar} Tmp_173: int;
  var {:pointer} Tmp_174: int;
  var {:scalar} comNo: int;
  var {:pointer} Tmp_175: int;
  var {:pointer} handFlow: int;
  var {:pointer} Tmp_176: int;
  var {:scalar} Tmp_177: int;
  var {:pointer} Tmp_178: int;
  var {:scalar} Tmp_179: int;
  var {:pointer} Tmp_180: int;
  var {:pointer} Tmp_181: int;
  var {:scalar} Tmp_182: int;
  var {:scalar} Tmp_183: int;
  var {:pointer} Lc: int;
  var {:pointer} Fi: int;
  var {:pointer} Tmp_184: int;
  var {:pointer} Gd_4: int;
  var {:pointer} Tmp_185: int;
  var {:scalar} Tmp_186: int;
  var {:scalar} lowWater: int;
  var {:scalar} Tmp_187: int;
  var {:scalar} Tmp_188: int;
  var {:scalar} Tmp_189: int;
  var {:scalar} ofs_6: int;
  var {:pointer} Tmp_190: int;
  var {:pointer} base_1: int;
  var {:scalar} Tmp_191: int;
  var {:pointer} Tmp_192: int;
  var {:scalar} Tmp_193: int;
  var {:scalar} sdv_46: int;
  var {:dopa} {:scalar} divisor: int;
  var {:scalar} Tmp_194: int;
  var {:scalar} c: int;
  var {:scalar} Tmp_195: int;
  var {:scalar} Tmp_196: int;
  var {:scalar} Tmp_197: int;
  var {:pointer} Tmp_198: int;
  var {:scalar} card_3: int;
  var {:scalar} Tmp_199: int;
  var {:pointer} Gd_5: int;
  var {:pointer} Tmp_200: int;
  var {:scalar} oldIrql_4: int;
  var {:scalar} Tmp_201: int;
  var {:scalar} Tmp_202: int;
  var {:pointer} Tmp_203: int;
  var {:scalar} baudRate: int;
  var {:scalar} Tmp_204: int;
  var {:scalar} Tmp_205: int;
  var {:scalar} Tmp_206: int;
  var {:scalar} Tmp_207: int;
  var {:pointer} newChars: int;
  var {:scalar} Tmp_208: int;
  var {:scalar} Tmp_209: int;
  var {:pointer} Tmp_210: int;
  var {:scalar} cardNo_1: int;
  var {:scalar} ioControlCode_1: int;
  var {:scalar} Tmp_211: int;
  var {:pointer} Tmp_212: int;
  var {:pointer} Wd: int;
  var {:scalar} arg: int;
  var {:scalar} ier: int;
  var {:pointer} Tmp_213: int;
  var {:pointer} Tmp_214: int;
  var {:pointer} Tmp_215: int;
  var {:pointer} Tmp_216: int;
  var {:pointer} Tmp_217: int;
  var {:pointer} Tmp_218: int;
  var {:pointer} extension_4: int;
  var {:pointer} Tmp_219: int;
  var {:pointer} newTimeouts: int;
  var {:pointer} Tmp_220: int;
  var {:pointer} Tmp_221: int;
  var {:scalar} Tmp_222: int;
  var {:scalar} Tmp_223: int;
  var {:pointer} Tmp_224: int;
  var {:scalar} Tmp_225: int;
  var {:scalar} Tmp_226: int;
  var {:pointer} base_2: int;
  var {:scalar} Tmp_227: int;
  var {:pointer} Tmp_228: int;
  var {:scalar} arg_1: int;
  var {:pointer} Tmp_229: int;
  var {:pointer} Tmp_230: int;
  var {:scalar} Tmp_231: int;
  var {:pointer} Tmp_232: int;
  var {:pointer} Tmp_233: int;
  var {:scalar} mask_1: int;
  var {:pointer} Tmp_234: int;
  var {:scalar} Tmp_235: int;
  var {:pointer} Tmp_236: int;
  var {:scalar} Tmp_237: int;
  var {:scalar} S_1: int;
  var {:scalar} Tmp_238: int;
  var {:scalar} Tmp_239: int;
  var {:scalar} ndx_2: int;
  var {:pointer} Tmp_240: int;
  var {:scalar} Tmp_241: int;
  var {:pointer} comNo_1: int;
  var {:pointer} Tmp_242: int;
  var {:scalar} Tmp_243: int;
  var {:pointer} Tmp_244: int;
  var {:pointer} Tmp_245: int;
  var {:scalar} Tmp_246: int;
  var {:scalar} Tmp_247: int;
  var {:pointer} Tmp_248: int;
  var {:scalar} Tmp_249: int;
  var {:scalar} Tmp_250: int;
  var {:pointer} base_3: int;
  var {:scalar} Tmp_251: int;
  var {:scalar} Tmp_252: int;
  var {:scalar} len_2: int;
  var {:scalar} Tmp_253: int;
  var {:pointer} Tmp_254: int;
  var {:scalar} Tmp_255: int;
  var {:scalar} ndx_3: int;
  var {:dopa} {:scalar} data_1: int;
  var {:scalar} portNo_1: int;
  var {:scalar} Tmp_256: int;
  var {:scalar} Tmp_257: int;
  var {:scalar} Tmp_258: int;
  var {:pointer} Lc_1: int;
  var {:pointer} Tmp_259: int;
  var {:scalar} Tmp_260: int;
  var {:pointer} DeviceObject_1: int;
  var {:pointer} Irp_1: int;
  var boogieTmp: int;
  var vslice_dummy_var_20: int;
  var vslice_dummy_var_21: int;
  var vslice_dummy_var_22: int;
  var vslice_dummy_var_23: int;
  var vslice_dummy_var_24: int;
  var vslice_dummy_var_25: int;
  var vslice_dummy_var_26: int;
  var vslice_dummy_var_1169: int;
  var vslice_dummy_var_1170: int;
  var vslice_dummy_var_1171: int;
  var vslice_dummy_var_1172: int;
  var vslice_dummy_var_1173: int;
  var vslice_dummy_var_1174: int;
  var vslice_dummy_var_1175: int;
  var vslice_dummy_var_1176: int;
  var vslice_dummy_var_1177: int;
  var vslice_dummy_var_1178: int;
  var vslice_dummy_var_1179: int;
  var vslice_dummy_var_1180: int;
  var vslice_dummy_var_1181: int;
  var vslice_dummy_var_1182: int;
  var vslice_dummy_var_1183: int;
  var vslice_dummy_var_1184: int;
  var vslice_dummy_var_1185: int;
  var vslice_dummy_var_1186: int;
  var vslice_dummy_var_1187: int;
  var vslice_dummy_var_1188: int;
  var vslice_dummy_var_1189: int;
  var vslice_dummy_var_1190: int;
  var vslice_dummy_var_1191: int;
  var vslice_dummy_var_1192: int;
  var vslice_dummy_var_1193: int;
  var vslice_dummy_var_1194: int;
  var vslice_dummy_var_1195: int;
  var vslice_dummy_var_1196: int;
  var vslice_dummy_var_1197: int;

  anon0:
    call {:si_unique_call 116} data := __HAVOC_malloc(4);
    call {:si_unique_call 117} S := __HAVOC_malloc(8);
    call {:si_unique_call 118} divisor := __HAVOC_malloc(4);
    call {:si_unique_call 119} S_1 := __HAVOC_malloc(8);
    call {:si_unique_call 120} data_1 := __HAVOC_malloc(4);
    DeviceObject_1 := actual_DeviceObject_1;
    Irp_1 := actual_Irp_1;
    call {:si_unique_call 121} Tmp_88 := __HAVOC_malloc(16);
    call {:si_unique_call 122} Tmp_96 := __HAVOC_malloc(16);
    call {:si_unique_call 123} Tmp_100 := __HAVOC_malloc(80);
    call {:si_unique_call 124} Tmp_127 := __HAVOC_malloc(16);
    call {:si_unique_call 125} Tmp_131 := __HAVOC_malloc(16);
    call {:si_unique_call 126} Tmp_134 := __HAVOC_malloc(16);
    call {:si_unique_call 127} Tmp_137 := __HAVOC_malloc(512);
    call {:si_unique_call 128} Tmp_141 := __HAVOC_malloc(16);
    call {:si_unique_call 129} Tmp_152 := __HAVOC_malloc(16);
    call {:si_unique_call 130} Tmp_163 := __HAVOC_malloc(16);
    call {:si_unique_call 131} Tmp_174 := __HAVOC_malloc(80);
    call {:si_unique_call 132} Tmp_184 := __HAVOC_malloc(16);
    call {:si_unique_call 133} Tmp_198 := __HAVOC_malloc(16);
    call {:si_unique_call 134} Tmp_203 := __HAVOC_malloc(4);
    call {:si_unique_call 135} Tmp_213 := __HAVOC_malloc(16);
    call {:si_unique_call 136} Tmp_220 := __HAVOC_malloc(80);
    call {:si_unique_call 137} Tmp_233 := __HAVOC_malloc(16);
    call {:si_unique_call 138} Tmp_234 := __HAVOC_malloc(80);
    call {:si_unique_call 139} Tmp_236 := __HAVOC_malloc(16);
    call {:si_unique_call 140} Tmp_240 := __HAVOC_malloc(16);
    call {:si_unique_call 141} comNo_1 := __HAVOC_malloc(8);
    call {:si_unique_call 142} Tmp_259 := __HAVOC_malloc(16);
    assume {:nonnull} DeviceObject_1 != 0;
    assume DeviceObject_1 > 0;
    havoc extension_4;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon678_Then, anon678_Else;

  anon678_Else:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 143} sdv_IoCompleteRequest(0, 0);
    Tmp_83 := -1073741808;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon678_Then:
    call {:si_unique_call 144} irpSp_1 := sdv_IoGetCurrentIrpStackLocation(Irp_1);
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    havoc ioControlCode_1;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon679_Then, anon679_Else;

  anon679_Else:
    goto anon511_Then, anon511_Else;

  anon511_Else:
    assume {:partition} ioControlCode_1 != 1778064;
    goto anon512_Then, anon512_Else;

  anon512_Else:
    assume {:partition} ioControlCode_1 != 1778068;
    goto anon513_Then, anon513_Else;

  anon513_Else:
    assume {:partition} ioControlCode_1 != 1778072;
    goto anon514_Then, anon514_Else;

  anon514_Else:
    assume {:partition} ioControlCode_1 != 1778076;
    goto anon515_Then, anon515_Else;

  anon515_Else:
    assume {:partition} ioControlCode_1 != 1777728;
    goto anon516_Then, anon516_Else;

  anon516_Else:
    assume {:partition} ioControlCode_1 != 1777772;
    goto anon517_Then, anon517_Else;

  anon517_Else:
    assume {:partition} ioControlCode_1 != 1777748;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 145} sdv_IoCompleteRequest(0, 0);
    Tmp_83 := -1073741808;
    goto L1;

  anon517_Then:
    assume {:partition} ioControlCode_1 == 1777748;
    goto L25;

  L25:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    status_1 := 0;
    goto anon680_Then, anon680_Else;

  anon680_Else:
    assume {:partition} ioControlCode_1 != 1769476;
    goto anon668_Then, anon668_Else;

  anon668_Else:
    assume {:partition} ioControlCode_1 != 1769480;
    goto anon667_Then, anon667_Else;

  anon667_Else:
    assume {:partition} ioControlCode_1 != 1769484;
    goto anon666_Then, anon666_Else;

  anon666_Else:
    assume {:partition} ioControlCode_1 != 1769488;
    goto anon665_Then, anon665_Else;

  anon665_Else:
    assume {:partition} ioControlCode_1 != 1769492;
    goto anon664_Then, anon664_Else;

  anon664_Else:
    assume {:partition} ioControlCode_1 != 1769496;
    goto anon663_Then, anon663_Else;

  anon663_Else:
    assume {:partition} ioControlCode_1 != 1769500;
    goto anon662_Then, anon662_Else;

  anon662_Else:
    assume {:partition} ioControlCode_1 != 1769504;
    goto anon661_Then, anon661_Else;

  anon661_Else:
    assume {:partition} ioControlCode_1 != 1769508;
    goto anon660_Then, anon660_Else;

  anon660_Else:
    assume {:partition} ioControlCode_1 != 1769512;
    goto anon659_Then, anon659_Else;

  anon659_Else:
    assume {:partition} ioControlCode_1 != 1769516;
    goto anon658_Then, anon658_Else;

  anon658_Else:
    assume {:partition} ioControlCode_1 != 1769520;
    goto anon657_Then, anon657_Else;

  anon657_Else:
    assume {:partition} ioControlCode_1 != 1769524;
    goto anon656_Then, anon656_Else;

  anon656_Else:
    assume {:partition} ioControlCode_1 != 1769528;
    goto anon655_Then, anon655_Else;

  anon655_Else:
    assume {:partition} ioControlCode_1 != 1769532;
    goto anon654_Then, anon654_Else;

  anon654_Else:
    assume {:partition} ioControlCode_1 != 1769536;
    goto anon653_Then, anon653_Else;

  anon653_Else:
    assume {:partition} ioControlCode_1 != 1769540;
    goto anon652_Then, anon652_Else;

  anon652_Else:
    assume {:partition} ioControlCode_1 != 1769544;
    goto anon651_Then, anon651_Else;

  anon651_Else:
    assume {:partition} ioControlCode_1 != 1769548;
    goto anon650_Then, anon650_Else;

  anon650_Else:
    assume {:partition} ioControlCode_1 != 1769552;
    goto anon649_Then, anon649_Else;

  anon649_Else:
    assume {:partition} ioControlCode_1 != 1769556;
    goto anon648_Then, anon648_Else;

  anon648_Else:
    assume {:partition} ioControlCode_1 != 1769560;
    goto anon647_Then, anon647_Else;

  anon647_Else:
    assume {:partition} ioControlCode_1 != 1769564;
    goto anon646_Then, anon646_Else;

  anon646_Else:
    assume {:partition} ioControlCode_1 != 1769568;
    goto anon645_Then, anon645_Else;

  anon645_Else:
    assume {:partition} ioControlCode_1 != 1769572;
    goto anon644_Then, anon644_Else;

  anon644_Else:
    assume {:partition} ioControlCode_1 != 1769576;
    goto anon643_Then, anon643_Else;

  anon643_Else:
    assume {:partition} ioControlCode_1 != 1769580;
    goto anon642_Then, anon642_Else;

  anon642_Else:
    assume {:partition} ioControlCode_1 != 1769584;
    goto anon641_Then, anon641_Else;

  anon641_Else:
    assume {:partition} ioControlCode_1 != 1769588;
    goto anon640_Then, anon640_Else;

  anon640_Else:
    assume {:partition} ioControlCode_1 != 1769592;
    goto anon639_Then, anon639_Else;

  anon639_Else:
    assume {:partition} ioControlCode_1 != 1769596;
    goto anon638_Then, anon638_Else;

  anon638_Else:
    assume {:partition} ioControlCode_1 != 1769600;
    goto anon637_Then, anon637_Else;

  anon637_Else:
    assume {:partition} ioControlCode_1 != 1769612;
    goto anon636_Then, anon636_Else;

  anon636_Else:
    assume {:partition} ioControlCode_1 != 1769616;
    goto anon635_Then, anon635_Else;

  anon635_Else:
    assume {:partition} ioControlCode_1 != 1777664;
    goto anon634_Then, anon634_Else;

  anon634_Else:
    assume {:partition} ioControlCode_1 != 1777688;
    goto anon633_Then, anon633_Else;

  anon633_Else:
    assume {:partition} ioControlCode_1 != 1777708;
    goto anon632_Then, anon632_Else;

  anon632_Else:
    assume {:partition} ioControlCode_1 != 1777716;
    goto anon631_Then, anon631_Else;

  anon631_Else:
    assume {:partition} ioControlCode_1 != 1777720;
    goto anon630_Then, anon630_Else;

  anon630_Else:
    assume {:partition} ioControlCode_1 != 1777724;
    goto anon629_Then, anon629_Else;

  anon629_Else:
    assume {:partition} ioControlCode_1 != 1777728;
    goto anon628_Then, anon628_Else;

  anon628_Else:
    assume {:partition} ioControlCode_1 != 1777732;
    goto anon627_Then, anon627_Else;

  anon627_Else:
    assume {:partition} ioControlCode_1 != 1777736;
    goto anon626_Then, anon626_Else;

  anon626_Else:
    assume {:partition} ioControlCode_1 != 1777740;
    goto anon625_Then, anon625_Else;

  anon625_Else:
    assume {:partition} ioControlCode_1 != 1777744;
    goto anon624_Then, anon624_Else;

  anon624_Else:
    assume {:partition} ioControlCode_1 != 1777748;
    goto anon623_Then, anon623_Else;

  anon623_Else:
    assume {:partition} ioControlCode_1 != 1777772;
    goto anon622_Then, anon622_Else;

  anon622_Else:
    assume {:partition} ioControlCode_1 != 1778064;
    goto anon621_Then, anon621_Else;

  anon621_Else:
    assume {:partition} ioControlCode_1 != 1778068;
    goto anon620_Then, anon620_Else;

  anon620_Else:
    assume {:partition} ioControlCode_1 != 1778072;
    goto anon619_Then, anon619_Else;

  anon619_Else:
    assume {:partition} ioControlCode_1 == 1778076;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Fi;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd_1;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon763_Then, anon763_Else;

  anon763_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon533_Then, anon533_Else;

  anon533_Else:
    status_1 := -1073741789;
    goto L110;

  L110:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon681_Then, anon681_Else;

  anon681_Else:
    call {:si_unique_call 146} sdv_IoCompleteRequest(0, 0);
    goto L118;

  L118:
    Tmp_83 := status_1;
    goto L1;

  anon681_Then:
    call {:si_unique_call 147} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 148} MoxaIRPEpilogue(extension_4);
    goto L118;

  anon533_Then:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon534_Then, anon534_Else;

  anon534_Else:
    status_1 := -1073741789;
    goto L110;

  anon534_Then:
    card_1 := 0;
    goto L125;

  L125:
    call {:si_unique_call 149} card_1, Tmp_144, Tmp_174 := MoxaIoControl_loop_L125(card_1, Gd_1, Tmp_144, Tmp_174, Fi);
    goto L125_last;

  L125_last:
    assume {:CounterLoop 4} {:Counter "card_1"} true;
    goto anon535_Then, anon535_Else;

  anon535_Else:
    assume {:partition} 4 > card_1;
    Tmp_144 := card_1;
    assume {:nonnull} Gd_1 != 0;
    assume Gd_1 > 0;
    havoc Tmp_174;
    assume {:nonnull} Fi != 0;
    assume Fi > 0;
    assume {:nonnull} Tmp_174 != 0;
    assume Tmp_174 > 0;
    goto anon764_Then, anon764_Else;

  anon764_Else:
    card_1 := card_1 + 1;
    goto anon764_Else_dummy;

  anon764_Else_dummy:
    assume false;
    return;

  anon764_Then:
    goto L126;

  L126:
    goto anon536_Then, anon536_Else;

  anon536_Else:
    assume {:partition} card_1 == 4;
    status_1 := -1073741811;
    goto L110;

  anon536_Then:
    assume {:partition} card_1 != 4;
    Tmp_206 := card_1;
    assume {:nonnull} Gd_1 != 0;
    assume Gd_1 > 0;
    havoc Tmp_198;
    assume {:nonnull} Tmp_198 != 0;
    assume Tmp_198 > 0;
    havoc base;
    assume {:nonnull} Fi != 0;
    assume Fi > 0;
    havoc ofs_3;
    assume {:nonnull} Fi != 0;
    assume Fi > 0;
    havoc len;
    ndx := 0;
    goto L136;

  L136:
    call {:si_unique_call 150} ndx, Tmp_238 := MoxaIoControl_loop_L136(len, ndx, ofs_3, base, Fi, Tmp_238);
    goto L136_last;

  L136_last:
    goto anon537_Then, anon537_Else;

  anon537_Else:
    assume {:partition} len > ndx;
    goto anon538_Then, anon538_Else;

  anon538_Else:
    assume {:partition} ndx + ofs_3 < 16384;
    Tmp_238 := ofs_3 + ndx;
    assume {:nonnull} Fi != 0;
    assume Fi > 0;
    assume {:nonnull} base != 0;
    assume base > 0;
    havoc vslice_dummy_var_1169;
    Mem_T.INT4[base + Tmp_238 * 4] := vslice_dummy_var_1169;
    ndx := ndx + 1;
    goto anon538_Else_dummy;

  anon538_Else_dummy:
    assume false;
    return;

  anon538_Then:
    assume {:partition} 16384 <= ndx + ofs_3;
    goto L137;

  L137:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_221;
    assume {:nonnull} Tmp_221 != 0;
    assume Tmp_221 > 0;
    Mem_T.INT4[Tmp_221] := ndx;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon537_Then:
    assume {:partition} ndx >= len;
    goto L137;

  anon535_Then:
    assume {:partition} card_1 >= 4;
    goto L126;

  anon763_Then:
    status_1 := -1073741811;
    goto L110;

  anon619_Then:
    assume {:partition} ioControlCode_1 != 1778076;
    status_1 := -1073741811;
    goto L110;

  anon620_Then:
    assume {:partition} ioControlCode_1 == 1778072;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Wd;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd_2;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon760_Then, anon760_Else;

  anon760_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon539_Then, anon539_Else;

  anon539_Else:
    status_1 := -1073741789;
    goto L110;

  anon539_Then:
    card := 0;
    goto L159;

  L159:
    call {:si_unique_call 151} card, Tmp_179, Tmp_220 := MoxaIoControl_loop_L159(card, Gd_2, Tmp_179, Wd, Tmp_220);
    goto L159_last;

  L159_last:
    assume {:CounterLoop 4} {:Counter "card"} true;
    goto anon540_Then, anon540_Else;

  anon540_Else:
    assume {:partition} 4 > card;
    Tmp_179 := card;
    assume {:nonnull} Gd_2 != 0;
    assume Gd_2 > 0;
    havoc Tmp_220;
    assume {:nonnull} Tmp_220 != 0;
    assume Tmp_220 > 0;
    assume {:nonnull} Wd != 0;
    assume Wd > 0;
    goto anon761_Then, anon761_Else;

  anon761_Else:
    card := card + 1;
    goto anon761_Else_dummy;

  anon761_Else_dummy:
    assume false;
    return;

  anon761_Then:
    goto L160;

  L160:
    goto anon541_Then, anon541_Else;

  anon541_Else:
    assume {:partition} card == 4;
    status_1 := -1073741811;
    goto L110;

  anon541_Then:
    assume {:partition} card != 4;
    Tmp_165 := card;
    assume {:nonnull} Gd_2 != 0;
    assume Gd_2 > 0;
    havoc Tmp_236;
    assume {:nonnull} Tmp_236 != 0;
    assume Tmp_236 > 0;
    havoc base_3;
    assume {:nonnull} Wd != 0;
    assume Wd > 0;
    havoc ofs_4;
    assume {:nonnull} Wd != 0;
    assume Wd > 0;
    havoc len_2;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon762_Then, anon762_Else;

  anon762_Else:
    status_1 := -1073741789;
    goto L110;

  anon762_Then:
    ndx_2 := 0;
    goto L173;

  L173:
    call {:si_unique_call 152} Tmp_187, Tmp_203, ndx_2, Tmp_257 := MoxaIoControl_loop_L173(ofs_4, Tmp_187, Tmp_203, Wd, ndx_2, base_3, len_2, Tmp_257);
    goto L173_last;

  L173_last:
    goto anon542_Then, anon542_Else;

  anon542_Else:
    assume {:partition} len_2 > ndx_2;
    goto anon543_Then, anon543_Else;

  anon543_Else:
    assume {:partition} ndx_2 + ofs_4 < 16384;
    Tmp_187 := ofs_4 + ndx_2;
    Tmp_257 := ndx_2;
    assume {:nonnull} Wd != 0;
    assume Wd > 0;
    havoc Tmp_203;
    assume {:nonnull} Tmp_203 != 0;
    assume Tmp_203 > 0;
    assume {:nonnull} base_3 != 0;
    assume base_3 > 0;
    Mem_T.INT4[base_3 + Tmp_187 * 4] := Mem_T.INT4[Tmp_203 + Tmp_257 * 4];
    ndx_2 := ndx_2 + 1;
    goto anon543_Else_dummy;

  anon543_Else_dummy:
    assume false;
    return;

  anon543_Then:
    assume {:partition} 16384 <= ndx_2 + ofs_4;
    goto L174;

  L174:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_217;
    assume {:nonnull} Tmp_217 != 0;
    assume Tmp_217 > 0;
    Mem_T.INT4[Tmp_217] := ndx_2;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon542_Then:
    assume {:partition} ndx_2 >= len_2;
    goto L174;

  anon540_Then:
    assume {:partition} card >= 4;
    goto L160;

  anon760_Then:
    status_1 := -1073741811;
    goto L110;

  anon621_Then:
    assume {:partition} ioControlCode_1 == 1778068;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Bh;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd_5;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon757_Then, anon757_Else;

  anon757_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon544_Then, anon544_Else;

  anon544_Else:
    status_1 := -1073741789;
    goto L110;

  anon544_Then:
    card_3 := 0;
    goto L197;

  L197:
    call {:si_unique_call 153} Tmp_100, card_3, Tmp_247 := MoxaIoControl_loop_L197(Bh, Tmp_100, card_3, Gd_5, Tmp_247);
    goto L197_last;

  L197_last:
    assume {:CounterLoop 4} {:Counter "card_3"} true;
    goto anon545_Then, anon545_Else;

  anon545_Else:
    assume {:partition} 4 > card_3;
    Tmp_247 := card_3;
    assume {:nonnull} Gd_5 != 0;
    assume Gd_5 > 0;
    havoc Tmp_100;
    assume {:nonnull} Bh != 0;
    assume Bh > 0;
    assume {:nonnull} Tmp_100 != 0;
    assume Tmp_100 > 0;
    goto anon758_Then, anon758_Else;

  anon758_Else:
    card_3 := card_3 + 1;
    goto anon758_Else_dummy;

  anon758_Else_dummy:
    assume false;
    return;

  anon758_Then:
    goto L198;

  L198:
    goto anon546_Then, anon546_Else;

  anon546_Else:
    assume {:partition} card_3 == 4;
    status_1 := -1073741811;
    goto L110;

  anon546_Then:
    assume {:partition} card_3 != 4;
    Tmp_121 := card_3;
    assume {:nonnull} Gd_5 != 0;
    assume Gd_5 > 0;
    havoc Tmp_134;
    assume {:nonnull} Tmp_134 != 0;
    assume Tmp_134 > 0;
    havoc base_2;
    assume {:nonnull} Bh != 0;
    assume Bh > 0;
    havoc ofs_6;
    assume {:nonnull} Bh != 0;
    assume Bh > 0;
    havoc len_1;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon759_Then, anon759_Else;

  anon759_Else:
    status_1 := -1073741789;
    goto L110;

  anon759_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc buff;
    ndx_3 := 0;
    goto L212;

  L212:
    call {:si_unique_call 154} Tmp_93, Tmp_138, ndx_3 := MoxaIoControl_loop_L212(Tmp_93, buff, len_1, Tmp_138, ofs_6, base_2, ndx_3);
    goto L212_last;

  L212_last:
    goto anon547_Then, anon547_Else;

  anon547_Else:
    assume {:partition} len_1 > ndx_3;
    goto anon548_Then, anon548_Else;

  anon548_Else:
    assume {:partition} ndx_3 + ofs_6 < 16384;
    Tmp_93 := ndx_3;
    Tmp_138 := ofs_6 + ndx_3;
    assume {:nonnull} base_2 != 0;
    assume base_2 > 0;
    assume {:nonnull} buff != 0;
    assume buff > 0;
    Mem_T.INT4[buff + Tmp_93 * 4] := Mem_T.INT4[base_2 + Tmp_138 * 4];
    ndx_3 := ndx_3 + 1;
    goto anon548_Else_dummy;

  anon548_Else_dummy:
    assume false;
    return;

  anon548_Then:
    assume {:partition} 16384 <= ndx_3 + ofs_6;
    goto L213;

  L213:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon547_Then:
    assume {:partition} ndx_3 >= len_1;
    goto L213;

  anon545_Then:
    assume {:partition} card_3 >= 4;
    goto L198;

  anon757_Then:
    status_1 := -1073741811;
    goto L110;

  anon622_Then:
    assume {:partition} ioControlCode_1 == 1778064;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Ms;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd_3;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon755_Then, anon755_Else;

  anon755_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon549_Then, anon549_Else;

  anon549_Else:
    status_1 := -1073741789;
    goto L110;

  anon549_Then:
    card_2 := 0;
    goto L230;

  L230:
    call {:si_unique_call 155} Tmp_96, Tmp_106, Tmp_108, Tmp_131, Tmp_163, card_2, Tmp_193, Tmp_207, Tmp_231, Tmp_234, Tmp_240 := MoxaIoControl_loop_L230(Tmp_96, Tmp_106, Tmp_108, Tmp_131, Tmp_163, Gd_3, card_2, Ms, Tmp_193, Tmp_207, Tmp_231, Tmp_234, Tmp_240);
    goto L230_last;

  L230_last:
    assume {:CounterLoop 4} {:Counter "card_2"} true;
    goto anon550_Then, anon550_Else;

  anon550_Else:
    assume {:partition} 4 > card_2;
    Tmp_106 := card_2;
    assume {:nonnull} Gd_3 != 0;
    assume Gd_3 > 0;
    havoc Tmp_163;
    assume {:nonnull} Tmp_163 != 0;
    assume Tmp_163 > 0;
    goto anon756_Then, anon756_Else;

  anon756_Else:
    assume {:partition} Mem_T.INT4[Tmp_163 + Tmp_106 * 4] != 0;
    Tmp_108 := card_2;
    assume {:nonnull} Ms != 0;
    assume Ms > 0;
    havoc Tmp_131;
    Tmp_231 := card_2;
    assume {:nonnull} Gd_3 != 0;
    assume Gd_3 > 0;
    havoc Tmp_240;
    assume {:nonnull} Tmp_131 != 0;
    assume Tmp_131 > 0;
    assume {:nonnull} Tmp_240 != 0;
    assume Tmp_240 > 0;
    Mem_T.INT4[Tmp_131 + Tmp_108 * 4] := Mem_T.INT4[Tmp_240 + Tmp_231 * 4];
    Tmp_193 := card_2;
    assume {:nonnull} Ms != 0;
    assume Ms > 0;
    havoc Tmp_96;
    Tmp_207 := card_2;
    assume {:nonnull} Gd_3 != 0;
    assume Gd_3 > 0;
    havoc Tmp_234;
    assume {:nonnull} Tmp_234 != 0;
    assume Tmp_234 > 0;
    assume {:nonnull} Tmp_96 != 0;
    assume Tmp_96 > 0;
    havoc vslice_dummy_var_1170;
    Mem_T.INT4[Tmp_96 + Tmp_193 * 4] := vslice_dummy_var_1170;
    card_2 := card_2 + 1;
    goto anon756_Else_dummy;

  anon756_Else_dummy:
    assume false;
    return;

  anon756_Then:
    assume {:partition} Mem_T.INT4[Tmp_163 + Tmp_106 * 4] == 0;
    goto L231;

  L231:
    assume {:nonnull} Ms != 0;
    assume Ms > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon550_Then:
    assume {:partition} card_2 >= 4;
    goto L231;

  anon755_Then:
    status_1 := -1073741811;
    goto L110;

  anon623_Then:
    assume {:partition} ioControlCode_1 == 1777772;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd_4;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon748_Then, anon748_Else;

  anon748_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon551_Then, anon551_Else;

  anon551_Else:
    status_1 := -1073741789;
    goto L110;

  anon551_Then:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon552_Then, anon552_Else;

  anon552_Else:
    status_1 := -1073741789;
    goto L110;

  anon552_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_254;
    assume {:nonnull} Tmp_254 != 0;
    assume Tmp_254 > 0;
    cardNo_1 := Mem_T.INT4[Tmp_254];
    goto anon749_Then, anon749_Else;

  anon749_Else:
    assume {:partition} cardNo_1 >= 4;
    status_1 := -1073741811;
    goto L110;

  anon749_Then:
    assume {:partition} 4 > cardNo_1;
    Tmp_99 := cardNo_1;
    assume {:nonnull} Gd_4 != 0;
    assume Gd_4 > 0;
    havoc Tmp_213;
    assume {:nonnull} Tmp_213 != 0;
    assume Tmp_213 > 0;
    goto anon750_Then, anon750_Else;

  anon750_Else:
    assume {:partition} Mem_T.INT4[Tmp_213 + Tmp_99 * 4] != 3;
    Tmp_112 := cardNo_1;
    assume {:nonnull} Gd_4 != 0;
    assume Gd_4 > 0;
    havoc Tmp_259;
    assume {:nonnull} Tmp_259 != 0;
    assume Tmp_259 > 0;
    goto anon751_Then, anon751_Else;

  anon751_Else:
    assume {:partition} Mem_T.INT4[Tmp_259 + Tmp_112 * 4] != 4;
    status_1 := -1073741811;
    goto L110;

  anon751_Then:
    assume {:partition} Mem_T.INT4[Tmp_259 + Tmp_112 * 4] == 4;
    goto L256;

  L256:
    Tmp_227 := cardNo_1;
    assume {:nonnull} Gd_4 != 0;
    assume Gd_4 > 0;
    havoc Tmp_88;
    assume {:nonnull} Tmp_88 != 0;
    assume Tmp_88 > 0;
    havoc base_1;
    Tmp_135 := base_1;
    assume {:nonnull} Tmp_135 != 0;
    assume Tmp_135 > 0;
    goto anon752_Then, anon752_Else;

  anon752_Else:
    assume {:partition} Mem_T.INT4[Tmp_135] == 264;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon752_Then:
    assume {:partition} Mem_T.INT4[Tmp_135] != 264;
    Tmp_98 := base_1;
    assume {:nonnull} Tmp_98 != 0;
    assume Tmp_98 > 0;
    goto anon753_Then, anon753_Else;

  anon753_Else:
    assume {:partition} Mem_T.INT4[Tmp_98] == 264;
    Tmp_122 := base_1;
    assume {:nonnull} Tmp_122 != 0;
    assume Tmp_122 > 0;
    goto anon754_Then, anon754_Else;

  anon754_Else:
    assume {:partition} Mem_T.INT4[Tmp_122] == 264;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    Tmp_168 := base_1;
    assume {:nonnull} Tmp_168 != 0;
    assume Tmp_168 > 0;
    Mem_T.INT4[Tmp_168] := 0;
    goto L110;

  anon754_Then:
    assume {:partition} Mem_T.INT4[Tmp_122] != 264;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon753_Then:
    assume {:partition} Mem_T.INT4[Tmp_98] != 264;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon750_Then:
    assume {:partition} Mem_T.INT4[Tmp_213 + Tmp_99 * 4] == 3;
    goto L256;

  anon748_Then:
    status_1 := -1073741811;
    goto L110;

  anon624_Then:
    assume {:partition} ioControlCode_1 == 1777748;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon553_Then, anon553_Else;

  anon553_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon554_Then, anon554_Else;

  anon554_Else:
    status_1 := -1073741789;
    goto L110;

  anon554_Then:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon555_Then, anon555_Else;

  anon555_Else:
    status_1 := -1073741789;
    goto L110;

  anon555_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_124;
    assume {:nonnull} Tmp_124 != 0;
    assume Tmp_124 > 0;
    comNo := Mem_T.INT4[Tmp_124];
    goto anon742_Then, anon742_Else;

  anon742_Else:
    assume {:partition} 0 >= comNo;
    goto L287;

  L287:
    status_1 := -1073741811;
    goto L110;

  anon742_Then:
    assume {:partition} comNo > 0;
    goto anon556_Then, anon556_Else;

  anon556_Else:
    assume {:partition} comNo <= 256;
    Tmp_252 := comNo;
    goto anon743_Then, anon743_Else;

  anon743_Else:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Ps;
    Tmp_201 := comNo;
    havoc Tmp_95;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_95 != 0;
    assume Tmp_95 > 0;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    Tmp_225 := comNo;
    havoc Tmp_218;
    assume {:nonnull} Tmp_218 != 0;
    assume Tmp_218 > 0;
    goto anon744_Then, anon744_Else;

  anon744_Else:
    Tmp_126 := comNo;
    havoc Tmp_123;
    assume {:nonnull} Tmp_123 != 0;
    assume Tmp_123 > 0;
    goto anon745_Then, anon745_Else;

  anon745_Else:
    assume {:partition} BAND(Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(Tmp_123)], 1) == 0;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    goto L294;

  L294:
    Tmp_102 := comNo;
    havoc Tmp_248;
    assume {:nonnull} Tmp_248 != 0;
    assume Tmp_248 > 0;
    goto anon746_Then, anon746_Else;

  anon746_Else:
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    goto L297;

  L297:
    Tmp_237 := comNo;
    havoc Tmp_185;
    assume {:nonnull} Tmp_185 != 0;
    assume Tmp_185 > 0;
    goto anon747_Then, anon747_Else;

  anon747_Else:
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    goto L299;

  L299:
    Tmp_156 := comNo;
    havoc Tmp_117;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_117 != 0;
    assume Tmp_117 > 0;
    Tmp_186 := comNo;
    havoc Tmp_145;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_145 != 0;
    assume Tmp_145 > 0;
    Tmp_196 := comNo;
    havoc Tmp_113;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_113 != 0;
    assume Tmp_113 > 0;
    Tmp_92 := comNo;
    havoc Tmp_245;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_245 != 0;
    assume Tmp_245 > 0;
    Tmp_250 := comNo;
    havoc Tmp_169;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_169 != 0;
    assume Tmp_169 > 0;
    Tmp_256 := comNo;
    havoc Tmp_119;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_119 != 0;
    assume Tmp_119 > 0;
    Tmp_105 := comNo;
    havoc Tmp_190;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Tmp_190 != 0;
    assume Tmp_190 > 0;
    Tmp_255 := comNo;
    havoc Tmp_150;
    assume {:nonnull} Tmp_150 != 0;
    assume Tmp_150 > 0;
    havoc Tmp_153;
    Tmp_246 := comNo;
    havoc Tmp_181;
    assume {:nonnull} Tmp_181 != 0;
    assume Tmp_181 > 0;
    havoc Tmp_120;
    assume {:nonnull} Ps != 0;
    assume Ps > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon747_Then:
    goto L299;

  anon746_Then:
    goto L297;

  anon745_Then:
    assume {:partition} BAND(Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(Tmp_123)], 1) != 0;
    goto L294;

  anon744_Then:
    goto L294;

  anon743_Then:
    goto L287;

  anon556_Then:
    assume {:partition} 256 < comNo;
    goto L287;

  anon553_Then:
    status_1 := -1073741811;
    goto L110;

  anon625_Then:
    assume {:partition} ioControlCode_1 == 1777744;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon557_Then, anon557_Else;

  anon557_Else:
    status_1 := -1073741789;
    goto L110;

  anon557_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1171;
    call {:si_unique_call 156} MoxaFuncGetLineStatus(vslice_dummy_var_1171, data);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_91;
    assume {:nonnull} Tmp_91 != 0;
    assume Tmp_91 > 0;
    assume {:nonnull} data != 0;
    assume data > 0;
    Mem_T.INT4[Tmp_91] := Mem_T.INT4[data];
    goto L110;

  anon626_Then:
    assume {:partition} ioControlCode_1 == 1777740;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon558_Then, anon558_Else;

  anon558_Else:
    status_1 := -1073741789;
    goto L110;

  anon558_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc ofs_1;
    call {:si_unique_call 157} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 158} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon741_Then, anon741_Else;

  anon741_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    call {:si_unique_call 159} MoxaFunc(ofs_1, 22, 1028);
    call {:si_unique_call 160} sdv_KeReleaseSpinLock(0, oldIrql_4);
    call {:si_unique_call 161} MoxaDelay(5);
    goto anon559_Then, anon559_Else;

  anon559_Else:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_178;
    assume {:nonnull} Tmp_178 != 0;
    assume Tmp_178 > 0;
    Mem_T.INT4[Tmp_178] := 1;
    goto L342;

  L342:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon559_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_116;
    assume {:nonnull} Tmp_116 != 0;
    assume Tmp_116 > 0;
    Mem_T.INT4[Tmp_116] := 0;
    goto L342;

  anon741_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon627_Then:
    assume {:partition} ioControlCode_1 == 1777736;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon560_Then, anon560_Else;

  anon560_Else:
    status_1 := -1073741789;
    goto L110;

  anon560_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_110;
    assume {:nonnull} Tmp_110 != 0;
    assume Tmp_110 > 0;
    Mem_T.INT4[Tmp_110] := 0;
    call {:si_unique_call 162} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 163} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon740_Then, anon740_Else;

  anon740_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1172;
    call {:si_unique_call 164} old_1 := MoxaReadReg(vslice_dummy_var_1172, 1);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1173;
    call {:si_unique_call 165} MoxaWriteReg(vslice_dummy_var_1173, 1, 0);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1174;
    call {:si_unique_call 166} ier := MoxaReadReg(vslice_dummy_var_1174, 1);
    goto anon561_Then, anon561_Else;

  anon561_Else:
    assume {:partition} ier != 0;
    goto L368;

  L368:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1175;
    call {:si_unique_call 167} MoxaWriteReg(vslice_dummy_var_1175, 1, old_1);
    call {:si_unique_call 168} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon561_Then:
    assume {:partition} ier == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1176;
    call {:si_unique_call 169} MoxaWriteReg(vslice_dummy_var_1176, 1, 3);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1177;
    call {:si_unique_call 170} ier := MoxaReadReg(vslice_dummy_var_1177, 1);
    goto anon562_Then, anon562_Else;

  anon562_Else:
    assume {:partition} ier == 3;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_192;
    assume {:nonnull} Tmp_192 != 0;
    assume Tmp_192 > 0;
    Mem_T.INT4[Tmp_192] := 1;
    goto L368;

  anon562_Then:
    assume {:partition} ier != 3;
    goto L368;

  anon740_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon628_Then:
    assume {:partition} ioControlCode_1 == 1777732;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Gd;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_189;
    assume {:nonnull} Gd != 0;
    assume Gd > 0;
    havoc Tmp_233;
    assume {:nonnull} Tmp_233 != 0;
    assume Tmp_233 > 0;
    goto anon737_Then, anon737_Else;

  anon737_Else:
    assume {:partition} Mem_T.INT4[Tmp_233 + Tmp_189 * 4] == 3;
    goto L385;

  L385:
    status_1 := -1073741811;
    goto L110;

  anon737_Then:
    assume {:partition} Mem_T.INT4[Tmp_233 + Tmp_189 * 4] != 3;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_249;
    assume {:nonnull} Gd != 0;
    assume Gd > 0;
    havoc Tmp_127;
    assume {:nonnull} Tmp_127 != 0;
    assume Tmp_127 > 0;
    goto anon738_Then, anon738_Else;

  anon738_Else:
    assume {:partition} Mem_T.INT4[Tmp_127 + Tmp_249 * 4] != 4;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon563_Then, anon563_Else;

  anon563_Else:
    status_1 := -1073741789;
    goto L110;

  anon563_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_200;
    assume {:nonnull} Tmp_200 != 0;
    assume Tmp_200 > 0;
    mode := Mem_T.INT4[Tmp_200];
    call {:si_unique_call 171} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 172} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon739_Then, anon739_Else;

  anon739_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1178;
    call {:si_unique_call 173} MoxaFunc(vslice_dummy_var_1178, 3, 1028);
    goto anon564_Then, anon564_Else;

  anon564_Else:
    assume {:partition} mode != 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1179;
    call {:si_unique_call 174} MoxaFunc(vslice_dummy_var_1179, 13, 1028);
    goto L404;

  L404:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1180;
    call {:si_unique_call 175} MoxaFunc(vslice_dummy_var_1180, 2, 1028);
    call {:si_unique_call 176} sdv_KeReleaseSpinLock(0, oldIrql_4);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon564_Then:
    assume {:partition} mode == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1181;
    call {:si_unique_call 177} MoxaFunc(vslice_dummy_var_1181, 14, 1028);
    goto L404;

  anon739_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon738_Then:
    assume {:partition} Mem_T.INT4[Tmp_127 + Tmp_249 * 4] == 4;
    goto L385;

  anon629_Then:
    assume {:partition} ioControlCode_1 == 1777728;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon565_Then, anon565_Else;

  anon565_Else:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon566_Then, anon566_Else;

  anon566_Else:
    status_1 := -1073741789;
    goto L110;

  anon566_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc com;
    assume {:nonnull} com != 0;
    assume com > 0;
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    Mem_T.INT4[comNo_1] := Mem_T.INT4[com];
    assume {:nonnull} com != 0;
    assume com > 0;
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    Mem_T.INT4[comNo_1 + 1 * 4] := Mem_T.INT4[com + 1 * 4];
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    goto anon733_Then, anon733_Else;

  anon733_Else:
    assume {:partition} Mem_T.INT4[comNo_1] > Mem_T.INT4[comNo_1 + 1 * 4];
    status_1 := -1073741811;
    goto L110;

  anon733_Then:
    assume {:partition} Mem_T.INT4[comNo_1 + 1 * 4] >= Mem_T.INT4[comNo_1];
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    size := 16 * (Mem_T.INT4[comNo_1 + 1 * 4] - Mem_T.INT4[comNo_1] + 1);
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon734_Then, anon734_Else;

  anon734_Else:
    status_1 := -1073741789;
    goto L110;

  anon734_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc St;
    nn := 0;
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    ndx_1 := Mem_T.INT4[comNo_1];
    goto L436;

  L436:
    call {:si_unique_call 178} Tmp_84, Tmp_89, Tmp_94, Tmp_103, Tmp_104, Tmp_107, Tmp_114, nn, Tmp_128, Tmp_130, Tmp_136, Tmp_139, ndx_1, Tmp_140, Tmp_142, Tmp_147, Tmp_151, Tmp_154, Tmp_157, Tmp_159, Tmp_160, Tmp_162, Tmp_166, Tmp_167, Tmp_172, Tmp_182, Tmp_195, Tmp_199, Tmp_204, Tmp_210, Tmp_211, Tmp_219, Tmp_226, Tmp_241, Tmp_243, portNo_1, boogieTmp := MoxaIoControl_loop_L436(Tmp_84, Tmp_89, Tmp_94, Tmp_103, Tmp_104, Tmp_107, Tmp_114, nn, St, Tmp_128, Tmp_130, Tmp_136, Tmp_139, ndx_1, Tmp_140, Tmp_142, Tmp_147, Tmp_151, Tmp_154, Tmp_157, Tmp_159, Tmp_160, Tmp_162, Tmp_166, Tmp_167, Tmp_172, Tmp_182, Tmp_195, Tmp_199, Tmp_204, Tmp_210, Tmp_211, Tmp_219, Tmp_226, Tmp_241, comNo_1, Tmp_243, portNo_1, boogieTmp);
    goto L436_last;

  L436_last:
    assume {:nonnull} comNo_1 != 0;
    assume comNo_1 > 0;
    goto anon567_Then, anon567_Else;

  anon567_Else:
    assume {:partition} Mem_T.INT4[comNo_1 + 1 * 4] >= ndx_1;
    goto anon568_Then, anon568_Else;

  anon568_Else:
    assume {:partition} ndx_1 <= 256;
    goto anon569_Then, anon569_Else;

  anon569_Else:
    assume {:partition} 0 >= ndx_1;
    goto L443;

  L443:
    ndx_1 := ndx_1 + 1;
    nn := nn + 1;
    goto L443_dummy;

  L443_dummy:
    assume false;
    return;

  anon569_Then:
    assume {:partition} ndx_1 > 0;
    Tmp_157 := ndx_1;
    goto anon735_Then, anon735_Else;

  anon735_Else:
    Tmp_114 := ndx_1;
    havoc Tmp_104;
    assume {:nonnull} Tmp_104 != 0;
    assume Tmp_104 > 0;
    havoc portNo_1;
    Tmp_241 := nn;
    Tmp_103 := ndx_1;
    havoc Tmp_84;
    Tmp_107 := portNo_1;
    assume {:nonnull} St != 0;
    assume St > 0;
    assume {:nonnull} Tmp_84 != 0;
    assume Tmp_84 > 0;
    Tmp_166 := nn;
    Tmp_154 := ndx_1;
    havoc Tmp_140;
    Tmp_160 := portNo_1;
    assume {:nonnull} St != 0;
    assume St > 0;
    assume {:nonnull} Tmp_140 != 0;
    assume Tmp_140 > 0;
    Tmp_243 := ndx_1;
    havoc Tmp_94;
    assume {:nonnull} Tmp_94 != 0;
    assume Tmp_94 > 0;
    Tmp_142 := ModemStatus__MOXA_DEVICE_EXTENSION(Tmp_94);
    Tmp_211 := ndx_1;
    havoc Tmp_210;
    assume {:nonnull} Tmp_210 != 0;
    assume Tmp_210 > 0;
    havoc Tmp_89;
    call {:si_unique_call 179} MoxaFuncGetLineStatus(Tmp_89, Tmp_142);
    Tmp_199 := nn;
    Tmp_195 := ndx_1;
    havoc Tmp_130;
    assume {:nonnull} St != 0;
    assume St > 0;
    assume {:nonnull} Tmp_130 != 0;
    assume Tmp_130 > 0;
    Tmp_151 := portNo_1;
    Tmp_204 := nn;
    assume {:nonnull} St != 0;
    assume St > 0;
    call {:si_unique_call 180} boogieTmp := corral_nondet();
    Tmp_182 := ndx_1;
    havoc Tmp_219;
    assume {:nonnull} Tmp_219 != 0;
    assume Tmp_219 > 0;
    goto anon736_Then, anon736_Else;

  anon736_Else:
    Tmp_159 := nn;
    Tmp_172 := nn;
    assume {:nonnull} St != 0;
    assume St > 0;
    goto L457;

  L457:
    Tmp_226 := ndx_1;
    havoc Tmp_139;
    assume {:nonnull} Tmp_139 != 0;
    assume Tmp_139 > 0;
    havoc Tmp_167;
    Tmp_162 := ndx_1;
    havoc Tmp_128;
    assume {:nonnull} Tmp_128 != 0;
    assume Tmp_128 > 0;
    havoc Tmp_147;
    Tmp_136 := nn;
    assume {:nonnull} St != 0;
    assume St > 0;
    goto L443;

  anon736_Then:
    goto L457;

  anon735_Then:
    goto L443;

  anon568_Then:
    assume {:partition} 256 < ndx_1;
    goto L437;

  L437:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon567_Then:
    assume {:partition} ndx_1 > Mem_T.INT4[comNo_1 + 1 * 4];
    goto L437;

  anon565_Then:
    status_1 := -1073741811;
    goto L110;

  anon630_Then:
    assume {:partition} ioControlCode_1 == 1777724;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon570_Then, anon570_Else;

  anon570_Else:
    status_1 := -1073741789;
    goto L110;

  anon570_Then:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon571_Then, anon571_Else;

  anon571_Else:
    status_1 := -1073741789;
    goto L110;

  anon571_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_230;
    assume {:nonnull} Tmp_230 != 0;
    assume Tmp_230 > 0;
    lowWater := Mem_T.INT4[Tmp_230];
    goto anon729_Then, anon729_Else;

  anon729_Else:
    assume {:partition} lowWater > 1024;
    lowWater := 1024;
    goto L476;

  L476:
    goto anon572_Then, anon572_Else;

  anon572_Else:
    assume {:partition} lowWater >= 0;
    cardNo := 0;
    goto L481;

  L481:
    call {:si_unique_call 181} Tmp_85, port, cardNo, ext, portNo, Tmp_125, ofs_2, Tmp_137, Tmp_141, Tmp_152, Tmp_155, Tmp_183, Tmp_184, Tmp_205 := MoxaIoControl_loop_L481(Tmp_85, port, cardNo, ext, portNo, Tmp_125, ofs_2, Tmp_137, Tmp_141, Tmp_152, Tmp_155, Tmp_183, Tmp_184, Tmp_205);
    goto L481_last;

  L481_last:
    assume {:CounterLoop 4} {:Counter "cardNo"} true;
    goto anon573_Then, anon573_Else;

  anon573_Else:
    assume {:partition} 4 > cardNo;
    Tmp_125 := cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_184;
    assume {:nonnull} Tmp_184 != 0;
    assume Tmp_184 > 0;
    goto anon730_Then, anon730_Else;

  anon730_Else:
    assume {:partition} Mem_T.INT4[Tmp_184 + Tmp_125 * 4] == 0;
    goto L487;

  L487:
    cardNo := cardNo + 1;
    goto L487_dummy;

  L487_dummy:
    assume false;
    return;

  anon730_Then:
    assume {:partition} Mem_T.INT4[Tmp_184 + Tmp_125 * 4] != 0;
    Tmp_183 := cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_141;
    assume {:nonnull} Tmp_141 != 0;
    assume Tmp_141 > 0;
    goto anon731_Then, anon731_Else;

  anon731_Else:
    assume {:partition} Mem_T.INT4[Tmp_141 + Tmp_183 * 4] == 0;
    goto L487;

  anon731_Then:
    assume {:partition} Mem_T.INT4[Tmp_141 + Tmp_183 * 4] != 0;
    port := 0;
    goto L486;

  L486:
    call {:si_unique_call 182} Tmp_85, port, ext, portNo, ofs_2, Tmp_137, Tmp_152, Tmp_155, Tmp_205 := MoxaIoControl_loop_L486(Tmp_85, port, cardNo, ext, portNo, ofs_2, Tmp_137, Tmp_152, Tmp_155, Tmp_205);
    goto L486_last;

  L486_last:
    Tmp_85 := cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_152;
    assume {:nonnull} Tmp_152 != 0;
    assume Tmp_152 > 0;
    goto anon732_Then, anon732_Else;

  anon732_Else:
    assume {:partition} Mem_T.INT4[Tmp_152 + Tmp_85 * 4] > port;
    portNo := cardNo * 32 + port;
    Tmp_205 := portNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_137;
    assume {:nonnull} Tmp_137 != 0;
    assume Tmp_137 > 0;
    havoc ext;
    assume {:nonnull} ext != 0;
    assume ext > 0;
    havoc ofs_2;
    Tmp_155 := ofs_2;
    assume {:nonnull} Tmp_155 != 0;
    assume Tmp_155 > 0;
    havoc vslice_dummy_var_1182;
    Mem_T.INT4[Tmp_155] := vslice_dummy_var_1182;
    port := port + 1;
    goto anon732_Else_dummy;

  anon732_Else_dummy:
    assume false;
    return;

  anon732_Then:
    assume {:partition} port >= Mem_T.INT4[Tmp_152 + Tmp_85 * 4];
    goto L487;

  anon573_Then:
    assume {:partition} cardNo >= 4;
    goto L478;

  L478:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_133;
    assume {:nonnull} Tmp_133 != 0;
    assume Tmp_133 > 0;
    havoc vslice_dummy_var_1183;
    Mem_T.INT4[Tmp_133] := vslice_dummy_var_1183;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon572_Then:
    assume {:partition} 0 > lowWater;
    goto L478;

  anon729_Then:
    assume {:partition} 1024 >= lowWater;
    goto L476;

  anon631_Then:
    assume {:partition} ioControlCode_1 == 1777720;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon532_Then, anon532_Else;

  anon532_Else:
    status_1 := -1073741789;
    goto L110;

  anon532_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 183} Tmp_83 := MoxaStartOrQueue(extension_4, Irp_1, ReadQueue__MOXA_DEVICE_EXTENSION(extension_4), CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_4), li2bplFunctionConstant140);
    goto anon728_Then, anon728_Else;

  anon728_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon728_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon632_Then:
    assume {:partition} ioControlCode_1 == 1777716;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon574_Then, anon574_Else;

  anon574_Else:
    status_1 := -1073741789;
    goto L110;

  anon574_Then:
    call {:si_unique_call 184} sdv_35 := GetDeviceRxQueueWithLock(extension_4);
    goto anon727_Then, anon727_Else;

  anon727_Else:
    assume {:partition} yogi_error != 1;
    count_2 := sdv_35;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_244;
    assume {:nonnull} Tmp_244 != 0;
    assume Tmp_244 > 0;
    Mem_T.INT4[Tmp_244] := count_2;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon727_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon633_Then:
    assume {:partition} ioControlCode_1 == 1777708;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon575_Then, anon575_Else;

  anon575_Else:
    status_1 := -1073741789;
    goto L110;

  anon575_Then:
    call {:si_unique_call 185} sdv_46 := GetDeviceTxQueueWithLock(extension_4);
    goto anon726_Then, anon726_Else;

  anon726_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc count_1;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_242;
    assume {:nonnull} Tmp_242 != 0;
    assume Tmp_242 > 0;
    Mem_T.INT4[Tmp_242] := count_1;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon726_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon634_Then:
    assume {:partition} ioControlCode_1 == 1777688;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon531_Then, anon531_Else;

  anon531_Else:
    goto L522;

  L522:
    status_1 := -1073741789;
    goto L110;

  anon531_Then:
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon576_Then, anon576_Else;

  anon576_Else:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 186} Tmp_83 := MoxaStartOrQueue(extension_4, Irp_1, ReadQueue__MOXA_DEVICE_EXTENSION(extension_4), CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_4), li2bplFunctionConstant140);
    goto anon725_Then, anon725_Else;

  anon725_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon725_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon576_Then:
    goto L522;

  anon635_Then:
    assume {:partition} ioControlCode_1 == 1777664;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon530_Then, anon530_Else;

  anon530_Else:
    status_1 := -1073741789;
    goto L110;

  anon530_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_149;
    assume {:nonnull} Tmp_149 != 0;
    assume Tmp_149 > 0;
    Mem_T.INT4[Tmp_149] := 1029;
    goto L110;

  anon636_Then:
    assume {:partition} ioControlCode_1 == 1769616;
    call {:si_unique_call 187} vslice_dummy_var_20 := KeSynchronizeExecution(0, li2bplFunctionConstant354, 0);
    goto L110;

  anon637_Then:
    assume {:partition} ioControlCode_1 == 1769612;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon529_Then, anon529_Else;

  anon529_Else:
    status_1 := -1073741789;
    goto L110;

  anon529_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 188} vslice_dummy_var_26 := KeSynchronizeExecution(0, li2bplFunctionConstant367, 0);
    goto L110;

  anon638_Then:
    assume {:partition} ioControlCode_1 == 1769600;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon528_Then, anon528_Else;

  anon528_Else:
    status_1 := -1073741789;
    goto L110;

  anon528_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_214;
    assume {:nonnull} Tmp_214 != 0;
    assume Tmp_214 > 0;
    Mem_T.INT4[Tmp_214] := 0;
    goto L110;

  anon639_Then:
    assume {:partition} ioControlCode_1 == 1769596;
    goto L110;

  anon640_Then:
    assume {:partition} ioControlCode_1 == 1769592;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon577_Then, anon577_Else;

  anon577_Else:
    status_1 := -1073741789;
    goto L110;

  anon577_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 189} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 190} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon724_Then, anon724_Else;

  anon724_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1184;
    call {:si_unique_call 191} MoxaFunc(vslice_dummy_var_1184, 42, 0);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_175;
    assume {:nonnull} Tmp_175 != 0;
    assume Tmp_175 > 0;
    modemControl := Mem_T.INT4[Tmp_175];
    call {:si_unique_call 192} sdv_KeReleaseSpinLock(0, oldIrql_4);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_229;
    assume {:nonnull} Tmp_229 != 0;
    assume Tmp_229 > 0;
    Mem_T.INT4[Tmp_229] := modemControl;
    goto L110;

  anon724_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon641_Then:
    assume {:partition} ioControlCode_1 == 1769588;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon527_Then, anon527_Else;

  anon527_Else:
    status_1 := -1073741789;
    goto L110;

  anon527_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    Tmp_215 := AssociatedIrp__IRP(Irp_1);
    assume {:nonnull} Tmp_215 != 0;
    assume Tmp_215 > 0;
    havoc vslice_dummy_var_1185;
    call {:si_unique_call 193} MoxaGetProperties(extension_4, vslice_dummy_var_1185);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon642_Then:
    assume {:partition} ioControlCode_1 == 1769584;
    goto L110;

  anon643_Then:
    assume {:partition} ioControlCode_1 == 1769580;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon578_Then, anon578_Else;

  anon578_Else:
    status_1 := -1073741789;
    goto L110;

  anon578_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} S_1 != 0;
    assume S_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} S_1 != 0;
    assume S_1 > 0;
    call {:si_unique_call 194} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 195} IoAcquireCancelSpinLock(Tmp_87);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    call {:si_unique_call 196} vslice_dummy_var_21 := KeSynchronizeExecution(0, li2bplFunctionConstant368, 0);
    call {:si_unique_call 197} IoReleaseCancelSpinLock(oldIrql_4);
    goto L110;

  anon644_Then:
    assume {:partition} ioControlCode_1 == 1769576;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon579_Then, anon579_Else;

  anon579_Else:
    status_1 := -1073741789;
    goto L110;

  anon579_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1186;
    call {:si_unique_call 198} MoxaFuncGetLineStatus(vslice_dummy_var_1186, data_1);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_180;
    assume {:nonnull} Tmp_180 != 0;
    assume Tmp_180 > 0;
    call {:si_unique_call 199} boogieTmp := corral_nondet();
    Mem_T.INT4[Tmp_180] := boogieTmp;
    goto L110;

  anon645_Then:
    assume {:partition} ioControlCode_1 == 1769572;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc handFlow;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon721_Then, anon721_Else;

  anon721_Else:
    status_1 := -1073741789;
    goto L110;

  anon721_Then:
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    goto anon580_Then, anon580_Else;

  anon580_Else:
    status_1 := -1073741811;
    goto L110;

  anon580_Then:
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    goto anon581_Then, anon581_Else;

  anon581_Else:
    status_1 := -1073741811;
    goto L110;

  anon581_Then:
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    havoc Tmp_235;
    goto anon722_Then, anon722_Else;

  anon722_Else:
    assume {:partition} Tmp_235 == 3;
    status_1 := -1073741811;
    goto L110;

  anon722_Then:
    assume {:partition} Tmp_235 != 3;
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    goto anon582_Then, anon582_Else;

  anon582_Else:
    goto L614;

  L614:
    status_1 := -1073741811;
    goto L110;

  anon582_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    goto anon583_Then, anon583_Else;

  anon583_Else:
    call {:si_unique_call 200} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 201} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon723_Then, anon723_Else;

  anon723_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon584_Then, anon584_Else;

  anon584_Else:
    assume {:nonnull} handFlow != 0;
    assume handFlow > 0;
    goto anon585_Then, anon585_Else;

  anon585_Else:
    status_1 := -1073741811;
    call {:si_unique_call 202} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon585_Then:
    goto L620;

  L620:
    assume {:nonnull} S != 0;
    assume S > 0;
    assume {:nonnull} S != 0;
    assume S > 0;
    call {:si_unique_call 203} vslice_dummy_var_25 := KeSynchronizeExecution(0, li2bplFunctionConstant369, 0);
    call {:si_unique_call 204} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon584_Then:
    goto L620;

  anon723_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon583_Then:
    goto L614;

  anon646_Then:
    assume {:partition} ioControlCode_1 == 1769568;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon526_Then, anon526_Else;

  anon526_Else:
    status_1 := -1073741789;
    goto L110;

  anon526_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 205} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 206} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon720_Then, anon720_Else;

  anon720_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_232;
    assume {:nonnull} Tmp_232 != 0;
    assume Tmp_232 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_232 != 0;
    assume Tmp_232 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_232 != 0;
    assume Tmp_232 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_232 != 0;
    assume Tmp_232 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 207} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon720_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon647_Then:
    assume {:partition} ioControlCode_1 == 1769564;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc newChars;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon718_Then, anon718_Else;

  anon718_Else:
    status_1 := -1073741789;
    goto L110;

  anon718_Then:
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    goto anon586_Then, anon586_Else;

  anon586_Else:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon587_Then, anon587_Else;

  anon587_Else:
    status_1 := -1073741811;
    goto L110;

  anon587_Then:
    goto L651;

  L651:
    call {:si_unique_call 208} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 209} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon719_Then, anon719_Else;

  anon719_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon588_Then, anon588_Else;

  anon588_Else:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    goto anon589_Then, anon589_Else;

  anon589_Else:
    goto L661;

  L661:
    status_1 := -1073741811;
    call {:si_unique_call 210} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon589_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    goto anon590_Then, anon590_Else;

  anon590_Else:
    goto L661;

  anon590_Then:
    goto L658;

  L658:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newChars != 0;
    assume newChars > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc ofs_5;
    i := 0;
    goto L673;

  L673:
    call {:si_unique_call 211} i, Tmp_148, Tmp_191, Tmp_251 := MoxaIoControl_loop_L673(i, Tmp_148, ofs_5, Tmp_191, newChars, Tmp_251);
    goto L673_last;

  L673_last:
    assume {:CounterLoop 6} {:Counter "i"} true;
    goto anon591_Then, anon591_Else;

  anon591_Else:
    assume {:partition} 6 > i;
    Tmp_251 := i;
    Tmp_191 := i;
    Tmp_148 := newChars;
    assume {:nonnull} Tmp_148 != 0;
    assume Tmp_148 > 0;
    assume {:nonnull} ofs_5 != 0;
    assume ofs_5 > 0;
    Mem_T.INT4[ofs_5 + Tmp_251 * 4] := Mem_T.INT4[Tmp_148 + Tmp_191 * 4];
    i := i + 1;
    goto anon591_Else_dummy;

  anon591_Else_dummy:
    assume false;
    return;

  anon591_Then:
    assume {:partition} i >= 6;
    assume {:nonnull} ofs_5 != 0;
    assume ofs_5 > 0;
    Mem_T.INT4[ofs_5] := 44;
    call {:si_unique_call 212} vslice_dummy_var_24 := MoxaWaitFinish(ofs_5);
    call {:si_unique_call 213} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon588_Then:
    goto L658;

  anon719_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon586_Then:
    goto L651;

  anon648_Then:
    assume {:partition} ioControlCode_1 == 1769560;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon525_Then, anon525_Else;

  anon525_Else:
    status_1 := -1073741789;
    goto L110;

  anon525_Then:
    call {:si_unique_call 214} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 215} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon717_Then, anon717_Else;

  anon717_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_228;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_228 != 0;
    assume Tmp_228 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 216} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon717_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon649_Then:
    assume {:partition} ioControlCode_1 == 1769556;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Lc_1;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon708_Then, anon708_Else;

  anon708_Else:
    status_1 := -1073741789;
    goto L110;

  anon708_Then:
    call {:si_unique_call 217} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 218} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon709_Then, anon709_Else;

  anon709_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon592_Then, anon592_Else;

  anon592_Else:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_97;
    goto anon710_Then, anon710_Else;

  anon710_Else:
    assume {:partition} Tmp_97 == 1;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L708;

  L708:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon593_Then, anon593_Else;

  anon593_Else:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_132;
    goto anon711_Then, anon711_Else;

  anon711_Else:
    assume {:partition} Tmp_132 == 192;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L714;

  L714:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon594_Then, anon594_Else;

  anon594_Else:
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L717;

  L717:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 219} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon594_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon595_Then, anon595_Else;

  anon595_Else:
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L717;

  anon595_Then:
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L717;

  anon711_Then:
    assume {:partition} Tmp_132 != 192;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_197;
    goto anon712_Then, anon712_Else;

  anon712_Else:
    assume {:partition} Tmp_197 == 64;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L714;

  anon712_Then:
    assume {:partition} Tmp_197 != 64;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_239;
    goto anon713_Then, anon713_Else;

  anon713_Else:
    assume {:partition} Tmp_239 == 160;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L714;

  anon713_Then:
    assume {:partition} Tmp_239 != 160;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_109;
    goto anon714_Then, anon714_Else;

  anon714_Else:
    assume {:partition} Tmp_109 == 32;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L714;

  anon714_Then:
    assume {:partition} Tmp_109 != 32;
    goto L714;

  anon593_Then:
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L714;

  anon710_Then:
    assume {:partition} Tmp_97 != 1;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_115;
    goto anon715_Then, anon715_Else;

  anon715_Else:
    assume {:partition} Tmp_115 == 2;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L708;

  anon715_Then:
    assume {:partition} Tmp_115 != 2;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_202;
    goto anon716_Then, anon716_Else;

  anon716_Else:
    assume {:partition} Tmp_202 == 3;
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L708;

  anon716_Then:
    assume {:partition} Tmp_202 != 3;
    goto L708;

  anon592_Then:
    assume {:nonnull} Lc_1 != 0;
    assume Lc_1 > 0;
    goto L708;

  anon709_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon650_Then:
    assume {:partition} ioControlCode_1 == 1769552;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Br;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon706_Then, anon706_Else;

  anon706_Else:
    status_1 := -1073741789;
    goto L110;

  anon706_Then:
    call {:si_unique_call 220} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 221} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon707_Then, anon707_Else;

  anon707_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} Br != 0;
    assume Br > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 222} sdv_KeReleaseSpinLock(0, oldIrql_4);
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    goto L110;

  anon707_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon651_Then:
    assume {:partition} ioControlCode_1 == 1769548;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon596_Then, anon596_Else;

  anon596_Else:
    status_1 := -1073741789;
    goto L110;

  anon596_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_176;
    assume {:nonnull} Tmp_176 != 0;
    assume Tmp_176 > 0;
    mask_1 := Mem_T.INT4[Tmp_176];
    goto anon704_Then, anon704_Else;

  anon704_Else:
    assume {:partition} mask_1 != 0;
    goto anon597_Then, anon597_Else;

  anon597_Else:
    assume {:partition} BAND(mask_1, -16) == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 223} Tmp_83 := MoxaStartOrQueue(extension_4, Irp_1, PurgeQueue__MOXA_DEVICE_EXTENSION(extension_4), CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(extension_4), li2bplFunctionConstant164);
    goto anon705_Then, anon705_Else;

  anon705_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon705_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon597_Then:
    assume {:partition} BAND(mask_1, -16) != 0;
    goto L755;

  L755:
    status_1 := -1073741811;
    goto L110;

  anon704_Then:
    assume {:partition} mask_1 == 0;
    goto L755;

  anon652_Then:
    assume {:partition} ioControlCode_1 == 1769544;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon524_Then, anon524_Else;

  anon524_Else:
    status_1 := -1073741789;
    goto L110;

  anon524_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 224} Tmp_83 := MoxaStartOrQueue(extension_4, Irp_1, MaskQueue__MOXA_DEVICE_EXTENSION(extension_4), CurrentMaskIrp__MOXA_DEVICE_EXTENSION(extension_4), li2bplFunctionConstant370);
    goto anon703_Then, anon703_Else;

  anon703_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon703_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon653_Then:
    assume {:partition} ioControlCode_1 == 1769540;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon598_Then, anon598_Else;

  anon598_Else:
    status_1 := -1073741789;
    goto L110;

  anon598_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_170;
    assume {:nonnull} Tmp_170 != 0;
    assume Tmp_170 > 0;
    newMask := Mem_T.INT4[Tmp_170];
    goto anon701_Then, anon701_Else;

  anon701_Else:
    assume {:partition} BAND(newMask, -8192) != 0;
    status_1 := -1073741811;
    goto L110;

  anon701_Then:
    assume {:partition} BAND(newMask, -8192) == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 225} Tmp_83 := MoxaStartOrQueue(extension_4, Irp_1, MaskQueue__MOXA_DEVICE_EXTENSION(extension_4), CurrentMaskIrp__MOXA_DEVICE_EXTENSION(extension_4), li2bplFunctionConstant370);
    goto anon702_Then, anon702_Else;

  anon702_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon702_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon654_Then:
    assume {:partition} ioControlCode_1 == 1769536;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon523_Then, anon523_Else;

  anon523_Else:
    status_1 := -1073741789;
    goto L110;

  anon523_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_216;
    assume {:nonnull} Tmp_216 != 0;
    assume Tmp_216 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1187;
    Mem_T.INT4[Tmp_216] := vslice_dummy_var_1187;
    goto L110;

  anon655_Then:
    assume {:partition} ioControlCode_1 == 1769532;
    call {:si_unique_call 226} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 227} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon700_Then, anon700_Else;

  anon700_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_86;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_209;
    havoc Mem_T.INT4;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1188;
    call {:si_unique_call 228} MoxaFunc(vslice_dummy_var_1188, 52, 1028);
    call {:si_unique_call 229} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon700_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon656_Then:
    assume {:partition} ioControlCode_1 == 1769528;
    call {:si_unique_call 230} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 231} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon699_Then, anon699_Else;

  anon699_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_258;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_253;
    havoc Mem_T.INT4;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1189;
    call {:si_unique_call 232} MoxaFunc(vslice_dummy_var_1189, 53, 1028);
    call {:si_unique_call 233} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon699_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon657_Then:
    assume {:partition} ioControlCode_1 == 1769524;
    goto L51;

  L51:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon522_Then, anon522_Else;

  anon522_Else:
    status_1 := -1073741808;
    goto L110;

  anon522_Then:
    call {:si_unique_call 234} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 235} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon696_Then, anon696_Else;

  anon696_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_90;
    goto anon697_Then, anon697_Else;

  anon697_Else:
    assume {:partition} Tmp_90 == 128;
    goto L810;

  L810:
    status_1 := -1073741811;
    goto L811;

  L811:
    call {:si_unique_call 236} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon697_Then:
    assume {:partition} Tmp_90 != 128;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_143;
    goto anon698_Then, anon698_Else;

  anon698_Else:
    assume {:partition} Tmp_143 != 192;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon599_Then, anon599_Else;

  anon599_Else:
    Tmp_101 := 1;
    goto L820;

  L820:
    arg := Tmp_101;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1190;
    call {:si_unique_call 237} MoxaFunc(vslice_dummy_var_1190, 38, arg);
    goto anon600_Then, anon600_Else;

  anon600_Else:
    assume {:partition} arg != 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_171;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_173;
    havoc Mem_T.INT4;
    goto L811;

  anon600_Then:
    assume {:partition} arg == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_194;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_188;
    havoc Mem_T.INT4;
    goto L811;

  anon599_Then:
    Tmp_101 := 0;
    goto L820;

  anon698_Then:
    assume {:partition} Tmp_143 == 192;
    goto L810;

  anon696_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon658_Then:
    assume {:partition} ioControlCode_1 == 1769520;
    goto L51;

  anon659_Then:
    assume {:partition} ioControlCode_1 == 1769516;
    goto L110;

  anon660_Then:
    assume {:partition} ioControlCode_1 == 1769512;
    goto L49;

  L49:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon521_Then, anon521_Else;

  anon521_Else:
    status_1 := -1073741808;
    goto L110;

  anon521_Then:
    call {:si_unique_call 238} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 239} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon694_Then, anon694_Else;

  anon694_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_118;
    goto anon695_Then, anon695_Else;

  anon695_Else:
    assume {:partition} Tmp_118 != 2;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon601_Then, anon601_Else;

  anon601_Else:
    Tmp_260 := 1;
    goto L843;

  L843:
    arg_1 := Tmp_260;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1191;
    call {:si_unique_call 240} MoxaFunc(vslice_dummy_var_1191, 37, arg_1);
    goto anon602_Then, anon602_Else;

  anon602_Else:
    assume {:partition} arg_1 != 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_161;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_208;
    havoc Mem_T.INT4;
    goto L836;

  L836:
    call {:si_unique_call 241} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon602_Then:
    assume {:partition} arg_1 == 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_222;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_177;
    havoc Mem_T.INT4;
    goto L836;

  anon601_Then:
    Tmp_260 := 0;
    goto L843;

  anon695_Then:
    assume {:partition} Tmp_118 == 2;
    status_1 := -1073741811;
    goto L836;

  anon694_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon661_Then:
    assume {:partition} ioControlCode_1 == 1769508;
    goto L49;

  anon662_Then:
    assume {:partition} ioControlCode_1 == 1769504;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon520_Then, anon520_Else;

  anon520_Else:
    status_1 := -1073741789;
    goto L110;

  anon520_Then:
    call {:si_unique_call 242} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 243} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon693_Then, anon693_Else;

  anon693_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_212;
    assume {:nonnull} Tmp_212 != 0;
    assume Tmp_212 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_212 != 0;
    assume Tmp_212 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_212 != 0;
    assume Tmp_212 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_212 != 0;
    assume Tmp_212 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Tmp_212 != 0;
    assume Tmp_212 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 244} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon693_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon663_Then:
    assume {:partition} ioControlCode_1 == 1769500;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc newTimeouts;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon691_Then, anon691_Else;

  anon691_Else:
    status_1 := -1073741789;
    goto L110;

  anon691_Then:
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    goto anon603_Then, anon603_Else;

  anon603_Else:
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    goto anon604_Then, anon604_Else;

  anon604_Else:
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    goto anon605_Then, anon605_Else;

  anon605_Else:
    status_1 := -1073741811;
    goto L110;

  anon605_Then:
    goto L866;

  L866:
    call {:si_unique_call 245} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 246} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon692_Then, anon692_Else;

  anon692_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} newTimeouts != 0;
    assume newTimeouts > 0;
    call {:si_unique_call 247} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon692_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon604_Then:
    goto L866;

  anon603_Then:
    goto L866;

  anon664_Then:
    assume {:partition} ioControlCode_1 == 1769496;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon606_Then, anon606_Else;

  anon606_Else:
    status_1 := -1073741789;
    goto L110;

  anon606_Then:
    call {:si_unique_call 248} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 249} IoAcquireCancelSpinLock(Tmp_87);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_224;
    assume {:nonnull} Tmp_224 != 0;
    assume Tmp_224 > 0;
    c := Mem_T.INT4[Tmp_224];
    call {:si_unique_call 250} IoReleaseCancelSpinLock(oldIrql_4);
    call {:si_unique_call 251} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 252} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon689_Then, anon689_Else;

  anon689_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_146;
    assume {:nonnull} Tmp_146 != 0;
    assume Tmp_146 > 0;
    Mem_T.INT4[Tmp_146] := c;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_129;
    assume {:nonnull} Tmp_129 != 0;
    assume Tmp_129 > 0;
    Mem_T.INT4[Tmp_129] := 51;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1192;
    call {:si_unique_call 253} sdv_33 := MoxaWaitFinish(vslice_dummy_var_1192);
    goto anon607_Then, anon607_Else;

  anon607_Else:
    assume {:partition} sdv_33 != 0;
    call {:si_unique_call 254} sdv_KeReleaseSpinLock(0, oldIrql_4);
    call {:si_unique_call 255} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 256} IoAcquireCancelSpinLock(Tmp_87);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon608_Then, anon608_Else;

  anon608_Else:
    call {:si_unique_call 257} vslice_dummy_var_23 := KeSynchronizeExecution(0, li2bplFunctionConstant324, 0);
    goto L915;

  L915:
    call {:si_unique_call 258} IoReleaseCancelSpinLock(oldIrql_4);
    goto L110;

  anon608_Then:
    call {:si_unique_call 259} vslice_dummy_var_22 := MoxaProcessEmptyTransmit(extension_4);
    goto anon690_Then, anon690_Else;

  anon690_Else:
    assume {:partition} yogi_error != 1;
    goto L915;

  anon690_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon607_Then:
    assume {:partition} sdv_33 == 0;
    status_1 := -1073741823;
    call {:si_unique_call 260} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon689_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon665_Then:
    assume {:partition} ioControlCode_1 == 1769492;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon519_Then, anon519_Else;

  anon519_Else:
    status_1 := -1073741808;
    goto L110;

  anon519_Then:
    call {:si_unique_call 261} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 262} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon688_Then, anon688_Else;

  anon688_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1193;
    call {:si_unique_call 263} MoxaFunc(vslice_dummy_var_1193, 12, 1028);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 264} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon688_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon666_Then:
    assume {:partition} ioControlCode_1 == 1769488;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon518_Then, anon518_Else;

  anon518_Else:
    status_1 := -1073741808;
    goto L110;

  anon518_Then:
    call {:si_unique_call 265} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 266} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon687_Then, anon687_Else;

  anon687_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1194;
    call {:si_unique_call 267} MoxaFunc(vslice_dummy_var_1194, 11, 1028);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    call {:si_unique_call 268} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon687_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon667_Then:
    assume {:partition} ioControlCode_1 == 1769484;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Lc;
    mask := 255;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon684_Then, anon684_Else;

  anon684_Else:
    status_1 := -1073741789;
    goto L110;

  anon684_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon609_Then, anon609_Else;

  anon609_Else:
    status_1 := -1073741808;
    goto L110;

  anon609_Then:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon610_Then, anon610_Else;

  anon610_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon671_Then, anon671_Else;

  anon671_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon670_Then, anon670_Else;

  anon670_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon669_Then, anon669_Else;

  anon669_Else:
    lData := 3;
    goto L968;

  L968:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon685_Then, anon685_Else;

  anon685_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon675_Then, anon675_Else;

  anon675_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon674_Then, anon674_Else;

  anon674_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon673_Then, anon673_Else;

  anon673_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon672_Then, anon672_Else;

  anon672_Else:
    lParity := 32;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L978;

  L978:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon611_Then, anon611_Else;

  anon611_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon677_Then, anon677_Else;

  anon677_Else:
    assume {:nonnull} Lc != 0;
    assume Lc > 0;
    goto anon676_Then, anon676_Else;

  anon676_Else:
    goto anon613_Then, anon613_Else;

  anon613_Else:
    assume {:partition} lData != 0;
    lStop := 8;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L987;

  L987:
    call {:si_unique_call 269} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 270} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon686_Then, anon686_Else;

  anon686_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc Tmp_223;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1195;
    call {:si_unique_call 271} MoxaFunc(vslice_dummy_var_1195, 41, Tmp_223);
    call {:si_unique_call 272} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon686_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon613_Then:
    assume {:partition} lData == 0;
    status_1 := -1073741811;
    goto L110;

  anon676_Then:
    status_1 := -1073741811;
    goto L110;

  anon677_Then:
    goto anon612_Then, anon612_Else;

  anon612_Else:
    assume {:partition} lData != 0;
    status_1 := -1073741811;
    goto L110;

  anon612_Then:
    assume {:partition} lData == 0;
    lStop := 4;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L987;

  anon611_Then:
    lStop := 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L987;

  anon672_Then:
    status_1 := -1073741811;
    goto L110;

  anon673_Then:
    lParity := 160;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L978;

  anon674_Then:
    lParity := 64;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L978;

  anon675_Then:
    lParity := 192;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L978;

  anon685_Then:
    lParity := 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto L978;

  anon669_Then:
    status_1 := -1073741811;
    goto L110;

  anon670_Then:
    lData := 2;
    mask := 127;
    goto L968;

  anon671_Then:
    lData := 1;
    mask := 63;
    goto L968;

  anon610_Then:
    lData := 0;
    mask := 31;
    goto L968;

  anon668_Then:
    assume {:partition} ioControlCode_1 == 1769480;
    goto L110;

  anon680_Then:
    assume {:partition} ioControlCode_1 == 1769476;
    assume {:nonnull} irpSp_1 != 0;
    assume irpSp_1 > 0;
    goto anon614_Then, anon614_Else;

  anon614_Else:
    status_1 := -1073741789;
    goto L110;

  anon614_Then:
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    havoc Tmp_164;
    assume {:nonnull} Tmp_164 != 0;
    assume Tmp_164 > 0;
    havoc baudRate;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon682_Then, anon682_Else;

  anon682_Else:
    status_1 := -1073741811;
    goto L110;

  anon682_Then:
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1196;
    call {:si_unique_call 273} status_1 := MoxaGetDivisorFromBaud(vslice_dummy_var_1196, baudRate, divisor);
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    goto anon615_Then, anon615_Else;

  anon615_Else:
    status_1 := -1073741808;
    goto L110;

  anon615_Then:
    call {:si_unique_call 274} Tmp_87 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    Mem_T.INT4[Tmp_87] := oldIrql_4;
    call {:si_unique_call 275} sdv_KeAcquireSpinLock(0, Tmp_87);
    goto anon683_Then, anon683_Else;

  anon683_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_87 != 0;
    assume Tmp_87 > 0;
    oldIrql_4 := Mem_T.INT4[Tmp_87];
    goto anon616_Then, anon616_Else;

  anon616_Else:
    assume {:partition} status_1 >= 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    assume {:nonnull} divisor != 0;
    assume divisor > 0;
    assume {:nonnull} extension_4 != 0;
    assume extension_4 > 0;
    havoc vslice_dummy_var_1197;
    call {:si_unique_call 276} MoxaFunc(vslice_dummy_var_1197, 36, Mem_T.INT4[divisor]);
    goto L1044;

  L1044:
    call {:si_unique_call 277} sdv_KeReleaseSpinLock(0, oldIrql_4);
    goto L110;

  anon616_Then:
    assume {:partition} 0 > status_1;
    goto L1044;

  anon683_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon516_Then:
    assume {:partition} ioControlCode_1 == 1777772;
    goto L25;

  anon515_Then:
    assume {:partition} ioControlCode_1 == 1777728;
    goto L25;

  anon514_Then:
    assume {:partition} ioControlCode_1 == 1778076;
    goto L25;

  anon513_Then:
    assume {:partition} ioControlCode_1 == 1778072;
    goto L25;

  anon512_Then:
    assume {:partition} ioControlCode_1 == 1778068;
    goto L25;

  anon511_Then:
    assume {:partition} ioControlCode_1 == 1778064;
    goto L25;

  anon679_Then:
    call {:si_unique_call 278} status_1 := MoxaIRPPrologue(Irp_1, extension_4);
    goto anon765_Then, anon765_Else;

  anon765_Else:
    assume {:partition} yogi_error != 1;
    goto anon617_Then, anon617_Else;

  anon617_Else:
    assume {:partition} status_1 != 0;
    assume {:nonnull} Irp_1 != 0;
    assume Irp_1 > 0;
    call {:si_unique_call 279} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 280} MoxaIRPEpilogue(extension_4);
    Tmp_83 := status_1;
    goto L1;

  anon617_Then:
    assume {:partition} status_1 == 0;
    call {:si_unique_call 281} sdv_42 := MoxaCompleteIfError(DeviceObject_1, Irp_1);
    goto anon618_Then, anon618_Else;

  anon618_Else:
    assume {:partition} sdv_42 != 0;
    Tmp_83 := -1073741536;
    goto L1;

  anon618_Then:
    assume {:partition} sdv_42 == 0;
    goto L25;

  anon765_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaWriteReg"} MoxaWriteReg(actual_PortOfs: int, actual_reg: int, actual_value: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaWriteReg"} MoxaWriteReg(actual_PortOfs: int, actual_reg: int, actual_value: int)
{
  var {:pointer} Tmp_261: int;
  var {:pointer} Tmp_262: int;
  var {:pointer} PortOfs: int;
  var {:scalar} reg: int;
  var {:scalar} value: int;
  var vslice_dummy_var_27: int;
  var vslice_dummy_var_28: int;

  anon0:
    call {:si_unique_call 282} vslice_dummy_var_27 := __HAVOC_malloc(4);
    PortOfs := actual_PortOfs;
    reg := actual_reg;
    value := actual_value;
    Tmp_261 := PortOfs;
    assume {:nonnull} Tmp_261 != 0;
    assume Tmp_261 > 0;
    Mem_T.INT4[Tmp_261] := value;
    Tmp_262 := PortOfs;
    assume {:nonnull} Tmp_262 != 0;
    assume Tmp_262 > 0;
    Mem_T.INT4[Tmp_262] := reg;
    assume {:nonnull} PortOfs != 0;
    assume PortOfs > 0;
    Mem_T.INT4[PortOfs] := 24;
    call {:si_unique_call 283} vslice_dummy_var_28 := MoxaWaitFinish(PortOfs);
    return;
}



procedure {:origName "MoxaReadReg"} MoxaReadReg(actual_PortOfs_1: int, actual_reg_1: int) returns (Tmp_265: int);
  modifies Mem_T.INT4, alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaReadReg"} MoxaReadReg(actual_PortOfs_1: int, actual_reg_1: int) returns (Tmp_265: int)
{
  var {:pointer} Tmp_266: int;
  var {:pointer} Tmp_268: int;
  var {:scalar} value_1: int;
  var {:pointer} PortOfs_1: int;
  var {:scalar} reg_1: int;
  var vslice_dummy_var_29: int;

  anon0:
    PortOfs_1 := actual_PortOfs_1;
    reg_1 := actual_reg_1;
    Tmp_268 := PortOfs_1;
    assume {:nonnull} Tmp_268 != 0;
    assume Tmp_268 > 0;
    Mem_T.INT4[Tmp_268] := reg_1;
    assume {:nonnull} PortOfs_1 != 0;
    assume PortOfs_1 > 0;
    Mem_T.INT4[PortOfs_1] := 23;
    call {:si_unique_call 284} vslice_dummy_var_29 := MoxaWaitFinish(PortOfs_1);
    Tmp_266 := PortOfs_1;
    assume {:nonnull} Tmp_266 != 0;
    assume Tmp_266 > 0;
    value_1 := Mem_T.INT4[Tmp_266];
    Tmp_265 := value_1;
    return;
}



procedure {:origName "MoxaCreateOpen"} MoxaCreateOpen(actual_DeviceObject_2: int, actual_Irp_2: int) returns (Tmp_269: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCreateOpen"} MoxaCreateOpen(actual_DeviceObject_2: int, actual_Irp_2: int) returns (Tmp_269: int)
{
  var {:pointer} Tmp_270: int;
  var {:pointer} sdv_57: int;
  var {:scalar} Tmp_272: int;
  var {:scalar} sdv_61: int;
  var {:pointer} Tmp_273: int;
  var {:scalar} status_2: int;
  var {:pointer} extension_5: int;
  var {:pointer} DeviceObject_2: int;
  var {:pointer} Irp_2: int;
  var boogieTmp: int;
  var vslice_dummy_var_30: int;
  var vslice_dummy_var_31: int;
  var vslice_dummy_var_32: int;
  var vslice_dummy_var_33: int;
  var vslice_dummy_var_34: int;
  var vslice_dummy_var_1198: int;
  var vslice_dummy_var_1199: int;
  var vslice_dummy_var_1200: int;
  var vslice_dummy_var_1201: int;
  var vslice_dummy_var_1202: int;

  anon0:
    DeviceObject_2 := actual_DeviceObject_2;
    Irp_2 := actual_Irp_2;
    call {:si_unique_call 285} Tmp_273 := __HAVOC_malloc(16);
    assume {:nonnull} DeviceObject_2 != 0;
    assume DeviceObject_2 > 0;
    havoc extension_5;
    call {:si_unique_call 286} sdv_57 := sdv_IoGetCurrentIrpStackLocation(Irp_2);
    assume {:nonnull} sdv_57 != 0;
    assume sdv_57 > 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 287} sdv_IoCompleteRequest(0, 0);
    Tmp_269 := -1073741565;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon31_Then:
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    goto anon32_Then, anon32_Else;

  anon32_Else:
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 288} sdv_IoCompleteRequest(0, 0);
    Tmp_269 := 0;
    goto L1;

  anon32_Then:
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 289} sdv_IoCompleteRequest(0, 0);
    Tmp_269 := -1073741670;
    goto L1;

  anon34_Then:
    call {:si_unique_call 290} ExAcquireFastMutex(0);
    call {:si_unique_call 291} status_2 := MoxaIRPPrologue(Irp_2, extension_5);
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} yogi_error != 1;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:partition} status_2 != 0;
    call {:si_unique_call 292} ExReleaseFastMutex(0);
    call {:si_unique_call 293} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 294} MoxaIRPEpilogue(extension_5);
    Tmp_269 := status_2;
    goto L1;

  anon35_Then:
    assume {:partition} status_2 == 0;
    call {:si_unique_call 295} Tmp_270 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc vslice_dummy_var_1198;
    Mem_T.INT4[Tmp_270] := vslice_dummy_var_1198;
    call {:si_unique_call 296} sdv_61 := sdv_InterlockedIncrement(Tmp_270);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} sdv_61 != 1;
    call {:si_unique_call 297} ExReleaseFastMutex(0);
    call {:si_unique_call 298} Tmp_270 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc vslice_dummy_var_1199;
    Mem_T.INT4[Tmp_270] := vslice_dummy_var_1199;
    call {:si_unique_call 299} vslice_dummy_var_31 := sdv_InterlockedDecrement(Tmp_270);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 300} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 301} MoxaIRPEpilogue(extension_5);
    Tmp_269 := -1073741790;
    goto L1;

  anon36_Then:
    assume {:partition} sdv_61 == 1;
    call {:si_unique_call 302} vslice_dummy_var_30 := MoxaGetPortPropertyFromRegistry(extension_5);
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    goto L74;

  L74:
    call {:si_unique_call 303} ExReleaseFastMutex(0);
    call {:si_unique_call 304} Tmp_270 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc vslice_dummy_var_1200;
    Mem_T.INT4[Tmp_270] := vslice_dummy_var_1200;
    call {:si_unique_call 305} vslice_dummy_var_32 := sdv_InterlockedDecrement(Tmp_270);
    assume {:nonnull} Tmp_270 != 0;
    assume Tmp_270 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 306} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 307} MoxaIRPEpilogue(extension_5);
    Tmp_269 := -1073741790;
    goto L1;

  anon37_Then:
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc Tmp_272;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_273;
    assume {:nonnull} Tmp_273 != 0;
    assume Tmp_273 > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:partition} Mem_T.INT4[Tmp_273 + Tmp_272 * 4] != 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 308} boogieTmp := corral_nondet();
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 309} boogieTmp := corral_nondet();
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 310} boogieTmp := corral_nondet();
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 311} vslice_dummy_var_33 := KeSynchronizeExecution(0, li2bplFunctionConstant354, 0);
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 312} MoxaReset(extension_5);
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc vslice_dummy_var_1201;
    call {:si_unique_call 313} MoxaFuncWithLock(extension_5, 55, vslice_dummy_var_1201);
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    havoc vslice_dummy_var_1202;
    call {:si_unique_call 314} MoxaFuncWithLock(extension_5, 54, vslice_dummy_var_1202);
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 315} MoxaFuncWithLock(extension_5, 2, 1028);
    goto anon43_Then, anon43_Else;

  anon43_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 316} MoxaFuncWithLock(extension_5, 20, 1028);
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 317} boogieTmp := corral_nondet();
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(extension_5)] := boogieTmp;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    assume {:nonnull} extension_5 != 0;
    assume extension_5 > 0;
    call {:si_unique_call 318} vslice_dummy_var_34 := MoxaAddTimeOutProc(extension_5);
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 319} ExReleaseFastMutex(0);
    call {:si_unique_call 320} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 321} MoxaIRPEpilogue(extension_5);
    Tmp_269 := 0;
    goto L1;

  anon45_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon44_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon43_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon42_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon41_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon40_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon39_Then:
    assume {:partition} Mem_T.INT4[Tmp_273 + Tmp_272 * 4] == 0;
    goto L74;

  anon38_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon33_Then:
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    assume {:nonnull} Irp_2 != 0;
    assume Irp_2 > 0;
    call {:si_unique_call 322} sdv_IoCompleteRequest(0, 0);
    Tmp_269 := -1073741810;
    goto L1;
}



procedure {:origName "MoxaCleanup"} MoxaCleanup(actual_DeviceObject_3: int, actual_Irp_3: int) returns (Tmp_274: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCleanup"} MoxaCleanup(actual_DeviceObject_3: int, actual_Irp_3: int) returns (Tmp_274: int)
{
  var {:pointer} Tmp_275: int;
  var {:pointer} Tmp_276: int;
  var {:pointer} Tmp_277: int;
  var {:pointer} Tmp_278: int;
  var {:scalar} cancelRoutine: int;
  var {:scalar} oldIrql_5: int;
  var {:scalar} status_3: int;
  var {:pointer} Tmp_279: int;
  var {:pointer} extension_6: int;
  var {:pointer} DeviceObject_3: int;
  var {:pointer} Irp_3: int;
  var vslice_dummy_var_1203: int;
  var vslice_dummy_var_1204: int;
  var vslice_dummy_var_1205: int;
  var vslice_dummy_var_1206: int;

  anon0:
    DeviceObject_3 := actual_DeviceObject_3;
    Irp_3 := actual_Irp_3;
    assume {:nonnull} DeviceObject_3 != 0;
    assume DeviceObject_3 > 0;
    havoc extension_6;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    goto L9;

  L9:
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    call {:si_unique_call 323} sdv_IoCompleteRequest(0, 0);
    goto L14;

  L14:
    Tmp_274 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon39_Then:
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    goto anon33_Then, anon33_Else;

  anon33_Else:
    call {:si_unique_call 324} status_3 := MoxaIRPPrologue(Irp_3, extension_6);
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} yogi_error != 1;
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:partition} status_3 != 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:partition} status_3 == -1073741738;
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    havoc status_3;
    goto L24;

  L24:
    call {:si_unique_call 325} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 326} MoxaIRPEpilogue(extension_6);
    Tmp_274 := status_3;
    goto L1;

  anon35_Then:
    assume {:partition} status_3 != -1073741738;
    goto L24;

  anon34_Then:
    assume {:partition} status_3 == 0;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    call {:si_unique_call 327} MoxaKillAllReadsOrWrites(DeviceObject_3, WriteQueue__MOXA_DEVICE_EXTENSION(extension_6), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_6));
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    call {:si_unique_call 328} MoxaKillAllReadsOrWrites(DeviceObject_3, ReadQueue__MOXA_DEVICE_EXTENSION(extension_6), CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_6));
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    call {:si_unique_call 329} MoxaKillAllReadsOrWrites(DeviceObject_3, PurgeQueue__MOXA_DEVICE_EXTENSION(extension_6), CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(extension_6));
    goto anon43_Then, anon43_Else;

  anon43_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    call {:si_unique_call 330} MoxaKillAllReadsOrWrites(DeviceObject_3, MaskQueue__MOXA_DEVICE_EXTENSION(extension_6), CurrentMaskIrp__MOXA_DEVICE_EXTENSION(extension_6));
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 331} Tmp_278 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_278 != 0;
    assume Tmp_278 > 0;
    Mem_T.INT4[Tmp_278] := oldIrql_5;
    call {:si_unique_call 332} IoAcquireCancelSpinLock(Tmp_278);
    assume {:nonnull} Tmp_278 != 0;
    assume Tmp_278 > 0;
    oldIrql_5 := Mem_T.INT4[Tmp_278];
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc Tmp_279;
    assume {:nonnull} Tmp_279 != 0;
    assume Tmp_279 > 0;
    cancelRoutine := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_279)];
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc Tmp_276;
    assume {:nonnull} Tmp_276 != 0;
    assume Tmp_276 > 0;
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} cancelRoutine != 0;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc Tmp_275;
    assume {:nonnull} Tmp_275 != 0;
    assume Tmp_275 > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(Tmp_275)] := oldIrql_5;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc Tmp_277;
    assume {:nonnull} Tmp_277 != 0;
    assume Tmp_277 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_277)] := 0;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    goto anon37_Then, anon37_Else;

  anon37_Else:
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:IndirectCall} true;
    assume cancelRoutine == li2bplFunctionConstant321;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc vslice_dummy_var_1203;
    call {:si_unique_call 333} MoxaCancelCurrentWrite(DeviceObject_3, vslice_dummy_var_1203);
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} yogi_error != 1;
    goto L61;

  L61:
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    assume {:nonnull} Irp_3 != 0;
    assume Irp_3 > 0;
    call {:si_unique_call 334} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 335} MoxaIRPEpilogue(extension_6);
    goto L14;

  anon48_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon38_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine == li2bplFunctionConstant188;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc vslice_dummy_var_1204;
    call {:si_unique_call 336} MoxaCancelQueued(DeviceObject_3, vslice_dummy_var_1204);
    goto L61;

  anon37_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine == li2bplFunctionConstant418;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc vslice_dummy_var_1205;
    call {:si_unique_call 337} MoxaCancelWait(DeviceObject_3, vslice_dummy_var_1205);
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} yogi_error != 1;
    goto L61;

  anon47_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon46_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine == li2bplFunctionConstant202;
    assume {:nonnull} extension_6 != 0;
    assume extension_6 > 0;
    havoc vslice_dummy_var_1206;
    call {:si_unique_call 338} MoxaFilterCancelQueued(DeviceObject_3, vslice_dummy_var_1206);
    goto L61;

  anon45_Then:
    assume {:partition} cancelRoutine == 0;
    call {:si_unique_call 339} IoReleaseCancelSpinLock(oldIrql_5);
    goto L61;

  anon36_Then:
    call {:si_unique_call 340} IoReleaseCancelSpinLock(oldIrql_5);
    goto L61;

  anon44_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon43_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon42_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon41_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon40_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon33_Then:
    goto L9;
}



procedure {:origName "MoxaClose"} MoxaClose(actual_DeviceObject_4: int, actual_Irp_4: int) returns (Tmp_280: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaClose"} MoxaClose(actual_DeviceObject_4: int, actual_Irp_4: int) returns (Tmp_280: int)
{
  var {:pointer} SD5: int;
  var {:pointer} structPtr888charTime: int;
  var {:scalar} count_3: int;
  var {:scalar} count1: int;
  var {:scalar} sdv_67: int;
  var {:scalar} charTime: int;
  var {:scalar} pendingDPCs: int;
  var {:scalar} allSentDelay: int;
  var {:scalar} sdv_69: int;
  var {:pointer} ofs_7: int;
  var {:scalar} sdv_74: int;
  var {:scalar} sdv_5: int;
  var {:scalar} Tmp_282: int;
  var {:pointer} Tmp_283: int;
  var {:pointer} Tmp_284: int;
  var {:scalar} status_4: int;
  var {:pointer} extension_7: int;
  var {:scalar} sdv_77: int;
  var {:scalar} Tmp_285: int;
  var {:pointer} DeviceObject_4: int;
  var {:pointer} Irp_4: int;
  var boogieTmp: int;
  var vslice_dummy_var_35: int;
  var vslice_dummy_var_36: int;
  var vslice_dummy_var_37: int;
  var vslice_dummy_var_38: int;
  var vslice_dummy_var_39: int;
  var vslice_dummy_var_40: int;
  var vslice_dummy_var_41: int;
  var vslice_dummy_var_1207: int;
  var vslice_dummy_var_1208: int;
  var vslice_dummy_var_1209: int;
  var vslice_dummy_var_1210: int;

  anon0:
    call {:si_unique_call 341} charTime := __HAVOC_malloc(20);
    call {:si_unique_call 342} allSentDelay := __HAVOC_malloc(20);
    call {:si_unique_call 343} sdv_5 := __HAVOC_malloc(20);
    call {:si_unique_call 344} vslice_dummy_var_35 := __HAVOC_malloc(20);
    call {:si_unique_call 345} vslice_dummy_var_36 := __HAVOC_malloc(20);
    DeviceObject_4 := actual_DeviceObject_4;
    Irp_4 := actual_Irp_4;
    assume {:nonnull} DeviceObject_4 != 0;
    assume DeviceObject_4 > 0;
    havoc extension_7;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    call {:si_unique_call 346} sdv_IoCompleteRequest(0, 0);
    Tmp_280 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon41_Then:
    call {:si_unique_call 347} ExAcquireFastMutex(0);
    call {:si_unique_call 348} vslice_dummy_var_37 := MoxaDelTimeOutProc(extension_7);
    call {:si_unique_call 349} status_4 := MoxaIRPPrologue(Irp_4, extension_7);
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:partition} yogi_error != 1;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    assume {:partition} status_4 != 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:partition} status_4 == -1073741738;
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    havoc status_4;
    goto L34;

  L34:
    call {:si_unique_call 350} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 351} MoxaIRPEpilogue(extension_7);
    call {:si_unique_call 352} Tmp_284 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc vslice_dummy_var_1207;
    Mem_T.INT4[Tmp_284] := vslice_dummy_var_1207;
    call {:si_unique_call 353} sdv_74 := sdv_InterlockedDecrement(Tmp_284);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    call {:si_unique_call 354} ExReleaseFastMutex(0);
    Tmp_280 := status_4;
    goto L1;

  anon39_Then:
    assume {:partition} status_4 != -1073741738;
    goto L34;

  anon37_Then:
    assume {:partition} status_4 == 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    goto anon38_Then, anon38_Else;

  anon38_Else:
    call {:si_unique_call 355} ExReleaseFastMutex(0);
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    call {:si_unique_call 356} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 357} MoxaIRPEpilogue(extension_7);
    Tmp_280 := -1073741808;
    goto L1;

  anon38_Then:
    call {:si_unique_call 358} SD5 := MoxaGetCharTime(extension_7);
    assume {:nonnull} SD5 != 0;
    assume SD5 > 0;
    assume {:nonnull} sdv_5 != 0;
    assume sdv_5 > 0;
    assume {:nonnull} SD5 != 0;
    assume SD5 > 0;
    assume {:nonnull} sdv_5 != 0;
    assume sdv_5 > 0;
    assume {:nonnull} SD5 != 0;
    assume SD5 > 0;
    assume {:nonnull} sdv_5 != 0;
    assume sdv_5 > 0;
    assume {:nonnull} SD5 != 0;
    assume SD5 > 0;
    assume {:nonnull} sdv_5 != 0;
    assume sdv_5 > 0;
    assume {:nonnull} SD5 != 0;
    assume SD5 > 0;
    assume {:nonnull} sdv_5 != 0;
    assume sdv_5 > 0;
    call {:si_unique_call 359} structPtr888charTime := RtlLargeIntegerNegate(sdv_5);
    assume {:nonnull} charTime != 0;
    assume charTime > 0;
    assume {:nonnull} structPtr888charTime != 0;
    assume structPtr888charTime > 0;
    assume {:nonnull} charTime != 0;
    assume charTime > 0;
    assume {:nonnull} structPtr888charTime != 0;
    assume structPtr888charTime > 0;
    assume {:nonnull} charTime != 0;
    assume charTime > 0;
    assume {:nonnull} structPtr888charTime != 0;
    assume structPtr888charTime > 0;
    assume {:nonnull} charTime != 0;
    assume charTime > 0;
    assume {:nonnull} structPtr888charTime != 0;
    assume structPtr888charTime > 0;
    assume {:nonnull} charTime != 0;
    assume charTime > 0;
    assume {:nonnull} structPtr888charTime != 0;
    assume structPtr888charTime > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc ofs_7;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    goto anon43_Then, anon43_Else;

  anon43_Else:
    call {:si_unique_call 360} MoxaFuncWithLock(extension_7, 12, 1028);
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    goto L72;

  L72:
    assume {:nonnull} ofs_7 != 0;
    assume ofs_7 > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} BAND(Mem_T.INT4[ofs_7], 2) != 0;
    call {:si_unique_call 361} MoxaFuncWithLock(extension_7, 16, 0);
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} yogi_error != 1;
    goto L77;

  L77:
    count1 := 0;
    goto L85;

  L85:
    call {:si_unique_call 362} count_3, count1, sdv_69, boogieTmp, vslice_dummy_var_38 := MoxaClose_loop_L85(count_3, count1, allSentDelay, sdv_69, extension_7, boogieTmp, vslice_dummy_var_38);
    goto L85_last;

  L85_last:
    call {:si_unique_call 385} sdv_69 := GetDeviceTxQueueWithLock(extension_7);
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:partition} yogi_error != 1;
    count_3 := sdv_69;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc count_3;
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} count_3 != count1;
    count1 := count_3;
    assume {:nonnull} allSentDelay != 0;
    assume allSentDelay > 0;
    call {:si_unique_call 363} boogieTmp := corral_nondet();
    assume {:nonnull} allSentDelay != 0;
    assume allSentDelay > 0;
    call {:si_unique_call 364} boogieTmp := corral_nondet();
    assume {:nonnull} allSentDelay != 0;
    assume allSentDelay > 0;
    call {:si_unique_call 365} boogieTmp := corral_nondet();
    assume {:nonnull} allSentDelay != 0;
    assume allSentDelay > 0;
    call {:si_unique_call 366} boogieTmp := corral_nondet();
    assume {:nonnull} allSentDelay != 0;
    assume allSentDelay > 0;
    call {:si_unique_call 367} boogieTmp := corral_nondet();
    call {:si_unique_call 368} vslice_dummy_var_38 := KeDelayExecutionThread(0, 1, 0);
    goto anon47_Else_dummy;

  anon47_Else_dummy:
    assume false;
    return;

  anon47_Then:
    assume {:partition} count_3 == count1;
    call {:si_unique_call 369} MoxaFuncWithLock(extension_7, 21, 0);
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 370} MoxaFuncWithLock(extension_7, 37, 0);
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 371} MoxaFuncWithLock(extension_7, 38, 0);
    goto anon50_Then, anon50_Else;

  anon50_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 372} MoxaFuncWithLock(extension_7, 29, 1028);
    goto anon51_Then, anon51_Else;

  anon51_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc Tmp_282;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc Tmp_285;
    havoc Mem_T.INT4;
    Tmp_283 := ofs_7;
    assume {:nonnull} Tmp_283 != 0;
    assume Tmp_283 > 0;
    Mem_T.INT4[Tmp_283] := 0;
    call {:si_unique_call 373} MoxaFuncWithLock(extension_7, 3, 1028);
    goto anon52_Then, anon52_Else;

  anon52_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    goto anon53_Then, anon53_Else;

  anon53_Else:
    call {:si_unique_call 374} vslice_dummy_var_39 := IoCancelIrp(0);
    goto L117;

  L117:
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    assume {:nonnull} Irp_4 != 0;
    assume Irp_4 > 0;
    call {:si_unique_call 375} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 376} MoxaIRPEpilogue(extension_7);
    call {:si_unique_call 377} Tmp_284 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc vslice_dummy_var_1208;
    Mem_T.INT4[Tmp_284] := vslice_dummy_var_1208;
    call {:si_unique_call 378} sdv_77 := sdv_InterlockedDecrement(Tmp_284);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    pendingDPCs := sdv_77;
    goto anon54_Then, anon54_Else;

  anon54_Else:
    assume {:partition} pendingDPCs != 0;
    call {:si_unique_call 379} vslice_dummy_var_40 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L133;

  L133:
    call {:si_unique_call 380} ExReleaseFastMutex(0);
    call {:si_unique_call 381} Tmp_284 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc vslice_dummy_var_1209;
    Mem_T.INT4[Tmp_284] := vslice_dummy_var_1209;
    call {:si_unique_call 382} vslice_dummy_var_41 := sdv_InterlockedIncrement(Tmp_284);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    call {:si_unique_call 383} Tmp_284 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    havoc vslice_dummy_var_1210;
    Mem_T.INT4[Tmp_284] := vslice_dummy_var_1210;
    call {:si_unique_call 384} sdv_67 := sdv_InterlockedDecrement(Tmp_284);
    assume {:nonnull} Tmp_284 != 0;
    assume Tmp_284 > 0;
    assume {:nonnull} extension_7 != 0;
    assume extension_7 > 0;
    Tmp_280 := 0;
    goto L1;

  anon54_Then:
    assume {:partition} pendingDPCs == 0;
    goto L133;

  anon53_Then:
    goto L117;

  anon52_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon51_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon50_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon49_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon48_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon46_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon45_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon40_Then:
    assume {:partition} BAND(Mem_T.INT4[ofs_7], 2) == 0;
    goto L77;

  anon44_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon43_Then:
    goto L72;

  anon42_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaReset"} MoxaReset(actual_Extension_4: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_2) || sdv_irql_previous_4 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_5) || sdv_irql_previous_3 == old(sdv_irql_previous) || sdv_irql_previous_3 == old(sdv_irql_current);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaReset"} MoxaReset(actual_Extension_4: int)
{
  var {:scalar} Tmp_287: int;
  var {:scalar} S_2: int;
  var {:pointer} ofs_8: int;
  var {:dopa} {:scalar} divisor_1: int;
  var {:pointer} Tmp_289: int;
  var {:pointer} Extension_4: int;
  var vslice_dummy_var_42: int;
  var vslice_dummy_var_43: int;
  var vslice_dummy_var_44: int;
  var vslice_dummy_var_1211: int;
  var vslice_dummy_var_1212: int;
  var vslice_dummy_var_1213: int;

  anon0:
    call {:si_unique_call 386} S_2 := __HAVOC_malloc(8);
    call {:si_unique_call 387} vslice_dummy_var_42 := __HAVOC_malloc(4);
    call {:si_unique_call 388} divisor_1 := __HAVOC_malloc(4);
    Extension_4 := actual_Extension_4;
    assume {:nonnull} Extension_4 != 0;
    assume Extension_4 > 0;
    havoc ofs_8;
    call {:si_unique_call 389} MoxaFuncWithLock(Extension_4, 1, 1028);
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Extension_4 != 0;
    assume Extension_4 > 0;
    havoc Tmp_287;
    call {:si_unique_call 390} MoxaFuncWithLock(Extension_4, 41, Tmp_287);
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Extension_4 != 0;
    assume Extension_4 > 0;
    havoc vslice_dummy_var_1211;
    havoc vslice_dummy_var_1212;
    call {:si_unique_call 391} vslice_dummy_var_43 := MoxaGetDivisorFromBaud(vslice_dummy_var_1211, vslice_dummy_var_1212, divisor_1);
    assume {:nonnull} divisor_1 != 0;
    assume divisor_1 > 0;
    call {:si_unique_call 392} MoxaFuncWithLock(Extension_4, 36, Mem_T.INT4[divisor_1]);
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} S_2 != 0;
    assume S_2 > 0;
    assume {:nonnull} Extension_4 != 0;
    assume Extension_4 > 0;
    assume {:nonnull} S_2 != 0;
    assume S_2 > 0;
    call {:si_unique_call 393} vslice_dummy_var_44 := MoxaSetupNewHandFlow(S_2);
    Tmp_289 := ofs_8;
    assume {:nonnull} Tmp_289 != 0;
    assume Tmp_289 > 0;
    havoc vslice_dummy_var_1213;
    Mem_T.INT4[Tmp_289] := vslice_dummy_var_1213;
    goto LM2;

  LM2:
    return;

  anon9_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon8_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon7_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init12"} _sdv_init12();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init12"} _sdv_init12()
{
  var vslice_dummy_var_45: int;

  anon0:
    call {:si_unique_call 394} vslice_dummy_var_45 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaGetPortPropertyFromRegistry"} MoxaGetPortPropertyFromRegistry(actual_extension_8: int) returns (Tmp_292: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} Tmp_292 == -1073741811 || Tmp_292 == -1073741823 || Tmp_292 == 0 || Tmp_292 == 5 || Tmp_292 == -1073741789 || Tmp_292 == -1073741670 || Tmp_292 == -1073741808;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetPortPropertyFromRegistry"} MoxaGetPortPropertyFromRegistry(actual_extension_8: int) returns (Tmp_292: int)
{
  var {:pointer} keyHandle: int;
  var {:pointer} Tmp_294: int;
  var {:dopa} {:scalar} data_2: int;
  var {:dopa} {:scalar} dataLen: int;
  var {:scalar} status_5: int;
  var {:pointer} Tmp_295: int;
  var {:pointer} extension_8: int;
  var vslice_dummy_var_46: int;

  anon0:
    call {:si_unique_call 395} data_2 := __HAVOC_malloc(4);
    call {:si_unique_call 396} dataLen := __HAVOC_malloc(4);
    extension_8 := actual_extension_8;
    call {:si_unique_call 397} Tmp_294 := __HAVOC_malloc(28);
    call {:si_unique_call 398} Tmp_295 := __HAVOC_malloc(48);
    assume {:nonnull} data_2 != 0;
    assume data_2 > 0;
    Mem_T.INT4[data_2] := 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    call {:si_unique_call 399} status_5 := IoOpenDeviceRegistryKey(0, 1, 131072, 0);
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} status_5 >= 0;
    Tmp_295 := strConst__li2bpl19;
    call {:si_unique_call 400} status_5 := MoxaGetRegistryKeyValue(keyHandle, Tmp_295, 24, data_2, 4, dataLen);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} status_5 >= 0;
    assume {:nonnull} data_2 != 0;
    assume data_2 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} Mem_T.INT4[data_2] != 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    goto L22;

  L22:
    Tmp_294 := strConst__li2bpl20;
    call {:si_unique_call 401} status_5 := MoxaGetRegistryKeyValue(keyHandle, Tmp_294, 14, data_2, 4, dataLen);
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} status_5 >= 0;
    assume {:nonnull} data_2 != 0;
    assume data_2 > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} Mem_T.INT4[data_2] != 0;
    assume {:nonnull} extension_8 != 0;
    assume extension_8 > 0;
    goto L30;

  L30:
    call {:si_unique_call 402} vslice_dummy_var_46 := ZwClose(0);
    Tmp_292 := status_5;
    goto L1;

  L1:
    return;

  anon15_Then:
    assume {:partition} Mem_T.INT4[data_2] == 0;
    goto L30;

  anon14_Then:
    assume {:partition} 0 > status_5;
    goto L30;

  anon13_Then:
    assume {:partition} Mem_T.INT4[data_2] == 0;
    goto L22;

  anon12_Then:
    assume {:partition} 0 > status_5;
    goto L22;

  anon11_Then:
    assume {:partition} 0 > status_5;
    Tmp_292 := status_5;
    goto L1;
}



procedure {:origName "MoxaGetCharTime"} MoxaGetCharTime(actual_Extension_5: int) returns (SD6: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetCharTime"} MoxaGetCharTime(actual_Extension_5: int) returns (SD6: int)
{
  var {:scalar} dataSize: int;
  var {:scalar} Tmp_296: int;
  var {:scalar} charTime_1: int;
  var {:scalar} Tmp_6: int;
  var {:scalar} Tmp_298: int;
  var {:scalar} bitTime: int;
  var {:scalar} paritySize: int;
  var {:scalar} stopSize: int;
  var {:scalar} Tmp_299: int;
  var {:pointer} Extension_5: int;
  var vslice_dummy_var_47: int;

  anon0:
    call {:si_unique_call 403} vslice_dummy_var_47 := __HAVOC_malloc(20);
    call {:si_unique_call 404} Tmp_6 := __HAVOC_malloc(20);
    Extension_5 := actual_Extension_5;
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    havoc Tmp_296;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} Tmp_296 == 1;
    dataSize := 6;
    goto L14;

  L14:
    paritySize := 1;
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    goto L17;

  L17:
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    stopSize := 2;
    goto L20;

  L20:
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    havoc bitTime;
    charTime_1 := bitTime + (dataSize + paritySize + stopSize) * bitTime;
    call {:si_unique_call 405} SD6 := RtlConvertUlongToLargeInteger(charTime_1);
    assume {:nonnull} SD6 != 0;
    assume SD6 > 0;
    assume {:nonnull} Tmp_6 != 0;
    assume Tmp_6 > 0;
    assume {:nonnull} SD6 != 0;
    assume SD6 > 0;
    assume {:nonnull} Tmp_6 != 0;
    assume Tmp_6 > 0;
    assume {:nonnull} SD6 != 0;
    assume SD6 > 0;
    assume {:nonnull} Tmp_6 != 0;
    assume Tmp_6 > 0;
    assume {:nonnull} SD6 != 0;
    assume SD6 > 0;
    assume {:nonnull} Tmp_6 != 0;
    assume Tmp_6 > 0;
    assume {:nonnull} SD6 != 0;
    assume SD6 > 0;
    assume {:nonnull} Tmp_6 != 0;
    assume Tmp_6 > 0;
    SD6 := Tmp_6;
    return;

  anon14_Then:
    stopSize := 1;
    goto L20;

  anon16_Then:
    paritySize := 0;
    goto L17;

  anon15_Then:
    assume {:partition} Tmp_296 != 1;
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    havoc Tmp_299;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} Tmp_299 == 2;
    dataSize := 7;
    goto L14;

  anon17_Then:
    assume {:partition} Tmp_299 != 2;
    assume {:nonnull} Extension_5 != 0;
    assume Extension_5 > 0;
    havoc Tmp_298;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} Tmp_298 == 3;
    dataSize := 8;
    goto L14;

  anon18_Then:
    assume {:partition} Tmp_298 != 3;
    dataSize := 8;
    goto L14;

  anon13_Then:
    dataSize := 5;
    goto L14;
}



procedure {:origName "MoxaAddTimeOutProc"} MoxaAddTimeOutProc(actual_extension_9: int) returns (Tmp_300: int);
  modifies alloc, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaAddTimeOutProc"} MoxaAddTimeOutProc(actual_extension_9: int) returns (Tmp_300: int)
{
  var {:pointer} pTmp: int;
  var {:pointer} extension_9: int;

  anon0:
    extension_9 := actual_extension_9;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    havoc pTmp;
    assume {:nonnull} pTmp != 0;
    assume pTmp > 0;
    assume {:nonnull} pTmp != 0;
    assume pTmp > 0;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    goto L13;

  L13:
    goto anon11_Then, anon11_Else;

  anon11_Else:
    call {:si_unique_call 406} MoxaResetTimeOutProc_sdv_static_function_9();
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L15;

  L15:
    Tmp_300 := 1;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon11_Then:
    goto L15;

  anon10_Then:
    goto L13;

  anon9_Then:
    Tmp_300 := 0;
    goto L1;
}



procedure {:origName "MoxaDelTimeOutProc"} MoxaDelTimeOutProc(actual_extension_11: int) returns (Tmp_308: int);
  free ensures {:va_keep} Tmp_308 == 1 || Tmp_308 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDelTimeOutProc"} MoxaDelTimeOutProc(actual_extension_11: int) returns (Tmp_308: int)
{
  var {:pointer} prev: int;
  var {:pointer} next_1: int;
  var {:pointer} extension_11: int;

  anon0:
    extension_11 := actual_extension_11;
    havoc next_1;
    prev := 0;
    goto L7;

  L7:
    call {:si_unique_call 407} prev, next_1 := MoxaDelTimeOutProc_loop_L7(prev, next_1, extension_11);
    goto L7_last;

  L7_last:
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} next_1 != 0;
    assume {:nonnull} next_1 != 0;
    assume next_1 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    prev := next_1;
    assume {:nonnull} prev != 0;
    assume prev > 0;
    havoc next_1;
    goto anon13_Else_dummy;

  anon13_Else_dummy:
    assume false;
    return;

  anon13_Then:
    goto L8;

  L8:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} next_1 != 0;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} prev != 0;
    assume {:nonnull} next_1 != 0;
    assume next_1 > 0;
    assume {:nonnull} prev != 0;
    assume prev > 0;
    assume {:nonnull} prev != 0;
    assume prev > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto L19;

  L19:
    assume {:nonnull} next_1 != 0;
    assume next_1 > 0;
    Tmp_308 := 1;
    goto L1;

  L1:
    return;

  anon15_Then:
    goto L19;

  anon14_Then:
    assume {:partition} prev == 0;
    assume {:nonnull} next_1 != 0;
    assume next_1 > 0;
    goto L19;

  anon12_Then:
    assume {:partition} next_1 == 0;
    Tmp_308 := 0;
    goto L1;

  anon11_Then:
    assume {:partition} next_1 == 0;
    goto L8;
}



procedure {:origName "MoxaResetTimeOutProc_sdv_static_function_9"} MoxaResetTimeOutProc_sdv_static_function_9();
  modifies alloc, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaResetTimeOutProc_sdv_static_function_9"} MoxaResetTimeOutProc_sdv_static_function_9()
{
  var {:scalar} time: int;
  var vslice_dummy_var_48: int;
  var vslice_dummy_var_49: int;

  anon0:
    call {:si_unique_call 408} time := __HAVOC_malloc(20);
    call {:si_unique_call 409} vslice_dummy_var_48 := __HAVOC_malloc(4);
    assume {:nonnull} time != 0;
    assume time > 0;
    call {:si_unique_call 410} vslice_dummy_var_49 := KeSetTimer(0, time, 0);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init9"} _sdv_init9();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init9"} _sdv_init9()
{
  var vslice_dummy_var_50: int;

  anon0:
    call {:si_unique_call 411} vslice_dummy_var_50 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "_sdv_init11"} _sdv_init11();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init11"} _sdv_init11()
{
  var vslice_dummy_var_51: int;

  anon0:
    call {:si_unique_call 412} vslice_dummy_var_51 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaIsrOut"} MoxaIsrOut(actual_Dpc_4: int, actual_DeferredContext_4: int, actual_SystemContext1_4: int, actual_SystemContext2_4: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIsrOut"} MoxaIsrOut(actual_Dpc_4: int, actual_DeferredContext_4: int, actual_SystemContext1_4: int, actual_SystemContext2_4: int)
{
  var {:scalar} oldIrql_7: int;
  var {:pointer} Tmp_327: int;
  var {:pointer} extension_13: int;
  var {:pointer} Dpc_4: int;
  var {:pointer} DeferredContext_4: int;
  var vslice_dummy_var_52: int;
  var vslice_dummy_var_53: int;

  anon0:
    call {:si_unique_call 413} vslice_dummy_var_52 := __HAVOC_malloc(4);
    Dpc_4 := actual_Dpc_4;
    DeferredContext_4 := actual_DeferredContext_4;
    extension_13 := DeferredContext_4;
    call {:si_unique_call 414} Tmp_327 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_327 != 0;
    assume Tmp_327 > 0;
    Mem_T.INT4[Tmp_327] := oldIrql_7;
    call {:si_unique_call 415} IoAcquireCancelSpinLock(Tmp_327);
    assume {:nonnull} Tmp_327 != 0;
    assume Tmp_327 > 0;
    oldIrql_7 := Mem_T.INT4[Tmp_327];
    call {:si_unique_call 416} vslice_dummy_var_53 := KeSynchronizeExecution(0, li2bplFunctionConstant340, 0);
    call {:si_unique_call 417} IoReleaseCancelSpinLock(oldIrql_7);
    call {:si_unique_call 418} MoxaDpcEpilogue(extension_13, Dpc_4);
    return;
}



procedure {:origName "MoxaIsrIn"} MoxaIsrIn(actual_Dpc_5: int, actual_DeferredContext_5: int, actual_SystemContext1_5: int, actual_SystemContext2_5: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIsrIn"} MoxaIsrIn(actual_Dpc_5: int, actual_DeferredContext_5: int, actual_SystemContext1_5: int, actual_SystemContext2_5: int)
{
  var {:pointer} Tmp_328: int;
  var {:scalar} oldIrql_8: int;
  var {:pointer} extension_14: int;
  var {:pointer} Dpc_5: int;
  var {:pointer} DeferredContext_5: int;
  var vslice_dummy_var_54: int;
  var vslice_dummy_var_55: int;

  anon0:
    call {:si_unique_call 419} vslice_dummy_var_54 := __HAVOC_malloc(4);
    Dpc_5 := actual_Dpc_5;
    DeferredContext_5 := actual_DeferredContext_5;
    extension_14 := DeferredContext_5;
    call {:si_unique_call 420} Tmp_328 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_328 != 0;
    assume Tmp_328 > 0;
    Mem_T.INT4[Tmp_328] := oldIrql_8;
    call {:si_unique_call 421} IoAcquireCancelSpinLock(Tmp_328);
    assume {:nonnull} Tmp_328 != 0;
    assume Tmp_328 > 0;
    oldIrql_8 := Mem_T.INT4[Tmp_328];
    call {:si_unique_call 422} vslice_dummy_var_55 := KeSynchronizeExecution(0, li2bplFunctionConstant306, 0);
    call {:si_unique_call 423} IoReleaseCancelSpinLock(oldIrql_8);
    call {:si_unique_call 424} MoxaDpcEpilogue(extension_14, Dpc_5);
    return;
}



procedure {:origName "MoxaISR"} MoxaISR(actual_InterruptObject: int, actual_Context_1: int) returns (Tmp_330: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaISR"} MoxaISR(actual_InterruptObject: int, actual_Context_1: int) returns (Tmp_330: int)
{
  var {:dopa} {:scalar} modemStatus: int;
  var {:scalar} Tmp_331: int;
  var {:pointer} Tmp_332: int;
  var {:scalar} Tmp_333: int;
  var {:pointer} Tmp_335: int;
  var {:pointer} Tmp_336: int;
  var {:scalar} Tmp_337: int;
  var {:scalar} boardNo: int;
  var {:scalar} ack: int;
  var {:pointer} irpSp_3: int;
  var {:pointer} Tmp_338: int;
  var {:pointer} firstInterruptEntry: int;
  var {:pointer} interruptEntry: int;
  var {:pointer} dispatch: int;
  var {:pointer} Tmp_339: int;
  var {:scalar} Tmp_340: int;
  var {:pointer} Tmp_341: int;
  var {:pointer} globalData: int;
  var {:scalar} sdv_92: int;
  var {:pointer} cisrsw: int;
  var {:scalar} change: int;
  var {:scalar} Tmp_342: int;
  var {:scalar} Tmp_343: int;
  var {:scalar} port_1: int;
  var {:pointer} Tmp_344: int;
  var {:scalar} Tmp_345: int;
  var {:pointer} ip: int;
  var {:pointer} Tmp_346: int;
  var {:scalar} Tmp_347: int;
  var {:pointer} Tmp_348: int;
  var {:pointer} sdv_96: int;
  var {:scalar} Tmp_349: int;
  var {:pointer} Tmp_350: int;
  var {:pointer} Tmp_351: int;
  var {:scalar} Tmp_352: int;
  var {:scalar} temp: int;
  var {:pointer} Tmp_353: int;
  var {:scalar} Tmp_355: int;
  var {:pointer} Tmp_356: int;
  var {:scalar} Tmp_357: int;
  var {:pointer} Tmp_358: int;
  var {:pointer} Tmp_359: int;
  var {:pointer} Tmp_360: int;
  var {:pointer} Tmp_361: int;
  var {:pointer} Tmp_362: int;
  var {:scalar} portNo_2: int;
  var {:pointer} Tmp_364: int;
  var {:pointer} Tmp_365: int;
  var {:scalar} thisPassServiced: int;
  var {:pointer} extension_15: int;
  var {:pointer} Tmp_366: int;
  var {:scalar} servicedAnInterrupt: int;
  var {:dopa} {:scalar} dataError: int;
  var {:scalar} Tmp_367: int;
  var {:pointer} Context_1: int;
  var vslice_dummy_var_56: int;
  var vslice_dummy_var_57: int;
  var vslice_dummy_var_58: int;
  var vslice_dummy_var_59: int;
  var vslice_dummy_var_60: int;
  var vslice_dummy_var_61: int;
  var vslice_dummy_var_1214: int;
  var vslice_dummy_var_1215: int;
  var vslice_dummy_var_1216: int;
  var vslice_dummy_var_1217: int;

  anon0:
    call {:si_unique_call 425} modemStatus := __HAVOC_malloc(4);
    call {:si_unique_call 426} dataError := __HAVOC_malloc(4);
    Context_1 := actual_Context_1;
    call {:si_unique_call 427} Tmp_344 := __HAVOC_malloc(512);
    call {:si_unique_call 428} Tmp_346 := __HAVOC_malloc(16);
    call {:si_unique_call 429} Tmp_350 := __HAVOC_malloc(16);
    call {:si_unique_call 430} Tmp_356 := __HAVOC_malloc(16);
    call {:si_unique_call 431} Tmp_358 := __HAVOC_malloc(16);
    call {:si_unique_call 432} Tmp_359 := __HAVOC_malloc(16);
    call {:si_unique_call 433} Tmp_360 := __HAVOC_malloc(16);
    call {:si_unique_call 434} Tmp_362 := __HAVOC_malloc(16);
    call {:si_unique_call 435} Tmp_364 := __HAVOC_malloc(16);
    call {:si_unique_call 436} Tmp_365 := __HAVOC_malloc(16);
    call {:si_unique_call 437} Tmp_366 := __HAVOC_malloc(16);
    servicedAnInterrupt := 0;
    firstInterruptEntry := Context_1;
    goto anon149_Then, anon149_Else;

  anon149_Else:
    call {:si_unique_call 438} sdv_92 := sdv_IsListEmpty(0);
    goto anon115_Then, anon115_Else;

  anon115_Else:
    assume {:partition} sdv_92 != 0;
    Tmp_330 := servicedAnInterrupt;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon115_Then:
    assume {:partition} sdv_92 == 0;
    goto L26;

  L26:
    call {:si_unique_call 439} Tmp_331, Tmp_332, Tmp_333, Tmp_335, Tmp_336, Tmp_337, boardNo, ack, irpSp_3, Tmp_338, interruptEntry, dispatch, Tmp_339, Tmp_340, Tmp_341, globalData, cisrsw, change, Tmp_342, Tmp_343, port_1, Tmp_344, Tmp_345, ip, Tmp_346, Tmp_347, Tmp_348, sdv_96, Tmp_349, Tmp_350, Tmp_351, Tmp_352, temp, Tmp_353, Tmp_355, Tmp_356, Tmp_357, Tmp_358, Tmp_359, Tmp_360, Tmp_361, Tmp_362, portNo_2, Tmp_364, Tmp_365, thisPassServiced, extension_15, Tmp_366, servicedAnInterrupt, Tmp_367, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61 := MoxaISR_loop_L26(modemStatus, Tmp_331, Tmp_332, Tmp_333, Tmp_335, Tmp_336, Tmp_337, boardNo, ack, irpSp_3, Tmp_338, firstInterruptEntry, interruptEntry, dispatch, Tmp_339, Tmp_340, Tmp_341, globalData, cisrsw, change, Tmp_342, Tmp_343, port_1, Tmp_344, Tmp_345, ip, Tmp_346, Tmp_347, Tmp_348, sdv_96, Tmp_349, Tmp_350, Tmp_351, Tmp_352, temp, Tmp_353, Tmp_355, Tmp_356, Tmp_357, Tmp_358, Tmp_359, Tmp_360, Tmp_361, Tmp_362, portNo_2, Tmp_364, Tmp_365, thisPassServiced, extension_15, Tmp_366, servicedAnInterrupt, dataError, Tmp_367, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61);
    goto L26_last;

  L26_last:
    thisPassServiced := 0;
    assume {:nonnull} firstInterruptEntry != 0;
    assume firstInterruptEntry > 0;
    havoc interruptEntry;
    goto L30;

  L30:
    call {:si_unique_call 440} Tmp_331, Tmp_332, Tmp_333, Tmp_335, Tmp_336, Tmp_337, boardNo, ack, irpSp_3, Tmp_338, interruptEntry, dispatch, Tmp_339, Tmp_340, Tmp_341, globalData, cisrsw, change, Tmp_342, Tmp_343, port_1, Tmp_344, Tmp_345, ip, Tmp_346, Tmp_347, Tmp_348, sdv_96, Tmp_349, Tmp_350, Tmp_351, Tmp_352, temp, Tmp_353, Tmp_355, Tmp_356, Tmp_357, Tmp_358, Tmp_359, Tmp_360, Tmp_361, Tmp_362, portNo_2, Tmp_364, Tmp_365, thisPassServiced, extension_15, Tmp_366, servicedAnInterrupt, Tmp_367, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61 := MoxaISR_loop_L30(modemStatus, Tmp_331, Tmp_332, Tmp_333, Tmp_335, Tmp_336, Tmp_337, boardNo, ack, irpSp_3, Tmp_338, interruptEntry, dispatch, Tmp_339, Tmp_340, Tmp_341, globalData, cisrsw, change, Tmp_342, Tmp_343, port_1, Tmp_344, Tmp_345, ip, Tmp_346, Tmp_347, Tmp_348, sdv_96, Tmp_349, Tmp_350, Tmp_351, Tmp_352, temp, Tmp_353, Tmp_355, Tmp_356, Tmp_357, Tmp_358, Tmp_359, Tmp_360, Tmp_361, Tmp_362, portNo_2, Tmp_364, Tmp_365, thisPassServiced, extension_15, Tmp_366, servicedAnInterrupt, dataError, Tmp_367, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61);
    goto L30_last;

  L30_last:
    call {:si_unique_call 453} sdv_96 := sdv_containing_record(interruptEntry, 8);
    cisrsw := sdv_96;
    goto anon150_Then, anon150_Else;

  anon150_Else:
    assume {:partition} cisrsw != 0;
    assume {:nonnull} cisrsw != 0;
    assume cisrsw > 0;
    dispatch := Dispatch__MOXA_CISR_SW(cisrsw);
    assume {:nonnull} dispatch != 0;
    assume dispatch > 0;
    havoc globalData;
    assume {:nonnull} dispatch != 0;
    assume dispatch > 0;
    havoc boardNo;
    goto anon151_Then, anon151_Else;

  anon151_Else:
    assume {:partition} globalData != 0;
    goto anon116_Then, anon116_Else;

  anon116_Else:
    assume {:partition} 0 <= boardNo;
    Tmp_355 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_366;
    assume {:nonnull} Tmp_366 != 0;
    assume Tmp_366 > 0;
    goto anon152_Then, anon152_Else;

  anon152_Else:
    Tmp_331 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_346;
    assume {:nonnull} Tmp_346 != 0;
    assume Tmp_346 > 0;
    call {:si_unique_call 441} ack := corral_nondet();
    ack := BOR(ack, 4);
    Tmp_343 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_356;
    assume {:nonnull} Tmp_356 != 0;
    assume Tmp_356 > 0;
    goto L43;

  L43:
    Tmp_345 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_365;
    assume {:nonnull} Tmp_365 != 0;
    assume Tmp_365 > 0;
    goto anon153_Then, anon153_Else;

  anon153_Else:
    assume {:partition} Mem_T.INT4[Tmp_365 + Tmp_345 * 4] == 1;
    Tmp_367 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_360;
    assume {:nonnull} Tmp_360 != 0;
    assume Tmp_360 > 0;
    havoc Tmp_353;
    assume {:nonnull} Tmp_353 != 0;
    assume Tmp_353 > 0;
    goto anon154_Then, anon154_Else;

  anon154_Else:
    assume {:partition} Mem_T.INT4[Tmp_353] == 255;
    Tmp_342 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_358;
    assume {:nonnull} Tmp_358 != 0;
    assume Tmp_358 > 0;
    havoc Tmp_339;
    assume {:nonnull} Tmp_339 != 0;
    assume Tmp_339 > 0;
    goto anon155_Then, anon155_Else;

  anon155_Else:
    assume {:partition} Mem_T.INT4[Tmp_339] != 0;
    Tmp_349 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_359;
    assume {:nonnull} Tmp_359 != 0;
    assume Tmp_359 > 0;
    havoc Tmp_348;
    assume {:nonnull} Tmp_348 != 0;
    assume Tmp_348 > 0;
    goto anon156_Then, anon156_Else;

  anon156_Else:
    assume {:partition} Mem_T.INT4[Tmp_348] == 128;
    goto L57;

  L57:
    servicedAnInterrupt := 1;
    thisPassServiced := 1;
    Tmp_357 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_364;
    assume {:nonnull} Tmp_364 != 0;
    assume Tmp_364 > 0;
    havoc ip;
    port_1 := 0;
    goto L62;

  L62:
    call {:si_unique_call 442} Tmp_332, Tmp_333, Tmp_336, Tmp_337, irpSp_3, Tmp_338, Tmp_341, change, port_1, Tmp_344, Tmp_347, Tmp_351, Tmp_352, temp, Tmp_361, Tmp_362, portNo_2, extension_15, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61 := MoxaISR_loop_L62(modemStatus, Tmp_332, Tmp_333, Tmp_336, Tmp_337, boardNo, irpSp_3, Tmp_338, Tmp_341, globalData, change, port_1, Tmp_344, ip, Tmp_347, Tmp_351, Tmp_352, temp, Tmp_361, Tmp_362, portNo_2, extension_15, dataError, vslice_dummy_var_56, vslice_dummy_var_57, vslice_dummy_var_58, vslice_dummy_var_59, vslice_dummy_var_60, vslice_dummy_var_61);
    goto L62_last;

  L62_last:
    Tmp_352 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_362;
    assume {:nonnull} Tmp_362 != 0;
    assume Tmp_362 > 0;
    goto anon157_Then, anon157_Else;

  anon157_Else:
    assume {:partition} Mem_T.INT4[Tmp_362 + Tmp_352 * 4] > port_1;
    portNo_2 := boardNo * 32 + port_1;
    Tmp_333 := portNo_2;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_344;
    assume {:nonnull} Tmp_344 != 0;
    assume Tmp_344 > 0;
    havoc extension_15;
    goto anon158_Then, anon158_Else;

  anon158_Else:
    assume {:partition} extension_15 == 0;
    goto L70;

  L70:
    port_1 := port_1 + 1;
    goto L70_dummy;

  L70_dummy:
    assume false;
    return;

  anon158_Then:
    assume {:partition} extension_15 != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_337;
    assume {:nonnull} ip != 0;
    assume ip > 0;
    temp := Mem_T.INT4[ip + Tmp_337 * 4];
    goto anon159_Then, anon159_Else;

  anon159_Else:
    assume {:partition} temp != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_347;
    assume {:nonnull} ip != 0;
    assume ip > 0;
    Mem_T.INT4[ip + Tmp_347 * 4] := 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon160_Then, anon160_Else;

  anon160_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon117_Then, anon117_Else;

  anon117_Else:
    goto anon118_Then, anon118_Else;

  anon118_Else:
    assume {:partition} BAND(temp, 514) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon120_Then, anon120_Else;

  anon120_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon121_Then, anon121_Else;

  anon121_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 443} vslice_dummy_var_60 := MoxaInsertQueueDpc#1(IsrOutDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon168_Then, anon168_Else;

  anon168_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  L76:
    goto anon119_Then, anon119_Else;

  anon119_Else:
    assume {:partition} BAND(temp, 256) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon123_Then, anon123_Else;

  anon123_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon124_Then, anon124_Else;

  anon124_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 444} vslice_dummy_var_59 := MoxaInsertQueueDpc#1(IsrInDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon167_Then, anon167_Else;

  anon167_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  L93:
    goto anon122_Then, anon122_Else;

  anon122_Else:
    assume {:partition} BAND(temp, 1) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon126_Then, anon126_Else;

  anon126_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L100;

  L100:
    goto anon125_Then, anon125_Else;

  anon125_Else:
    assume {:partition} BAND(temp, 32) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon128_Then, anon128_Else;

  anon128_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L103;

  L103:
    goto anon127_Then, anon127_Else;

  anon127_Else:
    assume {:partition} BAND(temp, 64) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon130_Then, anon130_Else;

  anon130_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L106;

  L106:
    goto anon129_Then, anon129_Else;

  anon129_Else:
    assume {:partition} BAND(temp, 8) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon161_Then, anon161_Else;

  anon161_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L112;

  L112:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon132_Then, anon132_Else;

  anon132_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 445} vslice_dummy_var_56 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon162_Then, anon162_Else;

  anon162_Else:
    assume {:partition} yogi_error != 1;
    goto L109;

  L109:
    goto anon131_Then, anon131_Else;

  anon131_Else:
    assume {:partition} BAND(temp, 16) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc vslice_dummy_var_1214;
    call {:si_unique_call 446} MoxaFuncGetLineStatus(vslice_dummy_var_1214, modemStatus);
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon134_Then, anon134_Else;

  anon134_Else:
    call {:si_unique_call 447} change := corral_nondet();
    goto anon163_Then, anon163_Else;

  anon163_Else:
    assume {:partition} BAND(change, 1) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon136_Then, anon136_Else;

  anon136_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L127;

  L127:
    goto anon135_Then, anon135_Else;

  anon135_Else:
    assume {:partition} BAND(change, 2) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon138_Then, anon138_Else;

  anon138_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L130;

  L130:
    goto anon137_Then, anon137_Else;

  anon137_Else:
    assume {:partition} BAND(change, 8) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon139_Then, anon139_Else;

  anon139_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L123;

  L123:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} modemStatus != 0;
    assume modemStatus > 0;
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(extension_15)] := Mem_T.INT4[modemStatus];
    goto L117;

  L117:
    goto anon133_Then, anon133_Else;

  anon133_Else:
    assume {:partition} BAND(temp, 4) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc vslice_dummy_var_1215;
    call {:si_unique_call 448} MoxaFuncGetDataError(vslice_dummy_var_1215, dataError);
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    goto anon141_Then, anon141_Else;

  anon141_Else:
    assume {:partition} BAND(Mem_T.INT4[dataError], 8) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L141;

  L141:
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    goto anon142_Then, anon142_Else;

  anon142_Else:
    assume {:partition} BAND(Mem_T.INT4[dataError], 4) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L143;

  L143:
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    goto anon143_Then, anon143_Else;

  anon143_Else:
    assume {:partition} BAND(Mem_T.INT4[dataError], 16) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L145;

  L145:
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    goto anon144_Then, anon144_Else;

  anon144_Else:
    assume {:partition} BAND(Mem_T.INT4[dataError], 2) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L147;

  L147:
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon164_Then, anon164_Else;

  anon164_Else:
    assume {:nonnull} dataError != 0;
    assume dataError > 0;
    goto anon146_Then, anon146_Else;

  anon146_Else:
    assume {:partition} BAND(Mem_T.INT4[dataError], 22) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto L150;

  L150:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon145_Then, anon145_Else;

  anon145_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 449} vslice_dummy_var_57 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon165_Then, anon165_Else;

  anon165_Else:
    assume {:partition} yogi_error != 1;
    goto L135;

  L135:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon140_Then, anon140_Else;

  anon140_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    goto anon147_Then, anon147_Else;

  anon147_Else:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_336;
    assume {:nonnull} Tmp_336 != 0;
    assume Tmp_336 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc vslice_dummy_var_1216;
    Mem_T.INT4[Tmp_336] := vslice_dummy_var_1216;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_332;
    assume {:nonnull} Tmp_332 != 0;
    assume Tmp_332 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 450} vslice_dummy_var_58 := MoxaInsertQueueDpc#1(CommWaitDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon166_Then, anon166_Else;

  anon166_Else:
    assume {:partition} yogi_error != 1;
    goto L70;

  anon166_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon147_Then:
    goto L70;

  anon140_Then:
    goto L70;

  anon165_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon145_Then:
    goto L135;

  anon146_Then:
    assume {:partition} BAND(Mem_T.INT4[dataError], 22) == 0;
    goto L150;

  anon164_Then:
    goto L150;

  anon144_Then:
    assume {:partition} BAND(Mem_T.INT4[dataError], 2) == 0;
    goto L147;

  anon143_Then:
    assume {:partition} BAND(Mem_T.INT4[dataError], 16) == 0;
    goto L145;

  anon142_Then:
    assume {:partition} BAND(Mem_T.INT4[dataError], 4) == 0;
    goto L143;

  anon141_Then:
    assume {:partition} BAND(Mem_T.INT4[dataError], 8) == 0;
    goto L141;

  anon133_Then:
    assume {:partition} BAND(temp, 4) == 0;
    goto L135;

  anon139_Then:
    goto L123;

  anon137_Then:
    assume {:partition} BAND(change, 8) == 0;
    goto L123;

  anon138_Then:
    goto L130;

  anon135_Then:
    assume {:partition} BAND(change, 2) == 0;
    goto L130;

  anon136_Then:
    goto L127;

  anon163_Then:
    assume {:partition} BAND(change, 1) == 0;
    goto L127;

  anon134_Then:
    goto L123;

  anon131_Then:
    assume {:partition} BAND(temp, 16) == 0;
    goto L117;

  anon162_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon132_Then:
    goto L109;

  anon161_Then:
    goto L112;

  anon129_Then:
    assume {:partition} BAND(temp, 8) == 0;
    goto L109;

  anon130_Then:
    goto L106;

  anon127_Then:
    assume {:partition} BAND(temp, 64) == 0;
    goto L106;

  anon128_Then:
    goto L103;

  anon125_Then:
    assume {:partition} BAND(temp, 32) == 0;
    goto L103;

  anon126_Then:
    goto L100;

  anon122_Then:
    assume {:partition} BAND(temp, 1) == 0;
    goto L100;

  anon167_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon124_Then:
    goto L93;

  anon123_Then:
    goto L93;

  anon119_Then:
    assume {:partition} BAND(temp, 256) == 0;
    goto L93;

  anon168_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon121_Then:
    goto L76;

  anon120_Then:
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_341;
    assume {:nonnull} Tmp_341 != 0;
    assume Tmp_341 > 0;
    goto anon169_Then, anon169_Else;

  anon169_Else:
    assume {:partition} BAND(Mem_T.INT4[Tmp_341], 514) != 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_338;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_351;
    assume {:nonnull} Tmp_338 != 0;
    assume Tmp_338 > 0;
    assume {:nonnull} Tmp_351 != 0;
    assume Tmp_351 > 0;
    Mem_T.INT4[Tmp_338] := BAND(Mem_T.INT4[Tmp_351], BNOT(BOR(2, 512)));
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc vslice_dummy_var_1217;
    call {:si_unique_call 451} irpSp_3 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1217);
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    havoc Tmp_361;
    assume {:nonnull} Tmp_361 != 0;
    assume Tmp_361 > 0;
    assume {:nonnull} irpSp_3 != 0;
    assume irpSp_3 > 0;
    assume {:nonnull} extension_15 != 0;
    assume extension_15 > 0;
    call {:si_unique_call 452} vslice_dummy_var_61 := MoxaInsertQueueDpc#1(CompleteWriteDpc__MOXA_DEVICE_EXTENSION(extension_15), 0, 0, extension_15);
    goto anon170_Then, anon170_Else;

  anon170_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  anon170_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon169_Then:
    assume {:partition} BAND(Mem_T.INT4[Tmp_341], 514) == 0;
    goto L76;

  anon118_Then:
    assume {:partition} BAND(temp, 514) == 0;
    goto L76;

  anon117_Then:
    goto L70;

  anon160_Then:
    goto L70;

  anon159_Then:
    assume {:partition} temp == 0;
    goto L70;

  anon157_Then:
    assume {:partition} port_1 >= Mem_T.INT4[Tmp_362 + Tmp_352 * 4];
    Tmp_340 := boardNo;
    assume {:nonnull} globalData != 0;
    assume globalData > 0;
    havoc Tmp_350;
    assume {:nonnull} Tmp_350 != 0;
    assume Tmp_350 > 0;
    havoc Tmp_335;
    assume {:nonnull} Tmp_335 != 0;
    assume Tmp_335 > 0;
    Mem_T.INT4[Tmp_335] := 0;
    goto L54;

  L54:
    assume {:nonnull} interruptEntry != 0;
    assume interruptEntry > 0;
    havoc interruptEntry;
    servicedAnInterrupt := BOR(servicedAnInterrupt, thisPassServiced);
    goto anon171_Then, anon171_Else;

  anon171_Else:
    goto anon148_Then, anon148_Else;

  anon148_Else:
    assume {:partition} thisPassServiced != 1;
    Tmp_330 := servicedAnInterrupt;
    goto L1;

  anon148_Then:
    assume {:partition} thisPassServiced == 1;
    goto anon148_Then_dummy;

  anon148_Then_dummy:
    assume false;
    return;

  anon171_Then:
    goto anon171_Then_dummy;

  anon171_Then_dummy:
    assume false;
    return;

  anon156_Then:
    assume {:partition} Mem_T.INT4[Tmp_348] != 128;
    goto L54;

  anon155_Then:
    assume {:partition} Mem_T.INT4[Tmp_339] == 0;
    goto L57;

  anon154_Then:
    assume {:partition} Mem_T.INT4[Tmp_353] != 255;
    goto L54;

  anon153_Then:
    assume {:partition} Mem_T.INT4[Tmp_365 + Tmp_345 * 4] != 1;
    goto L54;

  anon152_Then:
    goto L43;

  anon116_Then:
    assume {:partition} boardNo < 0;
    goto L40;

  L40:
    Tmp_330 := servicedAnInterrupt;
    goto L1;

  anon151_Then:
    assume {:partition} globalData == 0;
    goto L40;

  anon150_Then:
    assume {:partition} cisrsw == 0;
    Tmp_330 := servicedAnInterrupt;
    goto L1;

  anon149_Then:
    Tmp_330 := servicedAnInterrupt;
    goto L1;
}



procedure {:origName "MoxaWrite"} MoxaWrite(actual_DeviceObject_5: int, actual_Irp_5: int) returns (Tmp_368: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, Mem_T.CancelIrql__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaWrite"} MoxaWrite(actual_DeviceObject_5: int, actual_Irp_5: int) returns (Tmp_368: int)
{
  var {:scalar} sdv_103: int;
  var {:pointer} sdv_104: int;
  var {:scalar} status_6: int;
  var {:pointer} extension_16: int;
  var {:pointer} DeviceObject_5: int;
  var {:pointer} Irp_5: int;

  anon0:
    DeviceObject_5 := actual_DeviceObject_5;
    Irp_5 := actual_Irp_5;
    assume {:nonnull} DeviceObject_5 != 0;
    assume DeviceObject_5 > 0;
    havoc extension_16;
    assume {:nonnull} extension_16 != 0;
    assume extension_16 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    goto L8;

  L8:
    assume {:nonnull} Irp_5 != 0;
    assume Irp_5 > 0;
    assume {:nonnull} Irp_5 != 0;
    assume Irp_5 > 0;
    call {:si_unique_call 454} sdv_IoCompleteRequest(0, 0);
    Tmp_368 := -1073741536;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon22_Then:
    assume {:nonnull} extension_16 != 0;
    assume extension_16 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} extension_16 != 0;
    assume extension_16 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    call {:si_unique_call 455} status_6 := MoxaIRPPrologue(Irp_5, extension_16);
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} yogi_error != 1;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:partition} status_6 != 0;
    call {:si_unique_call 456} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 457} MoxaIRPEpilogue(extension_16);
    Tmp_368 := status_6;
    goto L1;

  anon19_Then:
    assume {:partition} status_6 == 0;
    call {:si_unique_call 458} sdv_103 := MoxaCompleteIfError(DeviceObject_5, Irp_5);
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:partition} sdv_103 != 0;
    Tmp_368 := -1073741536;
    goto L1;

  anon20_Then:
    assume {:partition} sdv_103 == 0;
    assume {:nonnull} Irp_5 != 0;
    assume Irp_5 > 0;
    call {:si_unique_call 459} sdv_104 := sdv_IoGetCurrentIrpStackLocation(Irp_5);
    assume {:nonnull} sdv_104 != 0;
    assume sdv_104 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:nonnull} extension_16 != 0;
    assume extension_16 > 0;
    call {:si_unique_call 460} Tmp_368 := MoxaStartOrQueue(extension_16, Irp_5, WriteQueue__MOXA_DEVICE_EXTENSION(extension_16), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_16), li2bplFunctionConstant318);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon24_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon21_Then:
    assume {:nonnull} Irp_5 != 0;
    assume Irp_5 > 0;
    call {:si_unique_call 461} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 462} MoxaIRPEpilogue(extension_16);
    Tmp_368 := 0;
    goto L1;

  anon23_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon18_Then:
    goto L8;

  anon17_Then:
    goto L8;
}



procedure {:origName "MoxaCompleteWrite"} MoxaCompleteWrite(actual_Dpc_6: int, actual_DeferredContext_6: int, actual_SystemContext1_6: int, actual_SystemContext2_6: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCompleteWrite"} MoxaCompleteWrite(actual_Dpc_6: int, actual_DeferredContext_6: int, actual_SystemContext1_6: int, actual_SystemContext2_6: int)
{
  var {:pointer} Tmp_370: int;
  var {:scalar} oldIrql_9: int;
  var {:pointer} extension_17: int;
  var {:pointer} Dpc_6: int;
  var {:pointer} DeferredContext_6: int;
  var vslice_dummy_var_62: int;

  anon0:
    call {:si_unique_call 463} vslice_dummy_var_62 := __HAVOC_malloc(4);
    Dpc_6 := actual_Dpc_6;
    DeferredContext_6 := actual_DeferredContext_6;
    extension_17 := DeferredContext_6;
    call {:si_unique_call 464} Tmp_370 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_370 != 0;
    assume Tmp_370 > 0;
    Mem_T.INT4[Tmp_370] := oldIrql_9;
    call {:si_unique_call 465} IoAcquireCancelSpinLock(Tmp_370);
    assume {:nonnull} Tmp_370 != 0;
    assume Tmp_370 > 0;
    oldIrql_9 := Mem_T.INT4[Tmp_370];
    assume {:nonnull} extension_17 != 0;
    assume extension_17 > 0;
    call {:si_unique_call 466} MoxaTryToCompleteCurrent(extension_17, 0, oldIrql_9, 0, CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_17), WriteQueue__MOXA_DEVICE_EXTENSION(extension_17), 0, WriteRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_17), li2bplFunctionConstant318, li2bplFunctionConstant323);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 467} MoxaDpcEpilogue(extension_17, Dpc_6);
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaCancelCurrentWrite"} MoxaCancelCurrentWrite(actual_DeviceObject_6: int, actual_Irp_6: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_5) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCancelCurrentWrite"} MoxaCancelCurrentWrite(actual_DeviceObject_6: int, actual_Irp_6: int)
{
  var {:pointer} extension_18: int;
  var {:pointer} DeviceObject_6: int;
  var {:pointer} Irp_6: int;
  var vslice_dummy_var_63: int;

  anon0:
    call {:si_unique_call 468} vslice_dummy_var_63 := __HAVOC_malloc(4);
    DeviceObject_6 := actual_DeviceObject_6;
    Irp_6 := actual_Irp_6;
    assume {:nonnull} DeviceObject_6 != 0;
    assume DeviceObject_6 > 0;
    havoc extension_18;
    assume {:nonnull} Irp_6 != 0;
    assume Irp_6 > 0;
    assume {:nonnull} extension_18 != 0;
    assume extension_18 > 0;
    call {:si_unique_call 469} MoxaTryToCompleteCurrent(extension_18, li2bplFunctionConstant325, Mem_T.CancelIrql__IRP[CancelIrql__IRP(Irp_6)], -1073741536, CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_18), WriteQueue__MOXA_DEVICE_EXTENSION(extension_18), 0, WriteRequestTotalTimer__MOXA_DEVICE_EXTENSION(extension_18), li2bplFunctionConstant318, li2bplFunctionConstant323);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init10"} _sdv_init10();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init10"} _sdv_init10()
{
  var vslice_dummy_var_64: int;

  anon0:
    call {:si_unique_call 470} vslice_dummy_var_64 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaProcessEmptyTransmit"} MoxaProcessEmptyTransmit(actual_Context_2: int) returns (Tmp_376: int);
  modifies Mem_T.INT4, alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaProcessEmptyTransmit"} MoxaProcessEmptyTransmit(actual_Context_2: int) returns (Tmp_376: int)
{
  var {:scalar} sdv_106: int;
  var {:pointer} Tmp_377: int;
  var {:pointer} Tmp_379: int;
  var {:pointer} extension_19: int;
  var {:pointer} Context_2: int;
  var vslice_dummy_var_65: int;
  var vslice_dummy_var_1218: int;

  anon0:
    Context_2 := actual_Context_2;
    extension_19 := Context_2;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    call {:si_unique_call 471} sdv_106 := sdv_IsListEmpty(0);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} sdv_106 != 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    havoc Tmp_379;
    assume {:nonnull} Tmp_379 != 0;
    assume Tmp_379 > 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    havoc vslice_dummy_var_1218;
    Mem_T.INT4[Tmp_379] := vslice_dummy_var_1218;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    havoc Tmp_377;
    assume {:nonnull} Tmp_377 != 0;
    assume Tmp_377 > 0;
    assume {:nonnull} extension_19 != 0;
    assume extension_19 > 0;
    call {:si_unique_call 472} vslice_dummy_var_65 := MoxaInsertQueueDpc#1(CommWaitDpc__MOXA_DEVICE_EXTENSION(extension_19), 0, 0, extension_19);
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} yogi_error != 1;
    goto L6;

  L6:
    Tmp_376 := 0;
    goto LM2;

  LM2:
    return;

  anon15_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon14_Then:
    goto L6;

  anon12_Then:
    assume {:partition} sdv_106 == 0;
    goto L6;

  anon11_Then:
    goto L6;

  anon13_Then:
    goto L6;
}



procedure {:origName "MoxaGetNextWrite"} MoxaGetNextWrite(actual_CurrentOpIrp: int, actual_QueueToProcess: int, actual_NewIrp: int, actual_CompleteCurrent: int, actual_Extension_6: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetNextWrite"} MoxaGetNextWrite(actual_CurrentOpIrp: int, actual_QueueToProcess: int, actual_NewIrp: int, actual_CompleteCurrent: int, actual_Extension_6: int)
{
  var {:pointer} sdv_108: int;
  var {:pointer} Tmp_380: int;
  var {:pointer} sdv_109: int;
  var {:pointer} Tmp_382: int;
  var {:scalar} oldIrql_10: int;
  var {:pointer} extension_20: int;
  var {:pointer} CurrentOpIrp: int;
  var {:pointer} QueueToProcess: int;
  var {:pointer} NewIrp: int;
  var {:scalar} CompleteCurrent: int;
  var vslice_dummy_var_66: int;
  var vslice_dummy_var_67: int;
  var vslice_dummy_var_1219: int;

  anon0:
    call {:si_unique_call 473} vslice_dummy_var_66 := __HAVOC_malloc(4);
    CurrentOpIrp := actual_CurrentOpIrp;
    QueueToProcess := actual_QueueToProcess;
    NewIrp := actual_NewIrp;
    CompleteCurrent := actual_CompleteCurrent;
    call {:si_unique_call 474} sdv_108 := sdv_containing_record(QueueToProcess, 228);
    extension_20 := sdv_108;
    goto L8;

  L8:
    call {:si_unique_call 475} Tmp_380, sdv_109 := MoxaGetNextWrite_loop_L8(Tmp_380, sdv_109, extension_20, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);
    goto L8_last;

  L8_last:
    call {:si_unique_call 481} MoxaGetNextIrp(CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent, extension_20);
    assume {:nonnull} NewIrp != 0;
    assume NewIrp > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    call {:si_unique_call 476} Tmp_382 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_382 != 0;
    assume Tmp_382 > 0;
    Mem_T.INT4[Tmp_382] := oldIrql_10;
    call {:si_unique_call 477} IoAcquireCancelSpinLock(Tmp_382);
    assume {:nonnull} Tmp_382 != 0;
    assume Tmp_382 > 0;
    oldIrql_10 := Mem_T.INT4[Tmp_382];
    call {:si_unique_call 478} vslice_dummy_var_67 := KeSynchronizeExecution(0, li2bplFunctionConstant324, 0);
    call {:si_unique_call 479} IoReleaseCancelSpinLock(oldIrql_10);
    goto L1;

  L1:
    return;

  anon5_Then:
    assume {:nonnull} NewIrp != 0;
    assume NewIrp > 0;
    havoc vslice_dummy_var_1219;
    call {:si_unique_call 480} sdv_109 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1219);
    assume {:nonnull} sdv_109 != 0;
    assume sdv_109 > 0;
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:nonnull} NewIrp != 0;
    assume NewIrp > 0;
    havoc Tmp_380;
    assume {:nonnull} Tmp_380 != 0;
    assume Tmp_380 > 0;
    goto anon6_Else_dummy;

  anon6_Else_dummy:
    assume false;
    return;

  anon6_Then:
    goto L1;
}



procedure {:origName "MoxaStartWrite"} MoxaStartWrite(actual_Extension_7: int) returns (Tmp_383: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartWrite"} MoxaStartWrite(actual_Extension_7: int) returns (Tmp_383: int)
{
  var {:pointer} structPtr888totalTime: int;
  var {:pointer} SD4: int;
  var {:pointer} Tmp_384: int;
  var {:pointer} sdv_112: int;
  var {:pointer} irpSp_4: int;
  var {:scalar} totalTime: int;
  var {:scalar} setFirstStatus_1: int;
  var {:pointer} Tmp_385: int;
  var {:pointer} newIrp_1: int;
  var {:pointer} Tmp_386: int;
  var {:scalar} timeouts: int;
  var {:pointer} Tmp_387: int;
  var {:pointer} Tmp_388: int;
  var {:pointer} sdv_116: int;
  var {:pointer} sdv_118: int;
  var {:pointer} Tmp_389: int;
  var {:scalar} oldIrql_11: int;
  var {:pointer} sdv_119: int;
  var {:scalar} sdv_4: int;
  var {:scalar} useATimer: int;
  var {:pointer} Tmp_390: int;
  var {:scalar} controlIrql_1: int;
  var {:pointer} Tmp_391: int;
  var {:pointer} Tmp_392: int;
  var {:pointer} Tmp_393: int;
  var {:pointer} Tmp_396: int;
  var {:scalar} firstStatus_1: int;
  var {:pointer} Extension_7: int;
  var boogieTmp: int;
  var vslice_dummy_var_68: int;
  var vslice_dummy_var_69: int;
  var vslice_dummy_var_70: int;
  var vslice_dummy_var_71: int;
  var vslice_dummy_var_72: int;
  var vslice_dummy_var_73: int;
  var vslice_dummy_var_74: int;
  var vslice_dummy_var_1220: int;
  var vslice_dummy_var_1221: int;
  var vslice_dummy_var_1222: int;
  var vslice_dummy_var_1223: int;
  var vslice_dummy_var_1224: int;
  var vslice_dummy_var_1225: int;
  var vslice_dummy_var_1226: int;
  var vslice_dummy_var_1227: int;
  var vslice_dummy_var_1228: int;

  anon0:
    call {:si_unique_call 482} totalTime := __HAVOC_malloc(20);
    call {:si_unique_call 483} newIrp_1 := __HAVOC_malloc(4);
    call {:si_unique_call 484} vslice_dummy_var_68 := __HAVOC_malloc(20);
    call {:si_unique_call 485} timeouts := __HAVOC_malloc(20);
    call {:si_unique_call 486} vslice_dummy_var_69 := __HAVOC_malloc(20);
    call {:si_unique_call 487} sdv_4 := __HAVOC_malloc(20);
    call {:si_unique_call 488} vslice_dummy_var_70 := __HAVOC_malloc(20);
    Extension_7 := actual_Extension_7;
    setFirstStatus_1 := 0;
    goto L13;

  L13:
    call {:si_unique_call 489} structPtr888totalTime, SD4, irpSp_4, setFirstStatus_1, Tmp_385, Tmp_386, Tmp_387, Tmp_388, sdv_116, Tmp_389, oldIrql_11, sdv_119, useATimer, controlIrql_1, Tmp_391, Tmp_392, Tmp_393, Tmp_396, firstStatus_1, boogieTmp, vslice_dummy_var_71, vslice_dummy_var_72 := MoxaStartWrite_loop_L13(structPtr888totalTime, SD4, irpSp_4, totalTime, setFirstStatus_1, Tmp_385, newIrp_1, Tmp_386, timeouts, Tmp_387, Tmp_388, sdv_116, Tmp_389, oldIrql_11, sdv_119, sdv_4, useATimer, controlIrql_1, Tmp_391, Tmp_392, Tmp_393, Tmp_396, firstStatus_1, Extension_7, boogieTmp, vslice_dummy_var_71, vslice_dummy_var_72);
    goto L13_last;

  L13_last:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1228;
    call {:si_unique_call 532} irpSp_4 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1228);
    assume {:nonnull} irpSp_4 != 0;
    assume irpSp_4 > 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    call {:si_unique_call 490} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := controlIrql_1;
    call {:si_unique_call 491} sdv_KeAcquireSpinLock(0, Tmp_386);
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    controlIrql_1 := Mem_T.INT4[Tmp_386];
    call {:si_unique_call 492} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := oldIrql_11;
    call {:si_unique_call 493} IoAcquireCancelSpinLock(Tmp_386);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    oldIrql_11 := Mem_T.INT4[Tmp_386];
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_389;
    assume {:nonnull} Tmp_389 != 0;
    assume Tmp_389 > 0;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_391;
    assume {:nonnull} Tmp_391 != 0;
    assume Tmp_391 > 0;
    call {:si_unique_call 494} IoReleaseCancelSpinLock(oldIrql_11);
    call {:si_unique_call 495} sdv_KeReleaseSpinLock(0, controlIrql_1);
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} setFirstStatus_1 != 0;
    goto L40;

  L40:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    call {:si_unique_call 496} MoxaGetNextWrite(CurrentWriteIrp__MOXA_DEVICE_EXTENSION(Extension_7), WriteQueue__MOXA_DEVICE_EXTENSION(Extension_7), newIrp_1, 1, Extension_7);
    assume {:nonnull} newIrp_1 != 0;
    assume newIrp_1 > 0;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    goto L44;

  L44:
    Tmp_383 := firstStatus_1;
    goto LM2;

  LM2:
    return;

  anon37_Then:
    goto anon37_Then_dummy;

  anon37_Then_dummy:
    assume false;
    return;

  anon36_Then:
    assume {:partition} setFirstStatus_1 == 0;
    firstStatus_1 := -1073741536;
    setFirstStatus_1 := 1;
    goto L40;

  anon46_Then:
    call {:si_unique_call 497} vslice_dummy_var_71 := KeSynchronizeExecution(0, li2bplFunctionConstant319, 0);
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} setFirstStatus_1 != 0;
    goto L48;

  L48:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_392;
    assume {:nonnull} Tmp_392 != 0;
    assume Tmp_392 > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_393;
    assume {:nonnull} Tmp_393 != 0;
    assume Tmp_393 > 0;
    call {:si_unique_call 498} IoReleaseCancelSpinLock(oldIrql_11);
    call {:si_unique_call 499} sdv_KeReleaseSpinLock(0, controlIrql_1);
    goto L40;

  anon38_Then:
    assume {:partition} setFirstStatus_1 == 0;
    setFirstStatus_1 := 1;
    firstStatus_1 := 0;
    goto L48;

  anon45_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon35_Then:
    call {:si_unique_call 500} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := oldIrql_11;
    call {:si_unique_call 501} IoAcquireCancelSpinLock(Tmp_386);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    oldIrql_11 := Mem_T.INT4[Tmp_386];
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1220;
    call {:si_unique_call 502} sdv_119 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1220);
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} sdv_119 != 0;
    assume sdv_119 > 0;
    call {:si_unique_call 503} IoReleaseCancelSpinLock(oldIrql_11);
    useATimer := 0;
    call {:si_unique_call 504} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := controlIrql_1;
    call {:si_unique_call 505} sdv_KeAcquireSpinLock(0, Tmp_386);
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    controlIrql_1 := Mem_T.INT4[Tmp_386];
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    call {:si_unique_call 506} sdv_KeReleaseSpinLock(0, controlIrql_1);
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    goto L74;

  L74:
    useATimer := 1;
    assume {:nonnull} irpSp_4 != 0;
    assume irpSp_4 > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    havoc vslice_dummy_var_1221;
    havoc vslice_dummy_var_1222;
    call {:si_unique_call 507} structPtr888totalTime := RtlEnlargedUnsignedMultiply(vslice_dummy_var_1221, vslice_dummy_var_1222);
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    havoc vslice_dummy_var_1223;
    call {:si_unique_call 508} SD4 := RtlConvertUlongToLargeInteger(vslice_dummy_var_1223);
    assume {:nonnull} SD4 != 0;
    assume SD4 > 0;
    assume {:nonnull} sdv_4 != 0;
    assume sdv_4 > 0;
    assume {:nonnull} SD4 != 0;
    assume SD4 > 0;
    assume {:nonnull} sdv_4 != 0;
    assume sdv_4 > 0;
    assume {:nonnull} SD4 != 0;
    assume SD4 > 0;
    assume {:nonnull} sdv_4 != 0;
    assume sdv_4 > 0;
    assume {:nonnull} SD4 != 0;
    assume SD4 > 0;
    assume {:nonnull} sdv_4 != 0;
    assume sdv_4 > 0;
    assume {:nonnull} SD4 != 0;
    assume SD4 > 0;
    assume {:nonnull} sdv_4 != 0;
    assume sdv_4 > 0;
    call {:si_unique_call 509} structPtr888totalTime := RtlLargeIntegerAdd(totalTime, sdv_4);
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} structPtr888totalTime != 0;
    assume structPtr888totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    call {:si_unique_call 510} boogieTmp := corral_nondet();
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    call {:si_unique_call 511} boogieTmp := corral_nondet();
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    call {:si_unique_call 512} boogieTmp := corral_nondet();
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    call {:si_unique_call 513} boogieTmp := corral_nondet();
    assume {:nonnull} totalTime != 0;
    assume totalTime > 0;
    call {:si_unique_call 514} boogieTmp := corral_nondet();
    goto L90;

  L90:
    call {:si_unique_call 515} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := controlIrql_1;
    call {:si_unique_call 516} sdv_KeAcquireSpinLock(0, Tmp_386);
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    controlIrql_1 := Mem_T.INT4[Tmp_386];
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1224;
    call {:si_unique_call 517} sdv_116 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1224);
    assume {:nonnull} sdv_116 != 0;
    assume sdv_116 > 0;
    call {:si_unique_call 518} Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    Mem_T.INT4[Tmp_386] := oldIrql_11;
    call {:si_unique_call 519} IoAcquireCancelSpinLock(Tmp_386);
    assume {:nonnull} Tmp_386 != 0;
    assume Tmp_386 > 0;
    oldIrql_11 := Mem_T.INT4[Tmp_386];
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_396;
    assume {:nonnull} Tmp_396 != 0;
    assume Tmp_396 > 0;
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_388;
    assume {:nonnull} Tmp_388 != 0;
    assume Tmp_388 > 0;
    call {:si_unique_call 520} IoReleaseCancelSpinLock(oldIrql_11);
    call {:si_unique_call 521} sdv_KeReleaseSpinLock(0, controlIrql_1);
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} setFirstStatus_1 == 0;
    firstStatus_1 := -1073741536;
    setFirstStatus_1 := 1;
    goto L40;

  anon41_Then:
    assume {:partition} setFirstStatus_1 != 0;
    goto L40;

  anon49_Then:
    call {:si_unique_call 522} vslice_dummy_var_72 := KeSynchronizeExecution(0, li2bplFunctionConstant320, 0);
    goto anon42_Then, anon42_Else;

  anon42_Else:
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} setFirstStatus_1 != 0;
    goto L118;

  L118:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_387;
    assume {:nonnull} Tmp_387 != 0;
    assume Tmp_387 > 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc Tmp_385;
    assume {:nonnull} Tmp_385 != 0;
    assume Tmp_385 > 0;
    assume {:nonnull} irpSp_4 != 0;
    assume irpSp_4 > 0;
    call {:si_unique_call 523} IoReleaseCancelSpinLock(oldIrql_11);
    call {:si_unique_call 524} sdv_KeReleaseSpinLock(0, controlIrql_1);
    goto L40;

  anon44_Then:
    assume {:partition} setFirstStatus_1 == 0;
    setFirstStatus_1 := 1;
    firstStatus_1 := 0;
    goto L118;

  anon42_Then:
    goto anon43_Then, anon43_Else;

  anon43_Else:
    assume {:partition} setFirstStatus_1 != 0;
    goto L130;

  L130:
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1225;
    call {:si_unique_call 525} vslice_dummy_var_73 := sdv_IoSetCancelRoutine(vslice_dummy_var_1225, li2bplFunctionConstant321);
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1226;
    call {:si_unique_call 526} sdv_118 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1226);
    assume {:nonnull} sdv_118 != 0;
    assume sdv_118 > 0;
    Tmp_390 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_118)));
    assume {:nonnull} sdv_118 != 0;
    assume sdv_118 > 0;
    assume {:nonnull} Tmp_390 != 0;
    assume Tmp_390 > 0;
    assume {:nonnull} sdv_118 != 0;
    assume sdv_118 > 0;
    goto anon50_Then, anon50_Else;

  anon50_Else:
    assume {:partition} useATimer != 0;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    call {:si_unique_call 527} vslice_dummy_var_74 := MoxaSetTimer(WriteRequestTotalTimer__MOXA_DEVICE_EXTENSION(Extension_7), totalTime, TotalWriteTimeoutDpc__MOXA_DEVICE_EXTENSION(Extension_7), Extension_7);
    goto anon51_Then, anon51_Else;

  anon51_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Extension_7 != 0;
    assume Extension_7 > 0;
    havoc vslice_dummy_var_1227;
    call {:si_unique_call 528} sdv_112 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1227);
    assume {:nonnull} sdv_112 != 0;
    assume sdv_112 > 0;
    Tmp_384 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_112)));
    assume {:nonnull} sdv_112 != 0;
    assume sdv_112 > 0;
    assume {:nonnull} Tmp_384 != 0;
    assume Tmp_384 > 0;
    assume {:nonnull} sdv_112 != 0;
    assume sdv_112 > 0;
    goto L138;

  L138:
    call {:si_unique_call 529} IoReleaseCancelSpinLock(oldIrql_11);
    call {:si_unique_call 530} sdv_KeReleaseSpinLock(0, controlIrql_1);
    goto L44;

  anon51_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon50_Then:
    assume {:partition} useATimer == 0;
    goto L138;

  anon43_Then:
    assume {:partition} setFirstStatus_1 == 0;
    call {:si_unique_call 531} sdv_IoMarkIrpPending(0);
    setFirstStatus_1 := 1;
    firstStatus_1 := 259;
    goto L130;

  anon48_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon39_Then:
    assume {:nonnull} timeouts != 0;
    assume timeouts > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    goto L90;

  anon40_Then:
    goto L74;

  anon47_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaSetInformationFile"} MoxaSetInformationFile(actual_DeviceObject_7: int, actual_Irp_7: int) returns (Tmp_397: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetInformationFile"} MoxaSetInformationFile(actual_DeviceObject_7: int, actual_Irp_7: int) returns (Tmp_397: int)
{
  var {:scalar} sdv_124: int;
  var {:pointer} sdv_125: int;
  var {:pointer} Extension_8: int;
  var {:pointer} sdv_126: int;
  var {:scalar} status_7: int;
  var {:pointer} DeviceObject_7: int;
  var {:pointer} Irp_7: int;
  var vslice_dummy_var_1229: int;
  var vslice_dummy_var_1230: int;
  var vslice_dummy_var_1231: int;

  anon0:
    DeviceObject_7 := actual_DeviceObject_7;
    Irp_7 := actual_Irp_7;
    assume {:nonnull} DeviceObject_7 != 0;
    assume DeviceObject_7 > 0;
    havoc Extension_8;
    assume {:nonnull} Extension_8 != 0;
    assume Extension_8 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    status_7 := -1073741536;
    assume {:nonnull} Irp_7 != 0;
    assume Irp_7 > 0;
    assume {:nonnull} Irp_7 != 0;
    assume Irp_7 > 0;
    call {:si_unique_call 533} sdv_IoCompleteRequest(0, 0);
    Tmp_397 := status_7;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon17_Then:
    assume {:nonnull} DeviceObject_7 != 0;
    assume DeviceObject_7 > 0;
    havoc vslice_dummy_var_1229;
    call {:si_unique_call 534} status_7 := MoxaIRPPrologue(Irp_7, vslice_dummy_var_1229);
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} yogi_error != 1;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} status_7 != 0;
    call {:si_unique_call 535} sdv_IoCompleteRequest(0, 0);
    assume {:nonnull} DeviceObject_7 != 0;
    assume DeviceObject_7 > 0;
    havoc vslice_dummy_var_1230;
    call {:si_unique_call 536} MoxaIRPEpilogue(vslice_dummy_var_1230);
    Tmp_397 := status_7;
    goto L1;

  anon13_Then:
    assume {:partition} status_7 == 0;
    call {:si_unique_call 537} sdv_124 := MoxaCompleteIfError(DeviceObject_7, Irp_7);
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} sdv_124 != 0;
    Tmp_397 := -1073741536;
    goto L1;

  anon14_Then:
    assume {:partition} sdv_124 == 0;
    assume {:nonnull} Irp_7 != 0;
    assume Irp_7 > 0;
    call {:si_unique_call 538} sdv_125 := sdv_IoGetCurrentIrpStackLocation(Irp_7);
    assume {:nonnull} sdv_125 != 0;
    assume sdv_125 > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto L39;

  L39:
    status_7 := 0;
    goto L40;

  L40:
    assume {:nonnull} Irp_7 != 0;
    assume Irp_7 > 0;
    call {:si_unique_call 539} sdv_IoCompleteRequest(0, 0);
    assume {:nonnull} DeviceObject_7 != 0;
    assume DeviceObject_7 > 0;
    havoc vslice_dummy_var_1231;
    call {:si_unique_call 540} MoxaIRPEpilogue(vslice_dummy_var_1231);
    Tmp_397 := status_7;
    goto L1;

  anon15_Then:
    call {:si_unique_call 541} sdv_126 := sdv_IoGetCurrentIrpStackLocation(Irp_7);
    assume {:nonnull} sdv_126 != 0;
    assume sdv_126 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    status_7 := -1073741811;
    goto L40;

  anon16_Then:
    goto L39;

  anon18_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init15"} _sdv_init15();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init15"} _sdv_init15()
{
  var vslice_dummy_var_75: int;

  anon0:
    call {:si_unique_call 542} vslice_dummy_var_75 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaQueryInformationFile"} MoxaQueryInformationFile(actual_DeviceObject_8: int, actual_Irp_8: int) returns (Tmp_401: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaQueryInformationFile"} MoxaQueryInformationFile(actual_DeviceObject_8: int, actual_Irp_8: int) returns (Tmp_401: int)
{
  var {:pointer} Tmp_402: int;
  var {:pointer} irpSp_5: int;
  var {:pointer} buf: int;
  var {:scalar} sdv_128: int;
  var {:pointer} Extension_9: int;
  var {:scalar} status_8: int;
  var {:pointer} DeviceObject_8: int;
  var {:pointer} Irp_8: int;
  var vslice_dummy_var_1232: int;
  var vslice_dummy_var_1233: int;
  var vslice_dummy_var_1234: int;

  anon0:
    DeviceObject_8 := actual_DeviceObject_8;
    Irp_8 := actual_Irp_8;
    assume {:nonnull} DeviceObject_8 != 0;
    assume DeviceObject_8 > 0;
    havoc Extension_9;
    assume {:nonnull} Extension_9 != 0;
    assume Extension_9 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    status_8 := -1073741536;
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    call {:si_unique_call 543} sdv_IoCompleteRequest(0, 0);
    Tmp_401 := status_8;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon16_Then:
    assume {:nonnull} DeviceObject_8 != 0;
    assume DeviceObject_8 > 0;
    havoc vslice_dummy_var_1232;
    call {:si_unique_call 544} status_8 := MoxaIRPPrologue(Irp_8, vslice_dummy_var_1232);
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} yogi_error != 1;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} status_8 != 0;
    call {:si_unique_call 545} sdv_IoCompleteRequest(0, 0);
    assume {:nonnull} DeviceObject_8 != 0;
    assume DeviceObject_8 > 0;
    havoc vslice_dummy_var_1233;
    call {:si_unique_call 546} MoxaIRPEpilogue(vslice_dummy_var_1233);
    Tmp_401 := status_8;
    goto L1;

  anon13_Then:
    assume {:partition} status_8 == 0;
    call {:si_unique_call 547} sdv_128 := MoxaCompleteIfError(DeviceObject_8, Irp_8);
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} sdv_128 != 0;
    Tmp_401 := -1073741536;
    goto L1;

  anon14_Then:
    assume {:partition} sdv_128 == 0;
    call {:si_unique_call 548} irpSp_5 := sdv_IoGetCurrentIrpStackLocation(Irp_8);
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    status_8 := 0;
    assume {:nonnull} irpSp_5 != 0;
    assume irpSp_5 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    havoc buf;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} buf != 0;
    assume buf > 0;
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    goto L48;

  L48:
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    call {:si_unique_call 549} sdv_IoCompleteRequest(0, 0);
    assume {:nonnull} DeviceObject_8 != 0;
    assume DeviceObject_8 > 0;
    havoc vslice_dummy_var_1234;
    call {:si_unique_call 550} MoxaIRPEpilogue(vslice_dummy_var_1234);
    Tmp_401 := status_8;
    goto L1;

  anon18_Then:
    assume {:nonnull} irpSp_5 != 0;
    assume irpSp_5 > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    havoc Tmp_402;
    assume {:nonnull} Tmp_402 != 0;
    assume Tmp_402 > 0;
    assume {:nonnull} Irp_8 != 0;
    assume Irp_8 > 0;
    goto L48;

  anon15_Then:
    status_8 := -1073741811;
    goto L48;

  anon17_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaSetPowerD0"} MoxaSetPowerD0(actual_PDevObj: int, actual_PIrp: int) returns (Tmp_404: int);
  modifies alloc, Mem_T.INT4, Mem_T.MinorFunction__IO_STACK_LOCATION, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetPowerD0"} MoxaSetPowerD0(actual_PDevObj: int, actual_PIrp: int) returns (Tmp_404: int)
{
  var {:pointer} SD3: int;
  var {:pointer} pDevExt: int;
  var {:dopa} {:scalar} boardReady: int;
  var {:pointer} Tmp_406: int;
  var {:scalar} Tmp_407: int;
  var {:pointer} pIrpStack: int;
  var {:scalar} sdv_3: int;
  var {:scalar} IoStatusBlock: int;
  var {:pointer} Tmp_408: int;
  var {:scalar} status_9: int;
  var {:scalar} event: int;
  var {:scalar} Tmp_409: int;
  var {:pointer} PDevObj: int;
  var {:pointer} PIrp: int;
  var vslice_dummy_var_76: int;
  var vslice_dummy_var_1235: int;
  var vslice_dummy_var_1236: int;

  anon0:
    call {:si_unique_call 551} boardReady := __HAVOC_malloc(4);
    call {:si_unique_call 552} sdv_3 := __HAVOC_malloc(8);
    call {:si_unique_call 553} IoStatusBlock := __HAVOC_malloc(12);
    call {:si_unique_call 554} event := __HAVOC_malloc(124);
    PDevObj := actual_PDevObj;
    PIrp := actual_PIrp;
    call {:si_unique_call 555} Tmp_406 := __HAVOC_malloc(16);
    call {:si_unique_call 556} Tmp_408 := __HAVOC_malloc(16);
    assume {:nonnull} PDevObj != 0;
    assume PDevObj > 0;
    havoc pDevExt;
    call {:si_unique_call 557} pIrpStack := sdv_IoGetCurrentIrpStackLocation(PIrp);
    assume {:nonnull} boardReady != 0;
    assume boardReady > 0;
    Mem_T.INT4[boardReady] := 0;
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    call {:si_unique_call 558} KeClearEvent(PowerD0Event__MOXA_DEVICE_EXTENSION(pDevExt));
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 559} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp);
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    call {:si_unique_call 560} sdv_IoSetCompletionRoutine(PIrp, li2bplFunctionConstant232, PowerD0Event__MOXA_DEVICE_EXTENSION(pDevExt), 1, 1, 1);
    call {:si_unique_call 561} status_9 := PoCallDriver(0, PIrp);
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} status_9 == 259;
    call {:si_unique_call 562} vslice_dummy_var_76 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L33;

  L33:
    assume {:nonnull} PIrp != 0;
    assume PIrp > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    call {:si_unique_call 563} KeInitializeEvent(event, 0, 0);
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    havoc vslice_dummy_var_1235;
    call {:si_unique_call 564} status_9 := MoxaIoSyncIoctlEx(1777788, 1, vslice_dummy_var_1235, event, IoStatusBlock, 0, 0, boardReady, 4);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} yogi_error != 1;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:partition} status_9 >= 0;
    assume {:nonnull} boardReady != 0;
    assume boardReady > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} Mem_T.INT4[boardReady] != 0;
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    call {:si_unique_call 565} MoxaRestoreDeviceState(pDevExt);
    goto L48;

  L48:
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    havoc Tmp_407;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_406;
    assume {:nonnull} Tmp_406 != 0;
    assume Tmp_406 > 0;
    Mem_T.INT4[Tmp_406 + Tmp_407 * 4] := 1;
    goto L53;

  L53:
    assume {:nonnull} pIrpStack != 0;
    assume pIrpStack > 0;
    havoc vslice_dummy_var_1236;
    call {:si_unique_call 566} SD3 := PoSetPowerState(0, Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack)))], vslice_dummy_var_1236);
    assume {:nonnull} SD3 != 0;
    assume SD3 > 0;
    assume {:nonnull} sdv_3 != 0;
    assume sdv_3 > 0;
    assume {:nonnull} SD3 != 0;
    assume SD3 > 0;
    assume {:nonnull} sdv_3 != 0;
    assume sdv_3 > 0;
    call {:si_unique_call 567} PoStartNextPowerIrp(0);
    call {:si_unique_call 568} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 569} MoxaIRPEpilogue(pDevExt);
    Tmp_404 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon22_Then:
    goto L48;

  anon21_Then:
    assume {:partition} Mem_T.INT4[boardReady] == 0;
    goto L45;

  L45:
    assume {:nonnull} pDevExt != 0;
    assume pDevExt > 0;
    havoc Tmp_409;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_408;
    assume {:nonnull} Tmp_408 != 0;
    assume Tmp_408 > 0;
    Mem_T.INT4[Tmp_408 + Tmp_409 * 4] := 0;
    goto L53;

  anon20_Then:
    assume {:partition} 0 > status_9;
    goto L45;

  anon24_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon19_Then:
    call {:si_unique_call 570} PoStartNextPowerIrp(0);
    call {:si_unique_call 571} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 572} MoxaIRPEpilogue(pDevExt);
    assume {:nonnull} PIrp != 0;
    assume PIrp > 0;
    havoc Tmp_404;
    goto L1;

  anon17_Then:
    assume {:partition} status_9 != 259;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} status_9 < 0;
    assume {:nonnull} PIrp != 0;
    assume PIrp > 0;
    call {:si_unique_call 573} PoStartNextPowerIrp(0);
    call {:si_unique_call 574} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 575} MoxaIRPEpilogue(pDevExt);
    Tmp_404 := status_9;
    goto L1;

  anon18_Then:
    assume {:partition} 0 <= status_9;
    goto L33;

  anon23_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaRestoreDeviceState"} MoxaRestoreDeviceState(actual_PDevExt: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaRestoreDeviceState"} MoxaRestoreDeviceState(actual_PDevExt: int)
{
  var {:scalar} i_1: int;
  var {:pointer} pDevState: int;
  var {:pointer} Tmp_410: int;
  var {:scalar} Tmp_411: int;
  var {:scalar} Tmp_412: int;
  var {:scalar} Tmp_413: int;
  var {:pointer} Tmp_414: int;
  var {:scalar} Tmp_415: int;
  var {:pointer} Tmp_418: int;
  var {:dopa} {:scalar} divisor_2: int;
  var {:scalar} Tmp_419: int;
  var {:pointer} Tmp_421: int;
  var {:scalar} arg_2: int;
  var {:scalar} Tmp_422: int;
  var {:scalar} Tmp_423: int;
  var {:pointer} Tmp_424: int;
  var {:pointer} PDevExt: int;
  var boogieTmp: int;
  var vslice_dummy_var_77: int;
  var vslice_dummy_var_78: int;
  var vslice_dummy_var_79: int;
  var vslice_dummy_var_1237: int;
  var vslice_dummy_var_1238: int;
  var vslice_dummy_var_1239: int;
  var vslice_dummy_var_1240: int;
  var vslice_dummy_var_1241: int;
  var vslice_dummy_var_1242: int;
  var vslice_dummy_var_1243: int;
  var vslice_dummy_var_1244: int;
  var vslice_dummy_var_1245: int;
  var vslice_dummy_var_1246: int;
  var vslice_dummy_var_1247: int;
  var vslice_dummy_var_1248: int;
  var vslice_dummy_var_1249: int;
  var vslice_dummy_var_1250: int;
  var vslice_dummy_var_1251: int;
  var vslice_dummy_var_1252: int;
  var vslice_dummy_var_1253: int;
  var vslice_dummy_var_1254: int;

  anon0:
    call {:si_unique_call 576} vslice_dummy_var_77 := __HAVOC_malloc(4);
    call {:si_unique_call 577} divisor_2 := __HAVOC_malloc(4);
    PDevExt := actual_PDevExt;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    pDevState := DeviceState__MOXA_DEVICE_EXTENSION(PDevExt);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_410;
    assume {:nonnull} Tmp_410 != 0;
    assume Tmp_410 > 0;
    assume {:nonnull} pDevState != 0;
    assume pDevState > 0;
    havoc vslice_dummy_var_1237;
    Mem_T.INT4[Tmp_410] := vslice_dummy_var_1237;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_413;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1238;
    call {:si_unique_call 578} MoxaFunc1(vslice_dummy_var_1238, 41, Tmp_413);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1239;
    havoc vslice_dummy_var_1240;
    call {:si_unique_call 579} vslice_dummy_var_78 := MoxaGetDivisorFromBaud(vslice_dummy_var_1239, vslice_dummy_var_1240, divisor_2);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    assume {:nonnull} divisor_2 != 0;
    assume divisor_2 > 0;
    havoc vslice_dummy_var_1241;
    call {:si_unique_call 580} MoxaFunc1(vslice_dummy_var_1241, 36, Mem_T.INT4[divisor_2]);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_421;
    assume {:nonnull} Tmp_421 != 0;
    assume Tmp_421 > 0;
    havoc vslice_dummy_var_1242;
    Mem_T.INT4[Tmp_421] := vslice_dummy_var_1242;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1243;
    havoc vslice_dummy_var_1244;
    call {:si_unique_call 581} MoxaFunc1(vslice_dummy_var_1243, 55, vslice_dummy_var_1244);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1245;
    havoc vslice_dummy_var_1246;
    call {:si_unique_call 582} MoxaFunc1(vslice_dummy_var_1245, 54, vslice_dummy_var_1246);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1247;
    call {:si_unique_call 583} MoxaFunc1(vslice_dummy_var_1247, 20, 1028);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_412;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1248;
    call {:si_unique_call 584} MoxaFunc1(vslice_dummy_var_1248, 39, Tmp_412);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_415;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1249;
    call {:si_unique_call 585} MoxaFunc1(vslice_dummy_var_1249, 40, Tmp_415);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_419;
    havoc arg_2;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1250;
    call {:si_unique_call 586} MoxaFunc1(vslice_dummy_var_1250, 7, arg_2);
    i_1 := 0;
    goto L44;

  L44:
    call {:si_unique_call 587} i_1, Tmp_411, Tmp_414, Tmp_418, Tmp_423 := MoxaRestoreDeviceState_loop_L44(i_1, Tmp_411, Tmp_414, Tmp_418, Tmp_423, PDevExt);
    goto L44_last;

  L44_last:
    assume {:CounterLoop 6} {:Counter "i_1"} true;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} 6 > i_1;
    Tmp_423 := i_1;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_418;
    Tmp_411 := i_1;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    Tmp_414 := SpecialChars__MOXA_DEVICE_EXTENSION(PDevExt);
    assume {:nonnull} Tmp_414 != 0;
    assume Tmp_414 > 0;
    assume {:nonnull} Tmp_418 != 0;
    assume Tmp_418 > 0;
    Mem_T.INT4[Tmp_418 + Tmp_423 * 4] := Mem_T.INT4[Tmp_414 + Tmp_411 * 4];
    i_1 := i_1 + 1;
    goto anon15_Else_dummy;

  anon15_Else_dummy:
    assume false;
    return;

  anon15_Then:
    assume {:partition} i_1 >= 6;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_424;
    assume {:nonnull} Tmp_424 != 0;
    assume Tmp_424 > 0;
    Mem_T.INT4[Tmp_424] := 44;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1251;
    call {:si_unique_call 588} vslice_dummy_var_79 := MoxaWaitFinish1(vslice_dummy_var_1251);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    call {:si_unique_call 589} boogieTmp := corral_nondet();
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(PDevExt)] := boogieTmp;
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    arg_2 := 1;
    goto L53;

  L53:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    arg_2 := BOR(arg_2, 2);
    goto L55;

  L55:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    arg_2 := BOR(arg_2, 4);
    goto L57;

  L57:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    arg_2 := BOR(arg_2, 8);
    goto L59;

  L59:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1252;
    call {:si_unique_call 590} MoxaFunc1(vslice_dummy_var_1252, 21, arg_2);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc Tmp_422;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1253;
    call {:si_unique_call 591} MoxaFunc1(vslice_dummy_var_1253, 53, 1028);
    goto L64;

  L64:
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    havoc vslice_dummy_var_1254;
    call {:si_unique_call 592} MoxaFunc1(vslice_dummy_var_1254, 2, 1028);
    assume {:nonnull} PDevExt != 0;
    assume PDevExt > 0;
    goto L1;

  L1:
    return;

  anon21_Then:
    goto L64;

  anon18_Then:
    goto L59;

  anon17_Then:
    goto L57;

  anon16_Then:
    goto L55;

  anon20_Then:
    goto L53;

  anon19_Then:
    goto L1;
}



procedure {:origName "MoxaSaveDeviceState"} MoxaSaveDeviceState(actual_PDevExt_1: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSaveDeviceState"} MoxaSaveDeviceState(actual_PDevExt_1: int)
{
  var {:pointer} pDevState_1: int;
  var {:scalar} oldIrql_12: int;
  var {:pointer} Tmp_426: int;
  var {:pointer} Tmp_427: int;
  var {:pointer} PDevExt_1: int;
  var vslice_dummy_var_80: int;
  var vslice_dummy_var_1255: int;
  var vslice_dummy_var_1256: int;
  var vslice_dummy_var_1257: int;

  anon0:
    call {:si_unique_call 593} vslice_dummy_var_80 := __HAVOC_malloc(4);
    PDevExt_1 := actual_PDevExt_1;
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    pDevState_1 := DeviceState__MOXA_DEVICE_EXTENSION(PDevExt_1);
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    havoc vslice_dummy_var_1255;
    call {:si_unique_call 594} MoxaKillAllReadsOrWrites(vslice_dummy_var_1255, WriteQueue__MOXA_DEVICE_EXTENSION(PDevExt_1), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(PDevExt_1));
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    havoc vslice_dummy_var_1256;
    call {:si_unique_call 595} MoxaKillAllReadsOrWrites(vslice_dummy_var_1256, ReadQueue__MOXA_DEVICE_EXTENSION(PDevExt_1), CurrentReadIrp__MOXA_DEVICE_EXTENSION(PDevExt_1));
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 596} Tmp_426 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_426 != 0;
    assume Tmp_426 > 0;
    Mem_T.INT4[Tmp_426] := oldIrql_12;
    call {:si_unique_call 597} sdv_KeAcquireSpinLock(0, Tmp_426);
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_426 != 0;
    assume Tmp_426 > 0;
    oldIrql_12 := Mem_T.INT4[Tmp_426];
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    havoc vslice_dummy_var_1257;
    call {:si_unique_call 598} MoxaFunc(vslice_dummy_var_1257, 10, 2);
    call {:si_unique_call 599} sdv_KeReleaseSpinLock(0, oldIrql_12);
    assume {:nonnull} PDevExt_1 != 0;
    assume PDevExt_1 > 0;
    havoc Tmp_427;
    assume {:nonnull} Tmp_427 != 0;
    assume Tmp_427 > 0;
    assume {:nonnull} pDevState_1 != 0;
    assume pDevState_1 > 0;
    goto LM2;

  LM2:
    return;

  anon9_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon8_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon7_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaGotoPowerState"} MoxaGotoPowerState(actual_PDevObj_1: int, actual_PDevExt_2: int, actual_DevPowerState: int) returns (Tmp_428: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_428 == 0 || Tmp_428 == -1073741584 || Tmp_428 == 259 || Tmp_428 == -1073741670;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGotoPowerState"} MoxaGotoPowerState(actual_PDevObj_1: int, actual_PDevExt_2: int, actual_DevPowerState: int) returns (Tmp_428: int)
{
  var {:scalar} powerState: int;
  var {:scalar} gotoPowEvent: int;
  var {:scalar} status_10: int;
  var {:pointer} PDevObj_1: int;
  var {:scalar} DevPowerState: int;
  var vslice_dummy_var_81: int;

  anon0:
    call {:si_unique_call 600} powerState := __HAVOC_malloc(8);
    call {:si_unique_call 601} gotoPowEvent := __HAVOC_malloc(124);
    PDevObj_1 := actual_PDevObj_1;
    DevPowerState := actual_DevPowerState;
    assume {:nonnull} powerState != 0;
    assume powerState > 0;
    call {:si_unique_call 602} KeInitializeEvent(gotoPowEvent, 1, 0);
    call {:si_unique_call 603} status_10 := PoRequestPowerIrp(PDevObj_1, 2, powerState, li2bplFunctionConstant253, gotoPowEvent, 0);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} status_10 == 259;
    call {:si_unique_call 604} vslice_dummy_var_81 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    status_10 := 0;
    goto L15;

  L15:
    Tmp_428 := status_10;
    return;

  anon3_Then:
    assume {:partition} status_10 != 259;
    goto L15;
}



procedure {:origName "_sdv_init6"} _sdv_init6();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init6"} _sdv_init6()
{
  var vslice_dummy_var_82: int;

  anon0:
    call {:si_unique_call 605} vslice_dummy_var_82 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaPowerDispatch"} MoxaPowerDispatch(actual_PDevObj_2: int, actual_PIrp_1: int) returns (Tmp_432: int);
  modifies alloc, Mem_T.INT4, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaPowerDispatch"} MoxaPowerDispatch(actual_PDevObj_2: int, actual_PIrp_1: int) returns (Tmp_432: int)
{
  var {:pointer} SD2: int;
  var {:pointer} pDevExt_1: int;
  var {:scalar} powerState_1: int;
  var {:scalar} sdv_2: int;
  var {:pointer} pIrpStack_1: int;
  var {:pointer} pLowerDevObj: int;
  var {:scalar} status_11: int;
  var {:pointer} pPdo: int;
  var {:pointer} PDevObj_2: int;
  var {:pointer} PIrp_1: int;
  var vslice_dummy_var_83: int;
  var vslice_dummy_var_1258: int;

  anon0:
    call {:si_unique_call 606} powerState_1 := __HAVOC_malloc(8);
    call {:si_unique_call 607} sdv_2 := __HAVOC_malloc(8);
    PDevObj_2 := actual_PDevObj_2;
    PIrp_1 := actual_PIrp_1;
    assume {:nonnull} PDevObj_2 != 0;
    assume PDevObj_2 > 0;
    havoc pDevExt_1;
    call {:si_unique_call 608} pIrpStack_1 := sdv_IoGetCurrentIrpStackLocation(PIrp_1);
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    havoc pLowerDevObj;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    havoc pPdo;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    call {:si_unique_call 609} PoStartNextPowerIrp(0);
    status_11 := -1073741536;
    assume {:nonnull} PIrp_1 != 0;
    assume PIrp_1 > 0;
    assume {:nonnull} PIrp_1 != 0;
    assume PIrp_1 > 0;
    call {:si_unique_call 610} sdv_IoCompleteRequest(0, 0);
    Tmp_432 := status_11;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon81_Then:
    call {:si_unique_call 611} status_11 := MoxaIRPPrologue(PIrp_1, pDevExt_1);
    goto anon82_Then, anon82_Else;

  anon82_Else:
    assume {:partition} yogi_error != 1;
    goto anon57_Then, anon57_Else;

  anon57_Else:
    assume {:partition} status_11 != 0;
    call {:si_unique_call 612} PoStartNextPowerIrp(0);
    call {:si_unique_call 613} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 614} MoxaIRPEpilogue(pDevExt_1);
    Tmp_432 := status_11;
    goto L1;

  anon57_Then:
    assume {:partition} status_11 == 0;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon58_Then, anon58_Else;

  anon58_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] != 0;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon69_Then, anon69_Else;

  anon69_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] != 1;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon68_Then, anon68_Else;

  anon68_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] != 2;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon67_Then, anon67_Else;

  anon67_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] == 3;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    goto anon60_Then, anon60_Else;

  anon60_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon61_Then, anon61_Else;

  anon61_Else:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] == 0;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    assume {:nonnull} PIrp_1 != 0;
    assume PIrp_1 > 0;
    assume {:nonnull} PIrp_1 != 0;
    assume PIrp_1 > 0;
    havoc status_11;
    call {:si_unique_call 615} PoStartNextPowerIrp(0);
    call {:si_unique_call 616} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 617} MoxaIRPEpilogue(pDevExt_1);
    Tmp_432 := status_11;
    goto L1;

  anon62_Then:
    goto L50;

  L50:
    assume {:nonnull} PIrp_1 != 0;
    assume PIrp_1 > 0;
    call {:si_unique_call 618} PoStartNextPowerIrp(0);
    call {:si_unique_call 619} sdv_IoSkipCurrentIrpStackLocation(PIrp_1);
    call {:si_unique_call 620} Tmp_432 := MoxaPoCallDriver(pDevExt_1, pLowerDevObj, PIrp_1);
    goto L1;

  anon61_Then:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] != 0;
    goto L50;

  anon60_Then:
    goto L50;

  anon67_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] != 3;
    goto L43;

  L43:
    call {:si_unique_call 621} PoStartNextPowerIrp(0);
    call {:si_unique_call 622} sdv_IoSkipCurrentIrpStackLocation(PIrp_1);
    call {:si_unique_call 623} status_11 := MoxaPoCallDriver(pDevExt_1, pLowerDevObj, PIrp_1);
    Tmp_432 := status_11;
    goto L1;

  anon68_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] == 2;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon59_Then, anon59_Else;

  anon59_Else:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] != 0;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] == 1;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon78_Then, anon78_Else;

  anon78_Else:
    goto L85;

  L85:
    call {:si_unique_call 624} Tmp_432 := MoxaSetPowerD3(PDevObj_2, PIrp_1);
    goto anon84_Then, anon84_Else;

  anon84_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon84_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon78_Then:
    goto L43;

  anon79_Then:
    goto L85;

  anon80_Then:
    goto L85;

  anon64_Then:
    call {:si_unique_call 625} Tmp_432 := MoxaSetPowerD0(PDevObj_2, PIrp_1);
    goto anon83_Then, anon83_Else;

  anon83_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon83_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon63_Then:
    goto L43;

  anon70_Then:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] != 1;
    goto L43;

  anon59_Then:
    assume {:partition} Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))] == 0;
    assume {:nonnull} pDevExt_1 != 0;
    assume pDevExt_1 > 0;
    goto anon65_Then, anon65_Else;

  anon65_Else:
    status_11 := 0;
    goto L43;

  anon65_Then:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon77_Then, anon77_Else;

  anon77_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon76_Then, anon76_Else;

  anon76_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon75_Then, anon75_Else;

  anon75_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon74_Then, anon74_Else;

  anon74_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon73_Then, anon73_Else;

  anon73_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon72_Then, anon72_Else;

  anon72_Else:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    goto anon71_Then, anon71_Else;

  anon71_Else:
    goto L98;

  L98:
    assume {:nonnull} powerState_1 != 0;
    assume powerState_1 > 0;
    goto L100;

  L100:
    assume {:nonnull} pIrpStack_1 != 0;
    assume pIrpStack_1 > 0;
    havoc vslice_dummy_var_1258;
    call {:si_unique_call 626} SD2 := PoSetPowerState(0, Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_1)))], vslice_dummy_var_1258);
    assume {:nonnull} SD2 != 0;
    assume SD2 > 0;
    assume {:nonnull} sdv_2 != 0;
    assume sdv_2 > 0;
    assume {:nonnull} SD2 != 0;
    assume SD2 > 0;
    assume {:nonnull} sdv_2 != 0;
    assume sdv_2 > 0;
    call {:si_unique_call 627} vslice_dummy_var_83 := PoRequestPowerIrp(pPdo, 2, powerState_1, 0, 0, 0);
    goto L43;

  anon71_Then:
    status_11 := 0;
    goto L43;

  anon72_Then:
    goto L98;

  anon73_Then:
    goto L98;

  anon74_Then:
    goto L98;

  anon75_Then:
    goto L98;

  anon76_Then:
    goto L98;

  anon77_Then:
    assume {:nonnull} powerState_1 != 0;
    assume powerState_1 > 0;
    goto L100;

  anon66_Then:
    assume {:nonnull} powerState_1 != 0;
    assume powerState_1 > 0;
    goto L100;

  anon69_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] == 1;
    goto L43;

  anon58_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_1)] == 0;
    goto L43;

  anon82_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaSetPowerD3"} MoxaSetPowerD3(actual_PDevObj_3: int, actual_PIrp_2: int) returns (Tmp_434: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.MinorFunction__IO_STACK_LOCATION, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetPowerD3"} MoxaSetPowerD3(actual_PDevObj_3: int, actual_PIrp_2: int) returns (Tmp_434: int)
{
  var {:pointer} SD1: int;
  var {:pointer} pDevExt_2: int;
  var {:scalar} sdv_1: int;
  var {:pointer} pIrpStack_2: int;
  var {:pointer} PDevObj_3: int;
  var {:pointer} PIrp_2: int;
  var vslice_dummy_var_1259: int;
  var vslice_dummy_var_1260: int;
  var vslice_dummy_var_1261: int;

  anon0:
    call {:si_unique_call 628} sdv_1 := __HAVOC_malloc(8);
    PDevObj_3 := actual_PDevObj_3;
    PIrp_2 := actual_PIrp_2;
    assume {:nonnull} PDevObj_3 != 0;
    assume PDevObj_3 > 0;
    havoc pDevExt_2;
    call {:si_unique_call 629} pIrpStack_2 := sdv_IoGetCurrentIrpStackLocation(PIrp_2);
    assume {:nonnull} pIrpStack_2 != 0;
    assume pIrpStack_2 > 0;
    havoc vslice_dummy_var_1259;
    call {:si_unique_call 630} SD1 := PoSetPowerState(0, Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(pIrpStack_2)))], vslice_dummy_var_1259);
    assume {:nonnull} SD1 != 0;
    assume SD1 > 0;
    assume {:nonnull} sdv_1 != 0;
    assume sdv_1 > 0;
    assume {:nonnull} SD1 != 0;
    assume SD1 > 0;
    assume {:nonnull} sdv_1 != 0;
    assume sdv_1 > 0;
    assume {:nonnull} pDevExt_2 != 0;
    assume pDevExt_2 > 0;
    assume {:nonnull} pDevExt_2 != 0;
    assume pDevExt_2 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:nonnull} pDevExt_2 != 0;
    assume pDevExt_2 > 0;
    call {:si_unique_call 631} MoxaSaveDeviceState(pDevExt_2);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_2 != 0;
    assume pDevExt_2 > 0;
    havoc vslice_dummy_var_1260;
    call {:si_unique_call 632} MoxaFunc1(vslice_dummy_var_1260, 3, 1028);
    goto L17;

  L17:
    assume {:nonnull} PIrp_2 != 0;
    assume PIrp_2 > 0;
    assume {:nonnull} PIrp_2 != 0;
    assume PIrp_2 > 0;
    call {:si_unique_call 633} PoStartNextPowerIrp(0);
    call {:si_unique_call 634} sdv_IoSkipCurrentIrpStackLocation(PIrp_2);
    assume {:nonnull} pDevExt_2 != 0;
    assume pDevExt_2 > 0;
    havoc vslice_dummy_var_1261;
    call {:si_unique_call 635} Tmp_434 := MoxaPoCallDriver(pDevExt_2, vslice_dummy_var_1261, PIrp_2);
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    goto L17;
}



procedure {:origName "MoxaSetupNewHandFlow"} MoxaSetupNewHandFlow(actual_Context_3: int) returns (Tmp_436: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} Tmp_436 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetupNewHandFlow"} MoxaSetupNewHandFlow(actual_Context_3: int) returns (Tmp_436: int)
{
  var {:scalar} Tmp_437: int;
  var {:scalar} Tmp_438: int;
  var {:scalar} Tmp_439: int;
  var {:scalar} Tmp_440: int;
  var {:scalar} Tmp_441: int;
  var {:scalar} Tmp_442: int;
  var {:scalar} Tmp_443: int;
  var {:scalar} Tmp_444: int;
  var {:scalar} Tmp_445: int;
  var {:scalar} New: int;
  var {:scalar} Tmp_446: int;
  var {:scalar} Tmp_447: int;
  var {:scalar} Tmp_448: int;
  var {:scalar} Tmp_449: int;
  var {:pointer} S_3: int;
  var {:pointer} ofs_10: int;
  var {:scalar} Tmp_450: int;
  var {:scalar} Tmp_451: int;
  var {:scalar} Tmp_452: int;
  var {:scalar} flowControl: int;
  var {:pointer} NewHandFlow: int;
  var {:pointer} Extension_10: int;
  var {:scalar} Tmp_453: int;
  var {:scalar} Tmp_454: int;
  var {:scalar} Tmp_455: int;
  var {:scalar} Tmp_456: int;
  var {:scalar} Tmp_457: int;
  var {:scalar} Tmp_458: int;
  var {:scalar} Tmp_459: int;
  var {:scalar} Tmp_460: int;
  var {:scalar} Tmp_461: int;
  var {:scalar} Tmp_462: int;
  var {:pointer} Context_3: int;

  anon0:
    call {:si_unique_call 636} New := __HAVOC_malloc(16);
    Context_3 := actual_Context_3;
    S_3 := Context_3;
    assume {:nonnull} S_3 != 0;
    assume S_3 > 0;
    havoc Extension_10;
    assume {:nonnull} S_3 != 0;
    assume S_3 > 0;
    havoc NewHandFlow;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} NewHandFlow != 0;
    assume NewHandFlow > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} NewHandFlow != 0;
    assume NewHandFlow > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} NewHandFlow != 0;
    assume NewHandFlow > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} NewHandFlow != 0;
    assume NewHandFlow > 0;
    flowControl := 0;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc ofs_10;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_450;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_447;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} Tmp_450 == Tmp_447;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_445;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_448;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:partition} Tmp_445 == Tmp_448;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_459;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_446;
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} Tmp_459 == Tmp_446;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_449;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_457;
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} Tmp_449 == Tmp_457;
    goto L29;

  L29:
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_441;
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} Tmp_441 != 2;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_437;
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:partition} Tmp_437 == 1;
    call {:si_unique_call 637} MoxaFunc(ofs_10, 37, 1);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_458;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_438;
    havoc Mem_T.INT4;
    goto L31;

  L31:
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_439;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_443;
    goto anon43_Then, anon43_Else;

  anon43_Else:
    assume {:partition} Tmp_439 == Tmp_443;
    goto L46;

  L46:
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_451;
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} Tmp_451 != 128;
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_461;
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} Tmp_461 == 64;
    call {:si_unique_call 638} MoxaFunc(ofs_10, 38, 1);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_452;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_455;
    havoc Mem_T.INT4;
    goto L48;

  L48:
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_462;
    call {:si_unique_call 639} MoxaFunc(ofs_10, 39, Tmp_462);
    assume {:nonnull} New != 0;
    assume New > 0;
    havoc Tmp_440;
    call {:si_unique_call 640} MoxaFunc(ofs_10, 40, Tmp_440);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    assume {:nonnull} New != 0;
    assume New > 0;
    Tmp_436 := 0;
    return;

  anon45_Then:
    assume {:partition} Tmp_461 != 64;
    call {:si_unique_call 641} MoxaFunc(ofs_10, 38, 0);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_460;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_454;
    havoc Mem_T.INT4;
    goto L48;

  anon44_Then:
    assume {:partition} Tmp_451 == 128;
    goto L48;

  anon43_Then:
    assume {:partition} Tmp_439 != Tmp_443;
    goto L42;

  L42:
    assume {:nonnull} New != 0;
    assume New > 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    call {:si_unique_call 642} MoxaFunc(ofs_10, 38, 1);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_444;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_453;
    havoc Mem_T.INT4;
    goto L46;

  anon35_Then:
    goto L46;

  anon34_Then:
    goto L42;

  anon42_Then:
    assume {:partition} Tmp_437 != 1;
    call {:si_unique_call 643} MoxaFunc(ofs_10, 37, 0);
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_442;
    assume {:nonnull} Extension_10 != 0;
    assume Extension_10 > 0;
    havoc Tmp_456;
    havoc Mem_T.INT4;
    goto L31;

  anon41_Then:
    assume {:partition} Tmp_441 == 2;
    goto L31;

  anon48_Then:
    assume {:partition} Tmp_449 != Tmp_457;
    goto L16;

  L16:
    assume {:nonnull} New != 0;
    assume New > 0;
    goto anon33_Then, anon33_Else;

  anon33_Else:
    flowControl := BOR(flowControl, 1);
    goto L72;

  L72:
    assume {:nonnull} New != 0;
    assume New > 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    flowControl := BOR(flowControl, 2);
    goto L74;

  L74:
    assume {:nonnull} New != 0;
    assume New > 0;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    flowControl := BOR(flowControl, 4);
    goto L76;

  L76:
    assume {:nonnull} New != 0;
    assume New > 0;
    goto anon38_Then, anon38_Else;

  anon38_Else:
    flowControl := BOR(flowControl, 8);
    goto L78;

  L78:
    call {:si_unique_call 644} MoxaFunc(ofs_10, 21, flowControl);
    goto L29;

  anon38_Then:
    goto L78;

  anon37_Then:
    goto L76;

  anon36_Then:
    goto L74;

  anon33_Then:
    goto L72;

  anon47_Then:
    assume {:partition} Tmp_459 != Tmp_446;
    goto L16;

  anon46_Then:
    assume {:partition} Tmp_445 != Tmp_448;
    goto L16;

  anon40_Then:
    assume {:partition} Tmp_450 != Tmp_447;
    goto L16;

  anon39_Then:
    goto L16;
}



procedure {:origName "_sdv_init14"} _sdv_init14();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init14"} _sdv_init14()
{
  var vslice_dummy_var_84: int;

  anon0:
    call {:si_unique_call 645} vslice_dummy_var_84 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "_sdv_init16"} _sdv_init16();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init16"} _sdv_init16()
{
  var vslice_dummy_var_85: int;

  anon0:
    call {:si_unique_call 646} vslice_dummy_var_85 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaFlush"} MoxaFlush(actual_DeviceObject_9: int, actual_Irp_9: int) returns (Tmp_468: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, Mem_T.CancelIrql__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFlush"} MoxaFlush(actual_DeviceObject_9: int, actual_Irp_9: int) returns (Tmp_468: int)
{
  var {:scalar} sdv_147: int;
  var {:scalar} sdv_148: int;
  var {:pointer} extension_21: int;
  var {:pointer} DeviceObject_9: int;
  var {:pointer} Irp_9: int;

  anon0:
    DeviceObject_9 := actual_DeviceObject_9;
    Irp_9 := actual_Irp_9;
    assume {:nonnull} DeviceObject_9 != 0;
    assume DeviceObject_9 > 0;
    havoc extension_21;
    assume {:nonnull} extension_21 != 0;
    assume extension_21 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    goto L7;

  L7:
    assume {:nonnull} Irp_9 != 0;
    assume Irp_9 > 0;
    assume {:nonnull} Irp_9 != 0;
    assume Irp_9 > 0;
    call {:si_unique_call 647} sdv_IoCompleteRequest(0, 0);
    Tmp_468 := -1073741536;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon16_Then:
    assume {:nonnull} extension_21 != 0;
    assume extension_21 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    call {:si_unique_call 648} sdv_147 := MoxaIRPPrologue(Irp_9, extension_21);
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} yogi_error != 1;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} sdv_147 != 0;
    call {:si_unique_call 649} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 650} MoxaIRPEpilogue(extension_21);
    Tmp_468 := -1073741536;
    goto L1;

  anon14_Then:
    assume {:partition} sdv_147 == 0;
    call {:si_unique_call 651} sdv_148 := MoxaCompleteIfError(DeviceObject_9, Irp_9);
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} sdv_148 != 0;
    Tmp_468 := -1073741536;
    goto L1;

  anon15_Then:
    assume {:partition} sdv_148 == 0;
    assume {:nonnull} Irp_9 != 0;
    assume Irp_9 > 0;
    assume {:nonnull} extension_21 != 0;
    assume extension_21 > 0;
    call {:si_unique_call 652} Tmp_468 := MoxaStartOrQueue(extension_21, Irp_9, WriteQueue__MOXA_DEVICE_EXTENSION(extension_21), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_21), li2bplFunctionConstant406);
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon18_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon17_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon13_Then:
    goto L7;
}



procedure {:origName "MoxaStartFlush"} MoxaStartFlush(actual_Extension_11: int) returns (Tmp_470: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartFlush"} MoxaStartFlush(actual_Extension_11: int) returns (Tmp_470: int)
{
  var {:pointer} newIrp_2: int;
  var {:pointer} Tmp_472: int;
  var {:pointer} Extension_11: int;
  var vslice_dummy_var_86: int;

  anon0:
    call {:si_unique_call 653} newIrp_2 := __HAVOC_malloc(4);
    Extension_11 := actual_Extension_11;
    assume {:nonnull} Extension_11 != 0;
    assume Extension_11 > 0;
    havoc Tmp_472;
    assume {:nonnull} Tmp_472 != 0;
    assume Tmp_472 > 0;
    assume {:nonnull} Extension_11 != 0;
    assume Extension_11 > 0;
    call {:si_unique_call 654} MoxaGetNextWrite(CurrentWriteIrp__MOXA_DEVICE_EXTENSION(Extension_11), WriteQueue__MOXA_DEVICE_EXTENSION(Extension_11), newIrp_2, 1, Extension_11);
    assume {:nonnull} newIrp_2 != 0;
    assume newIrp_2 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    call {:si_unique_call 655} vslice_dummy_var_86 := MoxaStartWrite(Extension_11);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto L9;

  L9:
    Tmp_470 := 0;
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    goto L9;
}



procedure {:origName "MoxaStartPurge"} MoxaStartPurge(actual_Extension_12: int) returns (Tmp_473: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartPurge"} MoxaStartPurge(actual_Extension_12: int) returns (Tmp_473: int)
{
  var {:scalar} oldIrql_13: int;
  var {:pointer} Tmp_474: int;
  var {:pointer} Tmp_475: int;
  var {:pointer} Tmp_476: int;
  var {:pointer} Tmp_477: int;
  var {:scalar} mask_2: int;
  var {:pointer} Tmp_478: int;
  var {:pointer} newIrp_3: int;
  var {:scalar} oldIrql_14: int;
  var {:scalar} oldIrql_15: int;
  var {:pointer} Extension_12: int;
  var vslice_dummy_var_1262: int;
  var vslice_dummy_var_1263: int;
  var vslice_dummy_var_1264: int;
  var vslice_dummy_var_1265: int;
  var vslice_dummy_var_1266: int;

  anon0:
    call {:si_unique_call 656} newIrp_3 := __HAVOC_malloc(4);
    Extension_12 := actual_Extension_12;
    goto L5;

  L5:
    call {:si_unique_call 657} oldIrql_13, Tmp_474, Tmp_475, Tmp_476, Tmp_477, mask_2, Tmp_478, oldIrql_14, oldIrql_15 := MoxaStartPurge_loop_L5(oldIrql_13, Tmp_474, Tmp_475, Tmp_476, Tmp_477, mask_2, Tmp_478, newIrp_3, oldIrql_14, oldIrql_15, Extension_12);
    goto L5_last;

  L5_last:
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc Tmp_474;
    assume {:nonnull} Tmp_474 != 0;
    assume Tmp_474 > 0;
    havoc Tmp_476;
    assume {:nonnull} Tmp_476 != 0;
    assume Tmp_476 > 0;
    mask_2 := Mem_T.INT4[Tmp_476];
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} BAND(mask_2, 1) != 0;
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc vslice_dummy_var_1262;
    call {:si_unique_call 658} MoxaKillAllReadsOrWrites(vslice_dummy_var_1262, WriteQueue__MOXA_DEVICE_EXTENSION(Extension_12), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(Extension_12));
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 659} Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    Mem_T.INT4[Tmp_478] := oldIrql_14;
    call {:si_unique_call 660} sdv_KeAcquireSpinLock(0, Tmp_478);
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    oldIrql_14 := Mem_T.INT4[Tmp_478];
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc vslice_dummy_var_1263;
    call {:si_unique_call 661} MoxaFunc(vslice_dummy_var_1263, 10, 1);
    call {:si_unique_call 662} sdv_KeReleaseSpinLock(0, oldIrql_14);
    goto L7;

  L7:
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} BAND(mask_2, 2) != 0;
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc vslice_dummy_var_1264;
    call {:si_unique_call 663} MoxaKillAllReadsOrWrites(vslice_dummy_var_1264, ReadQueue__MOXA_DEVICE_EXTENSION(Extension_12), CurrentReadIrp__MOXA_DEVICE_EXTENSION(Extension_12));
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} yogi_error != 1;
    goto L22;

  L22:
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:partition} BAND(mask_2, 4) != 0;
    call {:si_unique_call 664} Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    Mem_T.INT4[Tmp_478] := oldIrql_13;
    call {:si_unique_call 665} sdv_KeAcquireSpinLock(0, Tmp_478);
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    oldIrql_13 := Mem_T.INT4[Tmp_478];
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc vslice_dummy_var_1265;
    call {:si_unique_call 666} MoxaFunc(vslice_dummy_var_1265, 10, 1);
    call {:si_unique_call 667} sdv_KeReleaseSpinLock(0, oldIrql_13);
    goto L26;

  L26:
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} BAND(mask_2, 8) != 0;
    call {:si_unique_call 668} Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    Mem_T.INT4[Tmp_478] := oldIrql_15;
    call {:si_unique_call 669} sdv_KeAcquireSpinLock(0, Tmp_478);
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_478 != 0;
    assume Tmp_478 > 0;
    oldIrql_15 := Mem_T.INT4[Tmp_478];
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc vslice_dummy_var_1266;
    call {:si_unique_call 670} MoxaFunc(vslice_dummy_var_1266, 10, 0);
    call {:si_unique_call 671} sdv_KeReleaseSpinLock(0, oldIrql_15);
    goto L37;

  L37:
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc Tmp_477;
    assume {:nonnull} Tmp_477 != 0;
    assume Tmp_477 > 0;
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    havoc Tmp_475;
    assume {:nonnull} Tmp_475 != 0;
    assume Tmp_475 > 0;
    assume {:nonnull} Extension_12 != 0;
    assume Extension_12 > 0;
    call {:si_unique_call 672} MoxaGetNextIrp(CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(Extension_12), PurgeQueue__MOXA_DEVICE_EXTENSION(Extension_12), newIrp_3, 1, Extension_12);
    assume {:nonnull} newIrp_3 != 0;
    assume newIrp_3 > 0;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    Tmp_473 := 0;
    goto LM2;

  LM2:
    return;

  anon24_Then:
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    assume false;
    return;

  anon30_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon23_Then:
    assume {:partition} BAND(mask_2, 8) == 0;
    goto L37;

  anon29_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon22_Then:
    assume {:partition} BAND(mask_2, 4) == 0;
    goto L26;

  anon28_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon21_Then:
    assume {:partition} BAND(mask_2, 2) == 0;
    goto L22;

  anon27_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon26_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon25_Then:
    assume {:partition} BAND(mask_2, 1) == 0;
    goto L7;
}



procedure {:origName "_sdv_init3"} _sdv_init3();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init3"} _sdv_init3()
{
  var vslice_dummy_var_87: int;

  anon0:
    call {:si_unique_call 673} vslice_dummy_var_87 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaFinishStartDevice"} MoxaFinishStartDevice(actual_PDevObj_4: int) returns (Tmp_481: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFinishStartDevice"} MoxaFinishStartDevice(actual_PDevObj_4: int) returns (Tmp_481: int)
{
  var {:scalar} i_2: int;
  var {:scalar} Tmp_482: int;
  var {:scalar} Tmp_483: int;
  var {:scalar} Tmp_484: int;
  var {:scalar} Tmp_485: int;
  var {:pointer} Tmp_486: int;
  var {:scalar} Tmp_487: int;
  var {:pointer} Tmp_488: int;
  var {:scalar} Tmp_489: int;
  var {:pointer} Tmp_490: int;
  var {:pointer} Tmp_491: int;
  var {:scalar} Tmp_492: int;
  var {:scalar} Tmp_493: int;
  var {:pointer} Tmp_494: int;
  var {:pointer} moxaInterrupt: int;
  var {:pointer} dispatch_1: int;
  var {:scalar} Tmp_495: int;
  var {:scalar} Tmp_496: int;
  var {:pointer} cisrsw_1: int;
  var {:pointer} pDevExt_3: int;
  var {:scalar} processorAffinity: int;
  var {:scalar} Tmp_498: int;
  var {:scalar} Tmp_499: int;
  var {:pointer} Tmp_500: int;
  var {:scalar} Tmp_501: int;
  var {:scalar} Tmp_502: int;
  var {:scalar} Tmp_503: int;
  var {:scalar} Tmp_505: int;
  var {:scalar} Tmp_506: int;
  var {:pointer} sdv_152: int;
  var {:pointer} Tmp_507: int;
  var {:scalar} Tmp_508: int;
  var {:pointer} Tmp_509: int;
  var {:scalar} Tmp_510: int;
  var {:pointer} Tmp_511: int;
  var {:scalar} Tmp_512: int;
  var {:scalar} Tmp_513: int;
  var {:scalar} systemVector: int;
  var {:pointer} Tmp_514: int;
  var {:pointer} Tmp_515: int;
  var {:scalar} Tmp_516: int;
  var {:pointer} Tmp_517: int;
  var {:scalar} interruptMode: int;
  var {:scalar} Tmp_518: int;
  var {:pointer} sdv_154: int;
  var {:pointer} Tmp_519: int;
  var {:pointer} Tmp_520: int;
  var {:scalar} Tmp_521: int;
  var {:scalar} Tmp_522: int;
  var {:scalar} Tmp_523: int;
  var {:scalar} Tmp_524: int;
  var {:scalar} Tmp_525: int;
  var {:scalar} Tmp_526: int;
  var {:scalar} Tmp_527: int;
  var {:scalar} Tmp_528: int;
  var {:pointer} sdv_156: int;
  var {:pointer} Tmp_529: int;
  var {:pointer} Tmp_530: int;
  var {:pointer} Tmp_531: int;
  var {:scalar} Tmp_532: int;
  var {:scalar} Tmp_533: int;
  var {:scalar} Tmp_534: int;
  var {:scalar} Tmp_535: int;
  var {:scalar} Tmp_536: int;
  var {:scalar} Tmp_537: int;
  var {:pointer} Tmp_538: int;
  var {:scalar} Tmp_539: int;
  var {:pointer} Tmp_540: int;
  var {:scalar} Tmp_541: int;
  var {:pointer} Tmp_542: int;
  var {:pointer} Tmp_543: int;
  var {:scalar} Tmp_544: int;
  var {:pointer} Tmp_545: int;
  var {:pointer} Tmp_546: int;
  var {:pointer} Tmp_547: int;
  var {:pointer} Tmp_548: int;
  var {:pointer} Tmp_549: int;
  var {:scalar} Tmp_550: int;
  var {:scalar} status_13: int;
  var {:pointer} Tmp_552: int;
  var {:pointer} Tmp_553: int;
  var {:pointer} Tmp_554: int;
  var {:scalar} Tmp_555: int;
  var {:pointer} Tmp_556: int;
  var {:scalar} irql: int;
  var {:pointer} Tmp_557: int;
  var {:pointer} countSoFar: int;
  var {:pointer} Tmp_558: int;
  var {:pointer} Tmp_559: int;
  var {:pointer} Tmp_560: int;
  var {:scalar} Tmp_561: int;
  var {:scalar} Tmp_562: int;
  var {:scalar} Tmp_563: int;
  var {:pointer} Tmp_564: int;
  var {:scalar} Tmp_565: int;
  var {:pointer} PDevObj_4: int;
  var vslice_dummy_var_88: int;
  var vslice_dummy_var_89: int;
  var vslice_dummy_var_90: int;
  var vslice_dummy_var_91: int;
  var vslice_dummy_var_1267: int;
  var vslice_dummy_var_1268: int;
  var vslice_dummy_var_1269: int;
  var vslice_dummy_var_1270: int;
  var vslice_dummy_var_1271: int;
  var vslice_dummy_var_1272: int;
  var vslice_dummy_var_1273: int;
  var vslice_dummy_var_1274: int;
  var vslice_dummy_var_1275: int;
  var vslice_dummy_var_1276: int;
  var vslice_dummy_var_1277: int;

  anon0:
    call {:si_unique_call 674} Tmp_487 := __HAVOC_malloc(20);
    call {:si_unique_call 675} Tmp_492 := __HAVOC_malloc(20);
    call {:si_unique_call 676} moxaInterrupt := __HAVOC_malloc(4);
    call {:si_unique_call 677} Tmp_535 := __HAVOC_malloc(20);
    call {:si_unique_call 678} Tmp_537 := __HAVOC_malloc(20);
    call {:si_unique_call 679} Tmp_562 := __HAVOC_malloc(20);
    call {:si_unique_call 680} Tmp_565 := __HAVOC_malloc(20);
    PDevObj_4 := actual_PDevObj_4;
    call {:si_unique_call 681} Tmp_486 := __HAVOC_malloc(16);
    call {:si_unique_call 682} Tmp_488 := __HAVOC_malloc(16);
    call {:si_unique_call 683} Tmp_490 := __HAVOC_malloc(16);
    call {:si_unique_call 684} Tmp_491 := __HAVOC_malloc(16);
    call {:si_unique_call 685} Tmp_500 := __HAVOC_malloc(16);
    call {:si_unique_call 686} Tmp_507 := __HAVOC_malloc(16);
    call {:si_unique_call 687} Tmp_509 := __HAVOC_malloc(16);
    call {:si_unique_call 688} Tmp_511 := __HAVOC_malloc(16);
    call {:si_unique_call 689} Tmp_514 := __HAVOC_malloc(16);
    call {:si_unique_call 690} Tmp_517 := __HAVOC_malloc(16);
    call {:si_unique_call 691} Tmp_519 := __HAVOC_malloc(16);
    call {:si_unique_call 692} Tmp_520 := __HAVOC_malloc(16);
    call {:si_unique_call 693} Tmp_529 := __HAVOC_malloc(16);
    call {:si_unique_call 694} Tmp_530 := __HAVOC_malloc(16);
    call {:si_unique_call 695} Tmp_531 := __HAVOC_malloc(16);
    call {:si_unique_call 696} Tmp_538 := __HAVOC_malloc(16);
    call {:si_unique_call 697} Tmp_540 := __HAVOC_malloc(16);
    call {:si_unique_call 698} Tmp_542 := __HAVOC_malloc(16);
    call {:si_unique_call 699} Tmp_543 := __HAVOC_malloc(80);
    call {:si_unique_call 700} Tmp_545 := __HAVOC_malloc(16);
    call {:si_unique_call 701} Tmp_546 := __HAVOC_malloc(16);
    call {:si_unique_call 702} Tmp_547 := __HAVOC_malloc(16);
    call {:si_unique_call 703} Tmp_548 := __HAVOC_malloc(16);
    call {:si_unique_call 704} Tmp_549 := __HAVOC_malloc(16);
    call {:si_unique_call 705} vslice_dummy_var_89 := __HAVOC_malloc(16);
    call {:si_unique_call 706} Tmp_552 := __HAVOC_malloc(16);
    call {:si_unique_call 707} Tmp_553 := __HAVOC_malloc(16);
    call {:si_unique_call 708} Tmp_554 := __HAVOC_malloc(16);
    call {:si_unique_call 709} Tmp_556 := __HAVOC_malloc(16);
    call {:si_unique_call 710} Tmp_557 := __HAVOC_malloc(16);
    call {:si_unique_call 711} Tmp_558 := __HAVOC_malloc(16);
    call {:si_unique_call 712} Tmp_559 := __HAVOC_malloc(16);
    call {:si_unique_call 713} Tmp_560 := __HAVOC_malloc(16);
    call {:si_unique_call 714} Tmp_564 := __HAVOC_malloc(16);
    assume {:nonnull} PDevObj_4 != 0;
    assume PDevObj_4 > 0;
    havoc pDevExt_3;
    status_13 := 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon96_Then, anon96_Else;

  anon96_Else:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_3)], 2) != 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 715} MoxaSetDeviceFlags(pDevExt_3, Flags__MOXA_DEVICE_EXTENSION(pDevExt_3), 2, 0);
    goto anon97_Then, anon97_Else;

  anon97_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L19;

  L19:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon77_Then, anon77_Else;

  anon77_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1267;
    call {:si_unique_call 716} status_13 := MoxaGotoPowerState(vslice_dummy_var_1267, pDevExt_3, 1);
    goto anon78_Then, anon78_Else;

  anon78_Else:
    assume {:partition} status_13 < 0;
    goto L31;

  L31:
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume {:partition} status_13 >= 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_501;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_554;
    assume {:nonnull} Tmp_554 != 0;
    assume Tmp_554 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_498;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_560;
    assume {:nonnull} Tmp_560 != 0;
    assume Tmp_560 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_484;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_517;
    assume {:nonnull} Tmp_517 != 0;
    assume Tmp_517 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_525;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_514;
    assume {:nonnull} Tmp_514 != 0;
    assume Tmp_514 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_493;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_543;
    assume {:nonnull} Tmp_543 != 0;
    assume Tmp_543 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon99_Then, anon99_Else;

  anon99_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon89_Then, anon89_Else;

  anon89_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon88_Then, anon88_Else;

  anon88_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L46;

  L46:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon100_Then, anon100_Else;

  anon100_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon93_Then, anon93_Else;

  anon93_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon92_Then, anon92_Else;

  anon92_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon91_Then, anon91_Else;

  anon91_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon90_Then, anon90_Else;

  anon90_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  L55:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon95_Then, anon95_Else;

  anon95_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon94_Then, anon94_Else;

  anon94_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L60;

  L60:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon101_Then, anon101_Else;

  anon101_Else:
    call {:si_unique_call 717} sdv_154 := IoGetConfigurationInformation();
    assume {:nonnull} sdv_154 != 0;
    assume sdv_154 > 0;
    countSoFar := SerialCount__CONFIGURATION_INFORMATION(sdv_154);
    assume {:nonnull} countSoFar != 0;
    assume countSoFar > 0;
    Mem_T.INT4[countSoFar] := Mem_T.INT4[countSoFar] + 1;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 718} vslice_dummy_var_90 := IoWMIRegistrationControl(0, 1);
    goto L82;

  L82:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    call {:si_unique_call 719} MoxaUnstallIrps(pDevExt_3);
    goto L83;

  L83:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 720} MoxaSetDeviceFlags(pDevExt_3, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_3), -1, 0);
    goto anon102_Then, anon102_Else;

  anon102_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 721} MoxaSetDeviceFlags(pDevExt_3, Flags__MOXA_DEVICE_EXTENSION(pDevExt_3), 1, 1);
    goto anon103_Then, anon103_Else;

  anon103_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  L93:
    Tmp_481 := status_13;
    goto LM2;

  LM2:
    return;

  anon103_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon102_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon82_Then:
    goto L83;

  anon101_Then:
    goto L82;

  anon94_Then:
    goto L56;

  L56:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L60;

  anon95_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L60;

  anon81_Then:
    goto L56;

  anon90_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  anon91_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  anon92_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  anon93_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  anon100_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L55;

  anon88_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L46;

  anon89_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L46;

  anon99_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L46;

  anon79_Then:
    assume {:partition} 0 > status_13;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    call {:si_unique_call 722} MoxaKillPendingIrps(PDevObj_4);
    goto anon104_Then, anon104_Else;

  anon104_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 723} MoxaSetDeviceFlags(pDevExt_3, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_3), 1, 1);
    goto anon105_Then, anon105_Else;

  anon105_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    call {:si_unique_call 724} MoxaSetDeviceFlags(pDevExt_3, Flags__MOXA_DEVICE_EXTENSION(pDevExt_3), 1, 0);
    goto anon106_Then, anon106_Else;

  anon106_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  anon106_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon105_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon104_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon80_Then:
    goto L93;

  anon78_Then:
    assume {:partition} 0 <= status_13;
    goto L24;

  L24:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_506;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_558;
    assume {:nonnull} Tmp_558 != 0;
    assume Tmp_558 > 0;
    goto anon98_Then, anon98_Else;

  anon98_Else:
    goto L131;

  L131:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_508;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_509;
    assume {:nonnull} Tmp_509 != 0;
    assume Tmp_509 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_527;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_547;
    assume {:nonnull} Tmp_547 != 0;
    assume Tmp_547 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto L133;

  L133:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_494;
    assume {:nonnull} Tmp_494 != 0;
    assume Tmp_494 > 0;
    havoc vslice_dummy_var_1268;
    call {:si_unique_call 725} status_13 := MoxaDoExternalNaming(pDevExt_3, vslice_dummy_var_1268);
    goto anon84_Then, anon84_Else;

  anon84_Else:
    assume {:partition} status_13 < 0;
    status_13 := 0;
    goto L31;

  anon84_Then:
    assume {:partition} 0 <= status_13;
    goto L31;

  anon83_Then:
    goto L31;

  anon98_Then:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_516;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_549;
    assume {:nonnull} Tmp_549 != 0;
    assume Tmp_549 > 0;
    goto anon107_Then, anon107_Else;

  anon107_Else:
    assume {:partition} Mem_T.INT4[Tmp_549 + Tmp_516 * 4] != 0;
    call {:si_unique_call 726} sdv_156 := ExAllocatePoolWithTag(0, 16, -261523379);
    cisrsw_1 := sdv_156;
    goto anon108_Then, anon108_Else;

  anon108_Else:
    assume {:partition} cisrsw_1 != 0;
    assume {:nonnull} cisrsw_1 != 0;
    assume cisrsw_1 > 0;
    dispatch_1 := Dispatch__MOXA_CISR_SW(cisrsw_1);
    assume {:nonnull} dispatch_1 != 0;
    assume dispatch_1 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} dispatch_1 != 0;
    assume dispatch_1 > 0;
    i_2 := 0;
    goto L151;

  L151:
    call {:si_unique_call 727} i_2, Tmp_500, Tmp_513, Tmp_522, Tmp_526, Tmp_531, Tmp_532, Tmp_538, Tmp_542, Tmp_544, Tmp_545 := MoxaFinishStartDevice_loop_L151(i_2, pDevExt_3, Tmp_500, Tmp_513, Tmp_522, Tmp_526, Tmp_531, Tmp_532, Tmp_538, Tmp_542, Tmp_544, Tmp_545);
    goto L151_last;

  L151_last:
    assume {:CounterLoop 4} {:Counter "i_2"} true;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume {:partition} 4 > i_2;
    Tmp_544 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_538;
    assume {:nonnull} Tmp_538 != 0;
    assume Tmp_538 > 0;
    goto anon109_Then, anon109_Else;

  anon109_Else:
    Tmp_532 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_531;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_513;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_545;
    assume {:nonnull} Tmp_531 != 0;
    assume Tmp_531 > 0;
    assume {:nonnull} Tmp_545 != 0;
    assume Tmp_545 > 0;
    goto anon110_Then, anon110_Else;

  anon110_Else:
    assume {:partition} Mem_T.INT4[Tmp_531 + Tmp_532 * 4] == Mem_T.INT4[Tmp_545 + Tmp_513 * 4];
    Tmp_526 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_500;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_522;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_542;
    assume {:nonnull} Tmp_500 != 0;
    assume Tmp_500 > 0;
    assume {:nonnull} Tmp_542 != 0;
    assume Tmp_542 > 0;
    goto anon111_Then, anon111_Else;

  anon111_Else:
    assume {:partition} Mem_T.INT4[Tmp_500 + Tmp_526 * 4] != Mem_T.INT4[Tmp_542 + Tmp_522 * 4];
    goto L154;

  L154:
    i_2 := i_2 + 1;
    goto L154_dummy;

  L154_dummy:
    assume false;
    return;

  anon111_Then:
    assume {:partition} Mem_T.INT4[Tmp_500 + Tmp_526 * 4] == Mem_T.INT4[Tmp_542 + Tmp_522 * 4];
    goto L152;

  L152:
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume {:partition} i_2 != 4;
    Tmp_534 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_520;
    assume {:nonnull} Tmp_520 != 0;
    assume Tmp_520 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_510;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_511;
    assume {:nonnull} Tmp_511 != 0;
    assume Tmp_511 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_541;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_546;
    Tmp_518 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_552;
    assume {:nonnull} Tmp_546 != 0;
    assume Tmp_546 > 0;
    assume {:nonnull} Tmp_552 != 0;
    assume Tmp_552 > 0;
    Mem_T.INT4[Tmp_546 + Tmp_541 * 4] := Mem_T.INT4[Tmp_552 + Tmp_518 * 4];
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_539;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_491;
    Tmp_536 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_519;
    assume {:nonnull} Tmp_491 != 0;
    assume Tmp_491 > 0;
    assume {:nonnull} Tmp_519 != 0;
    assume Tmp_519 > 0;
    Mem_T.INT4[Tmp_491 + Tmp_539 * 4] := Mem_T.INT4[Tmp_519 + Tmp_536 * 4];
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_499;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_564;
    Tmp_483 := i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_507;
    assume {:nonnull} Tmp_507 != 0;
    assume Tmp_507 > 0;
    assume {:nonnull} Tmp_564 != 0;
    assume Tmp_564 > 0;
    assume {:nonnull} Tmp_564 != 0;
    assume Tmp_564 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} cisrsw_1 != 0;
    assume cisrsw_1 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1269;
    call {:si_unique_call 728} vslice_dummy_var_91 := sdv_InsertTailList(vslice_dummy_var_1269, SharerList__MOXA_CISR_SW(cisrsw_1));
    goto L133;

  anon86_Then:
    assume {:partition} i_2 == 4;
    call {:si_unique_call 729} sdv_152 := ExAllocatePoolWithTag(0, 8, -261523379);
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_563;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_556;
    assume {:nonnull} Tmp_556 != 0;
    assume Tmp_556 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    goto anon112_Then, anon112_Else;

  anon112_Else:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_528;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_557;
    assume {:nonnull} Tmp_557 != 0;
    assume Tmp_557 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1270;
    call {:si_unique_call 730} InitializeListHead(vslice_dummy_var_1270);
    assume {:nonnull} cisrsw_1 != 0;
    assume cisrsw_1 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1271;
    call {:si_unique_call 731} vslice_dummy_var_88 := sdv_InsertTailList(vslice_dummy_var_1271, SharerList__MOXA_CISR_SW(cisrsw_1));
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_482;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_529;
    assume {:nonnull} Tmp_529 != 0;
    assume Tmp_529 > 0;
    Tmp_524 := Mem_T.INT4[Tmp_529 + Tmp_482 * 4];
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_496;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_488;
    assume {:nonnull} Tmp_488 != 0;
    assume Tmp_488 > 0;
    Tmp_495 := Mem_T.INT4[Tmp_488 + Tmp_496 * 4];
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_561;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_530;
    assume {:nonnull} Tmp_530 != 0;
    assume Tmp_530 > 0;
    Tmp_555 := Mem_T.INT4[Tmp_530 + Tmp_561 * 4];
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_521;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_548;
    assume {:nonnull} Tmp_548 != 0;
    assume Tmp_548 > 0;
    Tmp_503 := Mem_T.INT4[Tmp_548 + Tmp_521 * 4];
    call {:si_unique_call 732} systemVector := HalGetInterruptVector(Tmp_503, Tmp_555, Tmp_495, Tmp_524, 0, 0);
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_512;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_559;
    assume {:nonnull} Tmp_559 != 0;
    assume Tmp_559 > 0;
    goto anon113_Then, anon113_Else;

  anon113_Else:
    assume {:partition} Mem_T.INT4[Tmp_559 + Tmp_512 * 4] == 5;
    interruptMode := 0;
    goto L192;

  L192:
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_502;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_486;
    assume {:nonnull} Tmp_486 != 0;
    assume Tmp_486 > 0;
    havoc Tmp_515;
    call {:si_unique_call 733} status_13 := IoConnectInterrupt(moxaInterrupt, li2bplFunctionConstant239, Tmp_515, 0, systemVector, irql, irql, interruptMode, 1, processorAffinity, 0);
    goto anon114_Then, anon114_Else;

  anon114_Else:
    assume {:partition} yogi_error != 1;
    goto anon87_Then, anon87_Else;

  anon87_Else:
    assume {:partition} status_13 >= 0;
    assume {:nonnull} moxaInterrupt != 0;
    assume moxaInterrupt > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_550;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_540;
    assume {:nonnull} Tmp_540 != 0;
    assume Tmp_540 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_505;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_490;
    assume {:nonnull} Tmp_490 != 0;
    assume Tmp_490 > 0;
    Mem_T.INT4[Tmp_490 + Tmp_505 * 4] := irql;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_533;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_553;
    assume {:nonnull} Tmp_553 != 0;
    assume Tmp_553 > 0;
    Mem_T.INT4[Tmp_553 + Tmp_533 * 4] := processorAffinity;
    goto L133;

  anon87_Then:
    assume {:partition} 0 > status_13;
    call {:si_unique_call 734} sdv_ExFreePool(0);
    status_13 := -1073348601;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_485;
    assume {:nonnull} Tmp_535 != 0;
    assume Tmp_535 > 0;
    assume {:nonnull} Tmp_535 != 0;
    assume Tmp_535 > 0;
    assume {:nonnull} Tmp_535 != 0;
    assume Tmp_535 > 0;
    assume {:nonnull} Tmp_535 != 0;
    assume Tmp_535 > 0;
    assume {:nonnull} Tmp_535 != 0;
    assume Tmp_535 > 0;
    assume {:nonnull} Tmp_487 != 0;
    assume Tmp_487 > 0;
    assume {:nonnull} Tmp_487 != 0;
    assume Tmp_487 > 0;
    assume {:nonnull} Tmp_487 != 0;
    assume Tmp_487 > 0;
    assume {:nonnull} Tmp_487 != 0;
    assume Tmp_487 > 0;
    assume {:nonnull} Tmp_487 != 0;
    assume Tmp_487 > 0;
    assume {:nonnull} PDevObj_4 != 0;
    assume PDevObj_4 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1272;
    havoc vslice_dummy_var_1273;
    call {:si_unique_call 735} MoxaLogError(vslice_dummy_var_1272, 0, Tmp_487, Tmp_535, 0, 0, 0, 1, status_13, -1073348601, Tmp_485, vslice_dummy_var_1273, 0, 0);
    goto L31;

  anon114_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon113_Then:
    assume {:partition} Mem_T.INT4[Tmp_559 + Tmp_512 * 4] != 5;
    interruptMode := 1;
    goto L192;

  anon112_Then:
    call {:si_unique_call 736} sdv_ExFreePool(0);
    status_13 := -1073348600;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_523;
    assume {:nonnull} Tmp_537 != 0;
    assume Tmp_537 > 0;
    assume {:nonnull} Tmp_537 != 0;
    assume Tmp_537 > 0;
    assume {:nonnull} Tmp_537 != 0;
    assume Tmp_537 > 0;
    assume {:nonnull} Tmp_537 != 0;
    assume Tmp_537 > 0;
    assume {:nonnull} Tmp_537 != 0;
    assume Tmp_537 > 0;
    assume {:nonnull} Tmp_562 != 0;
    assume Tmp_562 > 0;
    assume {:nonnull} Tmp_562 != 0;
    assume Tmp_562 > 0;
    assume {:nonnull} Tmp_562 != 0;
    assume Tmp_562 > 0;
    assume {:nonnull} Tmp_562 != 0;
    assume Tmp_562 > 0;
    assume {:nonnull} Tmp_562 != 0;
    assume Tmp_562 > 0;
    assume {:nonnull} PDevObj_4 != 0;
    assume PDevObj_4 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1274;
    havoc vslice_dummy_var_1275;
    call {:si_unique_call 737} MoxaLogError(vslice_dummy_var_1274, 0, Tmp_562, Tmp_537, 0, 0, 0, 1, status_13, -1073348600, Tmp_523, vslice_dummy_var_1275, 0, 0);
    goto L31;

  anon110_Then:
    assume {:partition} Mem_T.INT4[Tmp_531 + Tmp_532 * 4] != Mem_T.INT4[Tmp_545 + Tmp_513 * 4];
    goto L154;

  anon109_Then:
    goto L154;

  anon85_Then:
    assume {:partition} i_2 >= 4;
    goto L152;

  anon108_Then:
    assume {:partition} cisrsw_1 == 0;
    status_13 := -1073348600;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc Tmp_489;
    assume {:nonnull} Tmp_565 != 0;
    assume Tmp_565 > 0;
    assume {:nonnull} Tmp_565 != 0;
    assume Tmp_565 > 0;
    assume {:nonnull} Tmp_565 != 0;
    assume Tmp_565 > 0;
    assume {:nonnull} Tmp_565 != 0;
    assume Tmp_565 > 0;
    assume {:nonnull} Tmp_565 != 0;
    assume Tmp_565 > 0;
    assume {:nonnull} Tmp_492 != 0;
    assume Tmp_492 > 0;
    assume {:nonnull} Tmp_492 != 0;
    assume Tmp_492 > 0;
    assume {:nonnull} Tmp_492 != 0;
    assume Tmp_492 > 0;
    assume {:nonnull} Tmp_492 != 0;
    assume Tmp_492 > 0;
    assume {:nonnull} Tmp_492 != 0;
    assume Tmp_492 > 0;
    assume {:nonnull} PDevObj_4 != 0;
    assume PDevObj_4 > 0;
    assume {:nonnull} pDevExt_3 != 0;
    assume pDevExt_3 > 0;
    havoc vslice_dummy_var_1276;
    havoc vslice_dummy_var_1277;
    call {:si_unique_call 738} MoxaLogError(vslice_dummy_var_1276, 0, Tmp_492, Tmp_565, 0, 0, 0, 1, status_13, -1073348600, Tmp_489, vslice_dummy_var_1277, 0, 0);
    goto L31;

  anon107_Then:
    assume {:partition} Mem_T.INT4[Tmp_549 + Tmp_516 * 4] == 0;
    goto L131;

  anon77_Then:
    goto L24;

  anon97_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon96_Then:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_3)], 2) == 0;
    goto L19;
}



procedure {:origName "MoxaUndoExternalNaming"} MoxaUndoExternalNaming(actual_Extension_13: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaUndoExternalNaming"} MoxaUndoExternalNaming(actual_Extension_13: int)
{
  var {:scalar} Tmp_567: int;
  var {:pointer} Tmp_570: int;
  var {:scalar} Tmp_571: int;
  var {:scalar} status_14: int;
  var {:scalar} Tmp_575: int;
  var {:pointer} Extension_13: int;
  var vslice_dummy_var_92: int;
  var vslice_dummy_var_93: int;
  var vslice_dummy_var_94: int;
  var vslice_dummy_var_1278: int;
  var vslice_dummy_var_1279: int;
  var vslice_dummy_var_1280: int;

  anon0:
    call {:si_unique_call 739} Tmp_567 := __HAVOC_malloc(20);
    call {:si_unique_call 740} vslice_dummy_var_92 := __HAVOC_malloc(4);
    call {:si_unique_call 741} Tmp_571 := __HAVOC_malloc(20);
    Extension_13 := actual_Extension_13;
    call {:si_unique_call 742} vslice_dummy_var_94 := __HAVOC_malloc(44);
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    call {:si_unique_call 743} status_14 := IoSetDeviceInterfaceState(0, 0);
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    call {:si_unique_call 744} sdv_ExFreePool(0);
    goto L8;

  L8:
    call {:si_unique_call 745} vslice_dummy_var_93 := IoDeleteSymbolicLink(0);
    goto L5;

  L5:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    call {:si_unique_call 746} sdv_ExFreePool(0);
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto L18;

  L18:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    call {:si_unique_call 747} status_14 := RtlDeleteRegistryValue(4, 0, 0);
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} status_14 < 0;
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    havoc Tmp_575;
    assume {:nonnull} Tmp_571 != 0;
    assume Tmp_571 > 0;
    assume {:nonnull} Tmp_571 != 0;
    assume Tmp_571 > 0;
    assume {:nonnull} Tmp_571 != 0;
    assume Tmp_571 > 0;
    assume {:nonnull} Tmp_571 != 0;
    assume Tmp_571 > 0;
    assume {:nonnull} Tmp_571 != 0;
    assume Tmp_571 > 0;
    assume {:nonnull} Tmp_567 != 0;
    assume Tmp_567 > 0;
    assume {:nonnull} Tmp_567 != 0;
    assume Tmp_567 > 0;
    assume {:nonnull} Tmp_567 != 0;
    assume Tmp_567 > 0;
    assume {:nonnull} Tmp_567 != 0;
    assume Tmp_567 > 0;
    assume {:nonnull} Tmp_567 != 0;
    assume Tmp_567 > 0;
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    havoc Tmp_570;
    assume {:nonnull} Extension_13 != 0;
    assume Extension_13 > 0;
    assume {:nonnull} Tmp_570 != 0;
    assume Tmp_570 > 0;
    havoc vslice_dummy_var_1278;
    havoc vslice_dummy_var_1279;
    havoc vslice_dummy_var_1280;
    call {:si_unique_call 748} MoxaLogError(vslice_dummy_var_1278, vslice_dummy_var_1279, Tmp_567, Tmp_571, 0, 0, 0, 55, status_14, 393222, Tmp_575, vslice_dummy_var_1280, 0, 0);
    goto L1;

  L1:
    return;

  anon21_Then:
    assume {:partition} 0 <= status_14;
    goto L1;

  anon20_Then:
    goto L1;

  anon19_Then:
    goto L1;

  anon16_Then:
    goto L18;

  anon18_Then:
    goto L8;

  anon17_Then:
    goto L5;

  anon15_Then:
    goto L5;
}



procedure {:origName "MoxaDoExternalNaming"} MoxaDoExternalNaming(actual_PDevExt_3: int, actual_PDrvObj: int) returns (Tmp_576: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_576 == -1073741772 || Tmp_576 == -1073741824 || Tmp_576 == -1073741789 || Tmp_576 == -1073741670 || Tmp_576 == -1073741808 || Tmp_576 == 0 || Tmp_576 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDoExternalNaming"} MoxaDoExternalNaming(actual_PDevExt_3: int, actual_PDrvObj: int) returns (Tmp_576: int)
{
  var {:scalar} Tmp_577: int;
  var {:scalar} bufLen: int;
  var {:scalar} sdv_162: int;
  var {:scalar} Tmp_578: int;
  var {:scalar} linkName: int;
  var {:scalar} Tmp_580: int;
  var {:scalar} Tmp_581: int;
  var {:pointer} sdv_165: int;
  var {:scalar} Tmp_582: int;
  var {:scalar} Tmp_583: int;
  var {:scalar} Tmp_587: int;
  var {:pointer} sdv_167: int;
  var {:scalar} sdv_169: int;
  var {:scalar} Tmp_590: int;
  var {:scalar} Tmp_591: int;
  var {:scalar} Tmp_592: int;
  var {:pointer} sdv_171: int;
  var {:scalar} Tmp_593: int;
  var {:scalar} Tmp_594: int;
  var {:scalar} Tmp_596: int;
  var {:scalar} Tmp_597: int;
  var {:scalar} status_15: int;
  var {:pointer} pDevObj: int;
  var {:scalar} Tmp_601: int;
  var {:scalar} Tmp_602: int;
  var {:scalar} Tmp_603: int;
  var {:pointer} PDevExt_3: int;
  var {:pointer} PDrvObj: int;
  var vslice_dummy_var_95: int;
  var vslice_dummy_var_96: int;
  var vslice_dummy_var_97: int;
  var vslice_dummy_var_98: int;
  var vslice_dummy_var_99: int;
  var vslice_dummy_var_100: int;
  var vslice_dummy_var_101: int;
  var vslice_dummy_var_102: int;
  var vslice_dummy_var_103: int;
  var vslice_dummy_var_104: int;
  var vslice_dummy_var_105: int;
  var vslice_dummy_var_106: int;
  var vslice_dummy_var_107: int;
  var vslice_dummy_var_108: int;
  var vslice_dummy_var_1281: int;
  var vslice_dummy_var_1282: int;

  anon0:
    call {:si_unique_call 749} Tmp_577 := __HAVOC_malloc(20);
    call {:si_unique_call 750} linkName := __HAVOC_malloc(12);
    call {:si_unique_call 751} Tmp_580 := __HAVOC_malloc(20);
    call {:si_unique_call 752} Tmp_581 := __HAVOC_malloc(20);
    call {:si_unique_call 753} Tmp_583 := __HAVOC_malloc(20);
    call {:si_unique_call 754} Tmp_587 := __HAVOC_malloc(20);
    call {:si_unique_call 755} Tmp_591 := __HAVOC_malloc(20);
    call {:si_unique_call 756} Tmp_592 := __HAVOC_malloc(20);
    call {:si_unique_call 757} Tmp_593 := __HAVOC_malloc(20);
    call {:si_unique_call 758} Tmp_601 := __HAVOC_malloc(20);
    call {:si_unique_call 759} Tmp_603 := __HAVOC_malloc(20);
    PDevExt_3 := actual_PDevExt_3;
    PDrvObj := actual_PDrvObj;
    call {:si_unique_call 760} vslice_dummy_var_99 := __HAVOC_malloc(44);
    call {:si_unique_call 761} vslice_dummy_var_100 := __HAVOC_malloc(44);
    call {:si_unique_call 762} vslice_dummy_var_101 := __HAVOC_malloc(8);
    call {:si_unique_call 763} vslice_dummy_var_102 := __HAVOC_malloc(44);
    call {:si_unique_call 764} vslice_dummy_var_103 := __HAVOC_malloc(8);
    status_15 := 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc pDevObj;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 765} sdv_RtlZeroMemory(0, 8);
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    havoc Tmp_594;
    call {:si_unique_call 766} sdv_165 := ExAllocatePoolWithTag(1, Tmp_594, -261523379);
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    havoc Tmp_578;
    call {:si_unique_call 767} sdv_RtlZeroMemory(0, Tmp_578);
    call {:si_unique_call 768} sdv_169 := corral_nondet();
    bufLen := sdv_169 * 2 + 2;
    call {:si_unique_call 769} sdv_171 := ExAllocatePoolWithTag(1, bufLen, -261523379);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    call {:si_unique_call 770} sdv_RtlZeroMemory(0, bufLen);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 771} vslice_dummy_var_104 := corral_nondet();
    call {:si_unique_call 772} vslice_dummy_var_105 := corral_nondet();
    call {:si_unique_call 773} vslice_dummy_var_106 := corral_nondet();
    call {:si_unique_call 774} vslice_dummy_var_107 := corral_nondet();
    call {:si_unique_call 775} vslice_dummy_var_95 := corral_nondet();
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc Tmp_582;
    call {:si_unique_call 776} sdv_167 := ExAllocatePoolWithTag(1, Tmp_582, -261523379);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc Tmp_602;
    call {:si_unique_call 777} sdv_RtlZeroMemory(0, Tmp_602);
    call {:si_unique_call 778} vslice_dummy_var_96 := corral_nondet();
    call {:si_unique_call 779} status_15 := IoCreateSymbolicLink(0, 0);
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} status_15 >= 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 780} sdv_162 := corral_nondet();
    Tmp_590 := sdv_162 * 2 + 2;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 781} status_15 := RtlWriteRegistryValue(4, 0, 0, 1, 0, Tmp_590);
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} status_15 >= 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 782} status_15 := IoSetDeviceInterfaceState(0, 1);
    goto L94;

  L94:
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} status_15 >= 0;
    goto L96;

  L96:
    assume {:nonnull} linkName != 0;
    assume linkName > 0;
    goto anon29_Then, anon29_Else;

  anon29_Else:
    call {:si_unique_call 783} sdv_ExFreePool(0);
    goto L97;

  L97:
    Tmp_576 := status_15;
    return;

  anon29_Then:
    goto L97;

  anon27_Then:
    assume {:partition} 0 > status_15;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    call {:si_unique_call 784} vslice_dummy_var_97 := IoDeleteSymbolicLink(0);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto L101;

  L101:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 785} sdv_ExFreePool(0);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto L106;

  L106:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 786} vslice_dummy_var_108 := RtlDeleteRegistryValue(4, 0, 0);
    goto L111;

  L111:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon32_Then, anon32_Else;

  anon32_Else:
    call {:si_unique_call 787} vslice_dummy_var_98 := IoSetDeviceInterfaceState(0, 0);
    goto L115;

  L115:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    call {:si_unique_call 788} sdv_ExFreePool(0);
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    goto L96;

  anon33_Then:
    goto L96;

  anon32_Then:
    goto L115;

  anon31_Then:
    goto L111;

  anon30_Then:
    goto L106;

  anon28_Then:
    goto L101;

  anon26_Then:
    assume {:partition} 0 > status_15;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc Tmp_596;
    assume {:nonnull} Tmp_603 != 0;
    assume Tmp_603 > 0;
    assume {:nonnull} Tmp_603 != 0;
    assume Tmp_603 > 0;
    assume {:nonnull} Tmp_603 != 0;
    assume Tmp_603 > 0;
    assume {:nonnull} Tmp_603 != 0;
    assume Tmp_603 > 0;
    assume {:nonnull} Tmp_603 != 0;
    assume Tmp_603 > 0;
    assume {:nonnull} Tmp_601 != 0;
    assume Tmp_601 > 0;
    assume {:nonnull} Tmp_601 != 0;
    assume Tmp_601 > 0;
    assume {:nonnull} Tmp_601 != 0;
    assume Tmp_601 > 0;
    assume {:nonnull} Tmp_601 != 0;
    assume Tmp_601 > 0;
    assume {:nonnull} Tmp_601 != 0;
    assume Tmp_601 > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc vslice_dummy_var_1281;
    call {:si_unique_call 789} MoxaLogError(PDrvObj, pDevObj, Tmp_601, Tmp_603, 0, 0, 0, 53, status_15, 393221, Tmp_596, vslice_dummy_var_1281, 0, 0);
    goto L94;

  anon25_Then:
    assume {:partition} 0 > status_15;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc Tmp_597;
    assume {:nonnull} Tmp_583 != 0;
    assume Tmp_583 > 0;
    assume {:nonnull} Tmp_583 != 0;
    assume Tmp_583 > 0;
    assume {:nonnull} Tmp_583 != 0;
    assume Tmp_583 > 0;
    assume {:nonnull} Tmp_583 != 0;
    assume Tmp_583 > 0;
    assume {:nonnull} Tmp_583 != 0;
    assume Tmp_583 > 0;
    assume {:nonnull} Tmp_580 != 0;
    assume Tmp_580 > 0;
    assume {:nonnull} Tmp_580 != 0;
    assume Tmp_580 > 0;
    assume {:nonnull} Tmp_580 != 0;
    assume Tmp_580 > 0;
    assume {:nonnull} Tmp_580 != 0;
    assume Tmp_580 > 0;
    assume {:nonnull} Tmp_580 != 0;
    assume Tmp_580 > 0;
    assume {:nonnull} PDevExt_3 != 0;
    assume PDevExt_3 > 0;
    havoc vslice_dummy_var_1282;
    call {:si_unique_call 790} MoxaLogError(PDrvObj, pDevObj, Tmp_580, Tmp_583, 0, 0, 0, 52, status_15, 393220, Tmp_597, vslice_dummy_var_1282, 0, 0);
    goto L94;

  anon36_Then:
    assume {:nonnull} Tmp_592 != 0;
    assume Tmp_592 > 0;
    assume {:nonnull} Tmp_592 != 0;
    assume Tmp_592 > 0;
    assume {:nonnull} Tmp_592 != 0;
    assume Tmp_592 > 0;
    assume {:nonnull} Tmp_592 != 0;
    assume Tmp_592 > 0;
    assume {:nonnull} Tmp_592 != 0;
    assume Tmp_592 > 0;
    assume {:nonnull} Tmp_591 != 0;
    assume Tmp_591 > 0;
    assume {:nonnull} Tmp_591 != 0;
    assume Tmp_591 > 0;
    assume {:nonnull} Tmp_591 != 0;
    assume Tmp_591 > 0;
    assume {:nonnull} Tmp_591 != 0;
    assume Tmp_591 > 0;
    assume {:nonnull} Tmp_591 != 0;
    assume Tmp_591 > 0;
    call {:si_unique_call 791} MoxaLogError(PDrvObj, pDevObj, Tmp_591, Tmp_592, 0, 0, 0, 19, 0, -1073348600, 0, 0, 0, 0);
    status_15 := -1073741670;
    goto L94;

  anon35_Then:
    assume {:nonnull} Tmp_587 != 0;
    assume Tmp_587 > 0;
    assume {:nonnull} Tmp_587 != 0;
    assume Tmp_587 > 0;
    assume {:nonnull} Tmp_587 != 0;
    assume Tmp_587 > 0;
    assume {:nonnull} Tmp_587 != 0;
    assume Tmp_587 > 0;
    assume {:nonnull} Tmp_587 != 0;
    assume Tmp_587 > 0;
    assume {:nonnull} Tmp_593 != 0;
    assume Tmp_593 > 0;
    assume {:nonnull} Tmp_593 != 0;
    assume Tmp_593 > 0;
    assume {:nonnull} Tmp_593 != 0;
    assume Tmp_593 > 0;
    assume {:nonnull} Tmp_593 != 0;
    assume Tmp_593 > 0;
    assume {:nonnull} Tmp_593 != 0;
    assume Tmp_593 > 0;
    call {:si_unique_call 792} MoxaLogError(PDrvObj, pDevObj, Tmp_593, Tmp_587, 0, 0, 0, 19, 0, -1073348600, 0, 0, 0, 0);
    status_15 := -1073741670;
    goto L94;

  anon34_Then:
    assume {:nonnull} Tmp_577 != 0;
    assume Tmp_577 > 0;
    assume {:nonnull} Tmp_577 != 0;
    assume Tmp_577 > 0;
    assume {:nonnull} Tmp_577 != 0;
    assume Tmp_577 > 0;
    assume {:nonnull} Tmp_577 != 0;
    assume Tmp_577 > 0;
    assume {:nonnull} Tmp_577 != 0;
    assume Tmp_577 > 0;
    assume {:nonnull} Tmp_581 != 0;
    assume Tmp_581 > 0;
    assume {:nonnull} Tmp_581 != 0;
    assume Tmp_581 > 0;
    assume {:nonnull} Tmp_581 != 0;
    assume Tmp_581 > 0;
    assume {:nonnull} Tmp_581 != 0;
    assume Tmp_581 > 0;
    assume {:nonnull} Tmp_581 != 0;
    assume Tmp_581 > 0;
    call {:si_unique_call 793} MoxaLogError(PDrvObj, pDevObj, Tmp_581, Tmp_577, 0, 0, 0, 19, 0, -1073348600, 0, 0, 0, 0);
    status_15 := -1073741670;
    goto L94;
}



procedure {:origName "_sdv_init5"} _sdv_init5();
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init5"} _sdv_init5()
{
  var vslice_dummy_var_109: int;

  anon0:
    call {:si_unique_call 794} vslice_dummy_var_109 := __HAVOC_malloc(4);
    havoc Mem_T.INT4;
    return;
}



procedure {:origName "MoxaStartDevice"} MoxaStartDevice(actual_PDevObj_5: int, actual_PIrp_3: int) returns (Tmp_606: int);
  modifies alloc, Mem_T.INT4, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartDevice"} MoxaStartDevice(actual_PDevObj_5: int, actual_PIrp_3: int) returns (Tmp_606: int)
{
  var {:pointer} pDevExt_4: int;
  var {:pointer} pStartEvent: int;
  var {:pointer} sdv_180: int;
  var {:pointer} pLowerDevObj_2: int;
  var {:scalar} status_16: int;
  var {:pointer} PDevObj_5: int;
  var {:pointer} PIrp_3: int;
  var vslice_dummy_var_110: int;
  var vslice_dummy_var_111: int;

  anon0:
    PDevObj_5 := actual_PDevObj_5;
    PIrp_3 := actual_PIrp_3;
    call {:si_unique_call 795} vslice_dummy_var_110 := sdv_IoGetCurrentIrpStackLocation(PIrp_3);
    status_16 := -1073741822;
    assume {:nonnull} PDevObj_5 != 0;
    assume PDevObj_5 > 0;
    havoc pDevExt_4;
    assume {:nonnull} pDevExt_4 != 0;
    assume pDevExt_4 > 0;
    havoc pLowerDevObj_2;
    call {:si_unique_call 796} sdv_180 := ExAllocatePoolWithTag(0, 16, -261523379);
    pStartEvent := sdv_180;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} pStartEvent != 0;
    call {:si_unique_call 797} KeInitializeEvent(pStartEvent, 1, 0);
    call {:si_unique_call 798} KeInitializeEvent(pStartEvent, 1, 0);
    call {:si_unique_call 799} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_3);
    call {:si_unique_call 800} sdv_IoSetCompletionRoutine(PIrp_3, li2bplFunctionConstant232, pStartEvent, 1, 1, 1);
    call {:si_unique_call 801} status_16 := sdv_IoCallDriver(pLowerDevObj_2, PIrp_3);
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} status_16 == 259;
    call {:si_unique_call 802} vslice_dummy_var_111 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    assume {:nonnull} PIrp_3 != 0;
    assume PIrp_3 > 0;
    havoc status_16;
    goto L38;

  L38:
    call {:si_unique_call 803} sdv_ExFreePool(0);
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} status_16 >= 0;
    call {:si_unique_call 804} status_16 := MoxaFinishStartDevice(PDevObj_5);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    Tmp_606 := status_16;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon10_Then:
    assume {:partition} 0 > status_16;
    Tmp_606 := status_16;
    goto L1;

  anon9_Then:
    assume {:partition} status_16 != 259;
    goto L38;

  anon11_Then:
    assume {:partition} pStartEvent == 0;
    assume {:nonnull} PIrp_3 != 0;
    assume PIrp_3 > 0;
    call {:si_unique_call 805} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 806} MoxaIRPEpilogue(pDevExt_4);
    Tmp_606 := -1073741670;
    goto L1;
}



procedure {:origName "MoxaPnpDispatch"} MoxaPnpDispatch(actual_PDevObj_6: int, actual_PIrp_4: int) returns (Tmp_608: int);
  modifies alloc, Mem_T.INT4, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaPnpDispatch"} MoxaPnpDispatch(actual_PDevObj_6: int, actual_PIrp_4: int) returns (Tmp_608: int)
{
  var {:pointer} Tmp_609: int;
  var {:scalar} pendingIRPs: int;
  var {:scalar} Tmp_610: int;
  var {:scalar} pendingIRPs_1: int;
  var {:pointer} pDevExt_5: int;
  var {:pointer} Tmp_611: int;
  var {:pointer} Tmp_612: int;
  var {:scalar} cap: int;
  var {:pointer} sdv_194: int;
  var {:scalar} Tmp_613: int;
  var {:scalar} pendingIRPs_2: int;
  var {:pointer} pQueryCapsEvent: int;
  var {:pointer} pIrpStack_4: int;
  var {:scalar} sdv_201: int;
  var {:pointer} pLowerDevObj_3: int;
  var {:pointer} pDevCaps: int;
  var {:scalar} sdv_206: int;
  var {:scalar} status_17: int;
  var {:scalar} sdv_207: int;
  var {:pointer} Tmp_614: int;
  var {:pointer} Tmp_615: int;
  var {:pointer} PDevObj_6: int;
  var {:pointer} PIrp_4: int;
  var vslice_dummy_var_112: int;
  var vslice_dummy_var_113: int;
  var vslice_dummy_var_114: int;
  var vslice_dummy_var_115: int;
  var vslice_dummy_var_116: int;
  var vslice_dummy_var_117: int;
  var vslice_dummy_var_118: int;
  var vslice_dummy_var_119: int;
  var vslice_dummy_var_120: int;
  var vslice_dummy_var_1283: int;
  var vslice_dummy_var_1284: int;
  var vslice_dummy_var_1285: int;
  var vslice_dummy_var_1286: int;
  var vslice_dummy_var_1287: int;
  var vslice_dummy_var_1288: int;
  var vslice_dummy_var_1289: int;

  anon0:
    PDevObj_6 := actual_PDevObj_6;
    PIrp_4 := actual_PIrp_4;
    call {:si_unique_call 807} Tmp_611 := __HAVOC_malloc(28);
    call {:si_unique_call 808} Tmp_612 := __HAVOC_malloc(28);
    call {:si_unique_call 809} Tmp_614 := __HAVOC_malloc(28);
    call {:si_unique_call 810} Tmp_615 := __HAVOC_malloc(28);
    assume {:nonnull} PDevObj_6 != 0;
    assume PDevObj_6 > 0;
    havoc pDevExt_5;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc pLowerDevObj_3;
    call {:si_unique_call 811} pIrpStack_4 := sdv_IoGetCurrentIrpStackLocation(PIrp_4);
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    status_17 := -1073741536;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    call {:si_unique_call 812} sdv_IoCompleteRequest(0, 0);
    Tmp_608 := status_17;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon81_Then:
    call {:si_unique_call 813} status_17 := MoxaIRPPrologue(PIrp_4, pDevExt_5);
    goto anon101_Then, anon101_Else;

  anon101_Else:
    assume {:partition} yogi_error != 1;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    assume {:partition} status_17 != 0;
    call {:si_unique_call 814} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 815} MoxaIRPEpilogue(pDevExt_5);
    Tmp_608 := status_17;
    goto L1;

  anon82_Then:
    assume {:partition} status_17 == 0;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 0;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon98_Then, anon98_Else;

  anon98_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 1;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon97_Then, anon97_Else;

  anon97_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 2;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon96_Then, anon96_Else;

  anon96_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 3;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon95_Then, anon95_Else;

  anon95_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 4;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon94_Then, anon94_Else;

  anon94_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 6;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon93_Then, anon93_Else;

  anon93_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 7;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon92_Then, anon92_Else;

  anon92_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 9;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon91_Then, anon91_Else;

  anon91_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 20;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon90_Then, anon90_Else;

  anon90_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] != 23;
    goto L151;

  L151:
    call {:si_unique_call 816} sdv_IoSkipCurrentIrpStackLocation(PIrp_4);
    call {:si_unique_call 817} status_17 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    Tmp_608 := status_17;
    goto L1;

  anon90_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 23;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 818} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 8, 1);
    goto anon117_Then, anon117_Else;

  anon117_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 819} MoxaKillPendingIrps(PDevObj_6);
    goto anon118_Then, anon118_Else;

  anon118_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 820} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1283;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1283;
    call {:si_unique_call 821} vslice_dummy_var_119 := sdv_InterlockedDecrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 822} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1284;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1284;
    call {:si_unique_call 823} sdv_201 := sdv_InterlockedDecrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    pendingIRPs := sdv_201;
    goto anon119_Then, anon119_Else;

  anon119_Else:
    assume {:partition} pendingIRPs != 0;
    call {:si_unique_call 824} vslice_dummy_var_112 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L61;

  L61:
    call {:si_unique_call 825} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1285;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1285;
    call {:si_unique_call 826} vslice_dummy_var_120 := sdv_InterlockedIncrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 827} MoxaDisableInterfacesResources(PDevObj_6, 0);
    goto anon120_Then, anon120_Else;

  anon120_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 828} sdv_IoSkipCurrentIrpStackLocation(PIrp_4);
    call {:si_unique_call 829} Tmp_608 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    goto L1;

  anon120_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon119_Then:
    assume {:partition} pendingIRPs == 0;
    goto L61;

  anon118_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon117_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon91_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 20;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_5)], 4) != 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    havoc status_17;
    goto L77;

  L77:
    call {:si_unique_call 830} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_4);
    call {:si_unique_call 831} Tmp_608 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    goto L1;

  anon86_Then:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_5)], 4) == 0;
    goto L77;

  anon92_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 9;
    call {:si_unique_call 832} sdv_194 := ExAllocatePoolWithTag(0, 16, -261523379);
    pQueryCapsEvent := sdv_194;
    goto anon115_Then, anon115_Else;

  anon115_Else:
    assume {:partition} pQueryCapsEvent != 0;
    call {:si_unique_call 833} KeInitializeEvent(pQueryCapsEvent, 1, 0);
    call {:si_unique_call 834} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_4);
    call {:si_unique_call 835} sdv_IoSetCompletionRoutine(PIrp_4, li2bplFunctionConstant232, pQueryCapsEvent, 1, 1, 1);
    call {:si_unique_call 836} status_17 := sdv_IoCallDriver(pLowerDevObj_3, PIrp_4);
    goto anon87_Then, anon87_Else;

  anon87_Else:
    assume {:partition} status_17 == 259;
    call {:si_unique_call 837} vslice_dummy_var_113 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L108;

  L108:
    call {:si_unique_call 838} sdv_ExFreePool(0);
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    havoc status_17;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon116_Then, anon116_Else;

  anon116_Else:
    goto L130;

  L130:
    call {:si_unique_call 839} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 840} MoxaIRPEpilogue(pDevExt_5);
    Tmp_608 := status_17;
    goto L1;

  anon116_Then:
    call {:si_unique_call 841} pIrpStack_4 := sdv_IoGetCurrentIrpStackLocation(PIrp_4);
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    havoc pDevCaps;
    cap := 2;
    goto L123;

  L123:
    call {:si_unique_call 842} Tmp_610, Tmp_612, cap, Tmp_613, Tmp_614 := MoxaPnpDispatch_loop_L123(Tmp_610, pDevExt_5, Tmp_612, cap, Tmp_613, pDevCaps, Tmp_614);
    goto L123_last;

  L123_last:
    assume {:CounterLoop 5} {:Counter "cap"} true;
    goto anon88_Then, anon88_Else;

  anon88_Else:
    assume {:partition} 7 > cap;
    Tmp_610 := cap;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc Tmp_612;
    Tmp_613 := cap;
    assume {:nonnull} pDevCaps != 0;
    assume pDevCaps > 0;
    havoc Tmp_614;
    assume {:nonnull} Tmp_612 != 0;
    assume Tmp_612 > 0;
    assume {:nonnull} Tmp_614 != 0;
    assume Tmp_614 > 0;
    Mem_T.INT4[Tmp_612 + Tmp_610 * 4] := Mem_T.INT4[Tmp_614 + Tmp_613 * 4];
    cap := cap + 1;
    goto anon88_Else_dummy;

  anon88_Else_dummy:
    assume false;
    return;

  anon88_Then:
    assume {:partition} cap >= 7;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc Tmp_611;
    assume {:nonnull} Tmp_611 != 0;
    assume Tmp_611 > 0;
    Mem_T.INT4[Tmp_611] := 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc Tmp_615;
    assume {:nonnull} Tmp_615 != 0;
    assume Tmp_615 > 0;
    Mem_T.INT4[Tmp_615 + 1 * 4] := 1;
    assume {:nonnull} pDevCaps != 0;
    assume pDevCaps > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    assume {:nonnull} pDevCaps != 0;
    assume pDevCaps > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    goto L130;

  anon87_Then:
    assume {:partition} status_17 != 259;
    goto L108;

  anon115_Then:
    assume {:partition} pQueryCapsEvent == 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    call {:si_unique_call 843} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 844} MoxaIRPEpilogue(pDevExt_5);
    Tmp_608 := -1073741670;
    goto L1;

  anon93_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 7;
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon100_Then, anon100_Else;

  anon100_Else:
    assume {:nonnull} pIrpStack_4 != 0;
    assume pIrpStack_4 > 0;
    goto anon99_Then, anon99_Else;

  anon99_Else:
    goto L151;

  anon99_Then:
    goto L151;

  anon100_Then:
    goto L151;

  anon85_Then:
    goto L151;

  anon94_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 6;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    goto anon84_Then, anon84_Else;

  anon84_Else:
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 845} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 2, 0);
    goto anon114_Then, anon114_Else;

  anon114_Else:
    assume {:partition} yogi_error != 1;
    goto L159;

  L159:
    call {:si_unique_call 846} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_4);
    call {:si_unique_call 847} Tmp_608 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    goto L1;

  anon114_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon84_Then:
    goto L159;

  anon95_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 4;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 848} MoxaSetDeviceFlags(pDevExt_5, Flags__MOXA_DEVICE_EXTENSION(pDevExt_5), 2, 1);
    goto anon109_Then, anon109_Else;

  anon109_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 849} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 4, 1);
    goto anon110_Then, anon110_Else;

  anon110_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 850} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 2, 0);
    goto anon111_Then, anon111_Else;

  anon111_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 851} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1286;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1286;
    call {:si_unique_call 852} vslice_dummy_var_117 := sdv_InterlockedDecrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 853} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1287;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1287;
    call {:si_unique_call 854} sdv_206 := sdv_InterlockedDecrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    pendingIRPs_2 := sdv_206;
    goto anon112_Then, anon112_Else;

  anon112_Else:
    assume {:partition} pendingIRPs_2 != 0;
    call {:si_unique_call 855} vslice_dummy_var_114 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L189;

  L189:
    call {:si_unique_call 856} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1288;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1288;
    call {:si_unique_call 857} vslice_dummy_var_118 := sdv_InterlockedIncrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 858} MoxaReleaseResources(pDevExt_5);
    goto anon113_Then, anon113_Else;

  anon113_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 859} sdv_IoSkipCurrentIrpStackLocation(PIrp_4);
    call {:si_unique_call 860} Tmp_608 := sdv_IoCallDriver(pLowerDevObj_3, PIrp_4);
    goto L1;

  anon113_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon112_Then:
    assume {:partition} pendingIRPs_2 == 0;
    goto L189;

  anon111_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon110_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon109_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon96_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 3;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 861} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 1, 0);
    goto anon108_Then, anon108_Else;

  anon108_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 862} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_4);
    call {:si_unique_call 863} Tmp_608 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    goto L1;

  anon108_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon97_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 2;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 864} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 1, 1);
    goto anon104_Then, anon104_Else;

  anon104_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 865} MoxaKillPendingIrps(PDevObj_6);
    goto anon105_Then, anon105_Else;

  anon105_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 866} sdv_IoCopyCurrentIrpStackLocationToNext(PIrp_4);
    call {:si_unique_call 867} status_17 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    call {:si_unique_call 868} Tmp_609 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    havoc vslice_dummy_var_1289;
    Mem_T.INT4[Tmp_609] := vslice_dummy_var_1289;
    call {:si_unique_call 869} sdv_207 := sdv_InterlockedDecrement(Tmp_609);
    assume {:nonnull} Tmp_609 != 0;
    assume Tmp_609 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    pendingIRPs_1 := sdv_207;
    goto anon106_Then, anon106_Else;

  anon106_Else:
    assume {:partition} pendingIRPs_1 != 0;
    call {:si_unique_call 870} vslice_dummy_var_116 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L234;

  L234:
    call {:si_unique_call 871} vslice_dummy_var_115 := MoxaRemoveDevObj(PDevObj_6);
    goto anon107_Then, anon107_Else;

  anon107_Else:
    assume {:partition} yogi_error != 1;
    Tmp_608 := status_17;
    goto L1;

  anon107_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon106_Then:
    assume {:partition} pendingIRPs_1 == 0;
    goto L234;

  anon105_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon104_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon98_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 1;
    call {:si_unique_call 872} ExAcquireFastMutex(0);
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    goto anon89_Then, anon89_Else;

  anon89_Else:
    call {:si_unique_call 873} ExReleaseFastMutex(0);
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    havoc status_17;
    call {:si_unique_call 874} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 875} MoxaIRPEpilogue(pDevExt_5);
    Tmp_608 := status_17;
    goto L1;

  anon89_Then:
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    assume {:nonnull} pDevExt_5 != 0;
    assume pDevExt_5 > 0;
    call {:si_unique_call 876} MoxaSetDeviceFlags(pDevExt_5, DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_5), 1, 1);
    goto anon103_Then, anon103_Else;

  anon103_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 877} ExReleaseFastMutex(0);
    call {:si_unique_call 878} sdv_IoSkipCurrentIrpStackLocation(PIrp_4);
    call {:si_unique_call 879} Tmp_608 := MoxaIoCallDriver(pDevExt_5, pLowerDevObj_3, PIrp_4);
    goto L1;

  anon103_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon83_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(pIrpStack_4)] == 0;
    call {:si_unique_call 880} status_17 := MoxaStartDevice(PDevObj_6, PIrp_4);
    goto anon102_Then, anon102_Else;

  anon102_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} PIrp_4 != 0;
    assume PIrp_4 > 0;
    call {:si_unique_call 881} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 882} MoxaIRPEpilogue(pDevExt_5);
    Tmp_608 := status_17;
    goto L1;

  anon102_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon101_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaSyncCompletion"} MoxaSyncCompletion(actual_DeviceObject_10: int, actual_Irp_10: int, actual_MoxaSyncEventIn: int) returns (Tmp_616: int);
  free ensures {:va_keep} Tmp_616 == -1073741802;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSyncCompletion"} MoxaSyncCompletion(actual_DeviceObject_10: int, actual_Irp_10: int, actual_MoxaSyncEventIn: int) returns (Tmp_616: int)
{
  var {:pointer} MoxaSyncEvent: int;
  var {:pointer} MoxaSyncEventIn: int;
  var vslice_dummy_var_121: int;

  anon0:
    MoxaSyncEventIn := actual_MoxaSyncEventIn;
    MoxaSyncEvent := MoxaSyncEventIn;
    call {:si_unique_call 883} vslice_dummy_var_121 := KeSetEvent(MoxaSyncEvent, 0, 0);
    Tmp_616 := -1073741802;
    return;
}



procedure {:origName "MoxaDisableInterfacesResources"} MoxaDisableInterfacesResources(actual_PDevObj_7: int, actual_DisableUART: int);
  modifies alloc, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDisableInterfacesResources"} MoxaDisableInterfacesResources(actual_PDevObj_7: int, actual_DisableUART: int)
{
  var {:pointer} pDevExt_6: int;
  var {:pointer} PDevObj_7: int;
  var vslice_dummy_var_122: int;
  var vslice_dummy_var_123: int;

  anon0:
    call {:si_unique_call 884} vslice_dummy_var_122 := __HAVOC_malloc(4);
    PDevObj_7 := actual_PDevObj_7;
    assume {:nonnull} PDevObj_7 != 0;
    assume PDevObj_7 > 0;
    havoc pDevExt_6;
    assume {:nonnull} pDevExt_6 != 0;
    assume pDevExt_6 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_6)], 2) != 0;
    goto L7;

  L7:
    call {:si_unique_call 885} vslice_dummy_var_123 := IoWMIRegistrationControl(0, 2);
    call {:si_unique_call 886} MoxaUndoExternalNaming(pDevExt_6);
    goto LM2;

  LM2:
    return;

  anon5_Then:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(pDevExt_6)], 2) == 0;
    call {:si_unique_call 887} MoxaReleaseResources(pDevExt_6);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto L7;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaFuncWithLock"} MoxaFuncWithLock(actual_Extension_14: int, actual_Command: int, actual_Argument: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFuncWithLock"} MoxaFuncWithLock(actual_Extension_14: int, actual_Command: int, actual_Argument: int)
{
  var {:pointer} Tmp_620: int;
  var {:pointer} ofs_11: int;
  var {:scalar} oldIrql_16: int;
  var {:pointer} Tmp_622: int;
  var {:pointer} Extension_14: int;
  var {:scalar} Command: int;
  var {:scalar} Argument: int;
  var vslice_dummy_var_124: int;
  var vslice_dummy_var_125: int;

  anon0:
    call {:si_unique_call 888} vslice_dummy_var_124 := __HAVOC_malloc(4);
    Extension_14 := actual_Extension_14;
    Command := actual_Command;
    Argument := actual_Argument;
    call {:si_unique_call 889} Tmp_622 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_622 != 0;
    assume Tmp_622 > 0;
    Mem_T.INT4[Tmp_622] := oldIrql_16;
    call {:si_unique_call 890} sdv_KeAcquireSpinLock(0, Tmp_622);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_622 != 0;
    assume Tmp_622 > 0;
    oldIrql_16 := Mem_T.INT4[Tmp_622];
    assume {:nonnull} Extension_14 != 0;
    assume Extension_14 > 0;
    havoc ofs_11;
    Tmp_620 := ofs_11;
    assume {:nonnull} Tmp_620 != 0;
    assume Tmp_620 > 0;
    Mem_T.INT4[Tmp_620] := Argument;
    assume {:nonnull} ofs_11 != 0;
    assume ofs_11 > 0;
    Mem_T.INT4[ofs_11] := Command;
    call {:si_unique_call 891} vslice_dummy_var_125 := MoxaWaitFinish(ofs_11);
    call {:si_unique_call 892} sdv_KeReleaseSpinLock(0, oldIrql_16);
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaFuncGetDataError"} MoxaFuncGetDataError(actual_PortOfs_2: int, actual_Argument_1: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFuncGetDataError"} MoxaFuncGetDataError(actual_PortOfs_2: int, actual_Argument_1: int)
{
  var {:pointer} Tmp_624: int;
  var {:pointer} Tmp_626: int;
  var {:pointer} PortOfs_2: int;
  var {:pointer} Argument_1: int;
  var vslice_dummy_var_126: int;

  anon0:
    call {:si_unique_call 893} vslice_dummy_var_126 := __HAVOC_malloc(4);
    PortOfs_2 := actual_PortOfs_2;
    Argument_1 := actual_Argument_1;
    Tmp_624 := PortOfs_2;
    assume {:nonnull} Argument_1 != 0;
    assume Argument_1 > 0;
    assume {:nonnull} Tmp_624 != 0;
    assume Tmp_624 > 0;
    Mem_T.INT4[Argument_1] := Mem_T.INT4[Tmp_624];
    Tmp_626 := PortOfs_2;
    assume {:nonnull} Tmp_626 != 0;
    assume Tmp_626 > 0;
    Mem_T.INT4[Tmp_626] := 0;
    return;
}



procedure {:origName "MoxaIRPPrologue"} MoxaIRPPrologue(actual_PIrp_5: int, actual_PDevExt_4: int) returns (Tmp_627: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIRPPrologue"} MoxaIRPPrologue(actual_PIrp_5: int, actual_PDevExt_4: int) returns (Tmp_627: int)
{
  var {:pointer} Tmp_628: int;
  var {:pointer} PIrp_5: int;
  var {:pointer} PDevExt_4: int;
  var vslice_dummy_var_127: int;
  var vslice_dummy_var_1290: int;

  anon0:
    PIrp_5 := actual_PIrp_5;
    PDevExt_4 := actual_PDevExt_4;
    call {:si_unique_call 894} Tmp_628 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_4 != 0;
    assume PDevExt_4 > 0;
    assume {:nonnull} Tmp_628 != 0;
    assume Tmp_628 > 0;
    havoc vslice_dummy_var_1290;
    Mem_T.INT4[Tmp_628] := vslice_dummy_var_1290;
    call {:si_unique_call 895} vslice_dummy_var_127 := sdv_InterlockedIncrement(Tmp_628);
    assume {:nonnull} PDevExt_4 != 0;
    assume PDevExt_4 > 0;
    assume {:nonnull} Tmp_628 != 0;
    assume Tmp_628 > 0;
    call {:si_unique_call 896} Tmp_627 := MoxaFilterIrps(PIrp_5, PDevExt_4);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaFuncGetLineStatus"} MoxaFuncGetLineStatus(actual_PortOfs_3: int, actual_Argument_2: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFuncGetLineStatus"} MoxaFuncGetLineStatus(actual_PortOfs_3: int, actual_Argument_2: int)
{
  var {:pointer} PortOfs_3: int;
  var {:pointer} Argument_2: int;
  var boogieTmp: int;
  var vslice_dummy_var_128: int;

  anon0:
    call {:si_unique_call 897} vslice_dummy_var_128 := __HAVOC_malloc(4);
    PortOfs_3 := actual_PortOfs_3;
    Argument_2 := actual_Argument_2;
    assume {:nonnull} Argument_2 != 0;
    assume Argument_2 > 0;
    call {:si_unique_call 898} boogieTmp := corral_nondet();
    Mem_T.INT4[Argument_2] := boogieTmp;
    return;
}



procedure {:origName "MoxaWaitFinish1"} MoxaWaitFinish1(actual_PortOfs_4: int) returns (Tmp_632: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_632 == 1 || Tmp_632 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaWaitFinish1"} MoxaWaitFinish1(actual_PortOfs_4: int) returns (Tmp_632: int)
{
  var {:scalar} cnt: int;
  var {:scalar} Tmp_634: int;
  var {:pointer} PortOfs_4: int;

  anon0:
    PortOfs_4 := actual_PortOfs_4;
    cnt := 250;
    goto L5;

  L5:
    call {:si_unique_call 899} cnt, Tmp_634 := MoxaWaitFinish1_loop_L5(cnt, Tmp_634, PortOfs_4);
    goto L5_last;

  L5_last:
    Tmp_634 := cnt;
    cnt := cnt - 1;
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} Tmp_634 != 0;
    assume {:nonnull} PortOfs_4 != 0;
    assume PortOfs_4 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} Mem_T.INT4[PortOfs_4] != 0;
    call {:si_unique_call 900} MoxaDelay(1);
    goto anon5_Else_dummy;

  anon5_Else_dummy:
    assume false;
    return;

  anon5_Then:
    assume {:partition} Mem_T.INT4[PortOfs_4] == 0;
    Tmp_632 := 1;
    goto L1;

  L1:
    return;

  anon6_Then:
    assume {:partition} Tmp_634 == 0;
    Tmp_632 := 0;
    goto L1;
}



procedure {:origName "MoxaIoSyncReq"} MoxaIoSyncReq(actual_PDevObj_8: int, actual_PIrp_6: int, actual_PEvent: int) returns (Tmp_635: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_635 == 258 || Tmp_635 == 0 || Tmp_635 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIoSyncReq"} MoxaIoSyncReq(actual_PDevObj_8: int, actual_PIrp_6: int, actual_PEvent: int) returns (Tmp_635: int)
{
  var {:scalar} status_18: int;
  var {:pointer} PDevObj_8: int;
  var {:pointer} PIrp_6: int;

  anon0:
    PDevObj_8 := actual_PDevObj_8;
    PIrp_6 := actual_PIrp_6;
    call {:si_unique_call 901} status_18 := sdv_IoCallDriver(PDevObj_8, PIrp_6);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} status_18 == 259;
    call {:si_unique_call 902} status_18 := KeWaitForSingleObject(0, 0, 0, 0, 0);
    goto L9;

  L9:
    Tmp_635 := status_18;
    return;

  anon3_Then:
    assume {:partition} status_18 != 259;
    goto L9;
}



procedure {:origName "MoxaTryToCompleteCurrent"} MoxaTryToCompleteCurrent(actual_Extension_15: int, actual_SynchRoutine: int, actual_IrqlForRelease: int, actual_StatusToUse: int, actual_CurrentOpIrp_1: int, actual_QueueToProcess_1: int, actual_IntervalTimer: int, actual_TotalTimer: int, actual_Starter: int, actual_GetNextIrp: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_5) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaTryToCompleteCurrent"} MoxaTryToCompleteCurrent(actual_Extension_15: int, actual_SynchRoutine: int, actual_IrqlForRelease: int, actual_StatusToUse: int, actual_CurrentOpIrp_1: int, actual_QueueToProcess_1: int, actual_IntervalTimer: int, actual_TotalTimer: int, actual_Starter: int, actual_GetNextIrp: int)
{
  var {:pointer} sdv_217: int;
  var {:pointer} newIrp_4: int;
  var {:pointer} Tmp_637: int;
  var {:pointer} Tmp_639: int;
  var {:pointer} Tmp_640: int;
  var {:pointer} sdv_219: int;
  var {:pointer} Extension_15: int;
  var {:scalar} SynchRoutine: int;
  var {:scalar} IrqlForRelease: int;
  var {:scalar} StatusToUse: int;
  var {:pointer} CurrentOpIrp_1: int;
  var {:pointer} QueueToProcess_1: int;
  var {:pointer} IntervalTimer: int;
  var {:pointer} TotalTimer: int;
  var {:scalar} Starter: int;
  var {:scalar} GetNextIrp: int;
  var vslice_dummy_var_129: int;
  var vslice_dummy_var_130: int;
  var vslice_dummy_var_131: int;
  var vslice_dummy_var_132: int;
  var vslice_dummy_var_1291: int;
  var vslice_dummy_var_1292: int;

  anon0:
    call {:si_unique_call 903} newIrp_4 := __HAVOC_malloc(4);
    call {:si_unique_call 904} vslice_dummy_var_129 := __HAVOC_malloc(4);
    Extension_15 := actual_Extension_15;
    SynchRoutine := actual_SynchRoutine;
    IrqlForRelease := actual_IrqlForRelease;
    StatusToUse := actual_StatusToUse;
    CurrentOpIrp_1 := actual_CurrentOpIrp_1;
    QueueToProcess_1 := actual_QueueToProcess_1;
    IntervalTimer := actual_IntervalTimer;
    TotalTimer := actual_TotalTimer;
    Starter := actual_Starter;
    GetNextIrp := actual_GetNextIrp;
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    havoc vslice_dummy_var_1291;
    call {:si_unique_call 905} sdv_217 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1291);
    assume {:nonnull} sdv_217 != 0;
    assume sdv_217 > 0;
    Tmp_640 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_217)));
    assume {:nonnull} sdv_217 != 0;
    assume sdv_217 > 0;
    assume {:nonnull} Tmp_640 != 0;
    assume Tmp_640 > 0;
    assume {:nonnull} sdv_217 != 0;
    assume sdv_217 > 0;
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} SynchRoutine != 0;
    call {:si_unique_call 906} vslice_dummy_var_130 := KeSynchronizeExecution(0, SynchRoutine, 0);
    goto L12;

  L12:
    call {:si_unique_call 907} MoxaRundownIrpRefs(CurrentOpIrp_1, IntervalTimer, TotalTimer, Extension_15);
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    havoc vslice_dummy_var_1292;
    call {:si_unique_call 908} sdv_219 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1292);
    assume {:nonnull} sdv_219 != 0;
    assume sdv_219 > 0;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    havoc Tmp_637;
    assume {:nonnull} Tmp_637 != 0;
    assume Tmp_637 > 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    assume {:partition} StatusToUse == -1073741536;
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    havoc Tmp_639;
    assume {:nonnull} Tmp_639 != 0;
    assume Tmp_639 > 0;
    goto L28;

  L28:
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    assume {:nonnull} CurrentOpIrp_1 != 0;
    assume CurrentOpIrp_1 > 0;
    call {:si_unique_call 909} IoReleaseCancelSpinLock(IrqlForRelease);
    call {:si_unique_call 910} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 911} MoxaIRPEpilogue(Extension_15);
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon25_Then:
    call {:si_unique_call 912} IoReleaseCancelSpinLock(IrqlForRelease);
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:IndirectCall} true;
    assume GetNextIrp == li2bplFunctionConstant148;
    call {:si_unique_call 913} MoxaGetNextIrp(CurrentOpIrp_1, QueueToProcess_1, newIrp_4, 1, Extension_15);
    goto L37;

  L37:
    assume {:nonnull} newIrp_4 != 0;
    assume newIrp_4 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:IndirectCall} true;
    assume Starter == li2bplFunctionConstant140;
    call {:si_unique_call 914} vslice_dummy_var_132 := MoxaStartRead(Extension_15);
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon33_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon28_Then:
    assume {:IndirectCall} true;
    assume Starter == li2bplFunctionConstant318;
    call {:si_unique_call 915} vslice_dummy_var_131 := MoxaStartWrite(Extension_15);
    goto anon32_Then, anon32_Else;

  anon32_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon32_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon27_Then:
    goto L1;

  anon26_Then:
    assume {:IndirectCall} true;
    assume GetNextIrp == li2bplFunctionConstant323;
    call {:si_unique_call 916} MoxaGetNextWrite(CurrentOpIrp_1, QueueToProcess_1, newIrp_4, 1, Extension_15);
    goto L37;

  anon31_Then:
    assume {:partition} StatusToUse != -1073741536;
    goto L28;

  anon24_Then:
    call {:si_unique_call 917} IoReleaseCancelSpinLock(IrqlForRelease);
    goto L1;

  anon30_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon29_Then:
    assume {:partition} SynchRoutine == 0;
    goto L12;

  anon23_Then:
    call {:si_unique_call 918} IoReleaseCancelSpinLock(IrqlForRelease);
    goto L1;
}



procedure {:origName "MoxaUnstallIrps"} MoxaUnstallIrps(actual_PDevExt_5: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaUnstallIrps"} MoxaUnstallIrps(actual_PDevExt_5: int)
{
  var {:pointer} Tmp_643: int;
  var {:pointer} sdv_221: int;
  var {:scalar} Tmp_645: int;
  var {:scalar} oldIrql_17: int;
  var {:pointer} pIrpStack_5: int;
  var {:pointer} Tmp_646: int;
  var {:pointer} pIrp: int;
  var {:pointer} pDevObj_1: int;
  var {:pointer} pDrvObj: int;
  var {:pointer} pIrpLink: int;
  var {:pointer} PDevExt_5: int;
  var vslice_dummy_var_133: int;
  var vslice_dummy_var_134: int;
  var vslice_dummy_var_135: int;

  anon0:
    call {:si_unique_call 919} vslice_dummy_var_133 := __HAVOC_malloc(4);
    PDevExt_5 := actual_PDevExt_5;
    call {:si_unique_call 920} Tmp_643 := __HAVOC_malloc(112);
    call {:si_unique_call 921} Tmp_646 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_646 != 0;
    assume Tmp_646 > 0;
    Mem_T.INT4[Tmp_646] := oldIrql_17;
    call {:si_unique_call 922} IoAcquireCancelSpinLock(Tmp_646);
    assume {:nonnull} Tmp_646 != 0;
    assume Tmp_646 > 0;
    oldIrql_17 := Mem_T.INT4[Tmp_646];
    assume {:nonnull} PDevExt_5 != 0;
    assume PDevExt_5 > 0;
    havoc pIrpLink;
    goto L13;

  L13:
    call {:si_unique_call 923} Tmp_643, sdv_221, Tmp_645, oldIrql_17, pIrpStack_5, Tmp_646, pIrp, pDevObj_1, pDrvObj, pIrpLink, vslice_dummy_var_134, vslice_dummy_var_135 := MoxaUnstallIrps_loop_L13(Tmp_643, sdv_221, Tmp_645, oldIrql_17, pIrpStack_5, Tmp_646, pIrp, pDevObj_1, pDrvObj, pIrpLink, vslice_dummy_var_134, vslice_dummy_var_135);
    goto L13_last;

  L13_last:
    goto anon59_Then, anon59_Else;

  anon59_Else:
    call {:si_unique_call 924} sdv_221 := sdv_containing_record(pIrpLink, 88);
    pIrp := sdv_221;
    assume {:nonnull} pIrp != 0;
    assume pIrp > 0;
    havoc pIrpLink;
    call {:si_unique_call 925} vslice_dummy_var_134 := sdv_RemoveEntryList(0);
    call {:si_unique_call 926} pIrpStack_5 := sdv_IoGetCurrentIrpStackLocation(pIrp);
    assume {:nonnull} pIrpStack_5 != 0;
    assume pIrpStack_5 > 0;
    havoc pDevObj_1;
    assume {:nonnull} pDevObj_1 != 0;
    assume pDevObj_1 > 0;
    havoc pDrvObj;
    call {:si_unique_call 927} vslice_dummy_var_135 := sdv_IoSetCancelRoutine(pIrp, 0);
    call {:si_unique_call 928} IoReleaseCancelSpinLock(oldIrql_17);
    assume {:nonnull} pIrpStack_5 != 0;
    assume pIrpStack_5 > 0;
    havoc Tmp_645;
    assume {:nonnull} pDrvObj != 0;
    assume pDrvObj > 0;
    havoc Tmp_643;
    goto anon60_Then, anon60_Else;

  anon60_Else:
    assume Tmp_645 != 27;
    goto anon61_Then, anon61_Else;

  anon61_Else:
    assume Tmp_645 != 26;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    assume Tmp_645 != 25;
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume Tmp_645 != 24;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    assume Tmp_645 != 23;
    goto anon65_Then, anon65_Else;

  anon65_Else:
    assume Tmp_645 != 22;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume Tmp_645 != 21;
    goto anon67_Then, anon67_Else;

  anon67_Else:
    assume Tmp_645 != 20;
    goto anon68_Then, anon68_Else;

  anon68_Else:
    assume Tmp_645 != 19;
    goto anon69_Then, anon69_Else;

  anon69_Else:
    assume Tmp_645 != 18;
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume Tmp_645 != 17;
    goto anon71_Then, anon71_Else;

  anon71_Else:
    assume Tmp_645 != 16;
    goto anon72_Then, anon72_Else;

  anon72_Else:
    assume Tmp_645 != 15;
    goto anon73_Then, anon73_Else;

  anon73_Else:
    assume Tmp_645 != 14;
    goto anon74_Then, anon74_Else;

  anon74_Else:
    assume Tmp_645 != 13;
    goto anon75_Then, anon75_Else;

  anon75_Else:
    assume Tmp_645 != 12;
    goto anon76_Then, anon76_Else;

  anon76_Else:
    assume Tmp_645 != 11;
    goto anon77_Then, anon77_Else;

  anon77_Else:
    assume Tmp_645 != 10;
    goto anon78_Then, anon78_Else;

  anon78_Else:
    assume Tmp_645 != 9;
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume Tmp_645 != 8;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    assume Tmp_645 != 7;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    assume Tmp_645 != 6;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    assume Tmp_645 != 5;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    assume Tmp_645 != 4;
    goto anon84_Then, anon84_Else;

  anon84_Else:
    assume Tmp_645 != 3;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume Tmp_645 != 2;
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume Tmp_645 != 1;
    goto anon87_Then, anon87_Else;

  anon87_Else:
    assume false;
    return;

  anon87_Then:
    assume Tmp_645 == 0;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643] == 0;
    goto L40;

  L40:
    call {:si_unique_call 929} Tmp_646 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_646 != 0;
    assume Tmp_646 > 0;
    Mem_T.INT4[Tmp_646] := oldIrql_17;
    call {:si_unique_call 930} IoAcquireCancelSpinLock(Tmp_646);
    assume {:nonnull} Tmp_646 != 0;
    assume Tmp_646 > 0;
    oldIrql_17 := Mem_T.INT4[Tmp_646];
    goto L40_dummy;

  L40_dummy:
    assume false;
    return;

  anon86_Then:
    assume Tmp_645 == 1;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 1 * 4] == 0;
    goto L40;

  anon85_Then:
    assume Tmp_645 == 2;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 2 * 4] == 0;
    goto L40;

  anon84_Then:
    assume Tmp_645 == 3;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 3 * 4] == 0;
    goto L40;

  anon83_Then:
    assume Tmp_645 == 4;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 4 * 4] == 0;
    goto L40;

  anon82_Then:
    assume Tmp_645 == 5;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 5 * 4] == 0;
    goto L40;

  anon81_Then:
    assume Tmp_645 == 6;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 6 * 4] == 0;
    goto L40;

  anon80_Then:
    assume Tmp_645 == 7;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 7 * 4] == 0;
    goto L40;

  anon79_Then:
    assume Tmp_645 == 8;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 8 * 4] == 0;
    goto L40;

  anon78_Then:
    assume Tmp_645 == 9;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 9 * 4] == 0;
    goto L40;

  anon77_Then:
    assume Tmp_645 == 10;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 10 * 4] == 0;
    goto L40;

  anon76_Then:
    assume Tmp_645 == 11;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 11 * 4] == 0;
    goto L40;

  anon75_Then:
    assume Tmp_645 == 12;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 12 * 4] == 0;
    goto L40;

  anon74_Then:
    assume Tmp_645 == 13;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 13 * 4] == 0;
    goto L40;

  anon73_Then:
    assume Tmp_645 == 14;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 14 * 4] == 0;
    goto L40;

  anon72_Then:
    assume Tmp_645 == 15;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 15 * 4] == 0;
    goto L40;

  anon71_Then:
    assume Tmp_645 == 16;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 16 * 4] == 0;
    goto L40;

  anon70_Then:
    assume Tmp_645 == 17;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 17 * 4] == 0;
    goto L40;

  anon69_Then:
    assume Tmp_645 == 18;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 18 * 4] == 0;
    goto L40;

  anon68_Then:
    assume Tmp_645 == 19;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 19 * 4] == 0;
    goto L40;

  anon67_Then:
    assume Tmp_645 == 20;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 20 * 4] == 0;
    goto L40;

  anon66_Then:
    assume Tmp_645 == 21;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 21 * 4] == 0;
    goto L40;

  anon65_Then:
    assume Tmp_645 == 22;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 22 * 4] == 0;
    goto L40;

  anon64_Then:
    assume Tmp_645 == 23;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 23 * 4] == 0;
    goto L40;

  anon63_Then:
    assume Tmp_645 == 24;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 24 * 4] == 0;
    goto L40;

  anon62_Then:
    assume Tmp_645 == 25;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 25 * 4] == 0;
    goto L40;

  anon61_Then:
    assume Tmp_645 == 26;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 26 * 4] == 0;
    goto L40;

  anon60_Then:
    assume Tmp_645 == 27;
    assume {:nonnull} Tmp_643 != 0;
    assume Tmp_643 > 0;
    assume Mem_T.INT4[Tmp_643 + 27 * 4] == 0;
    goto L40;

  anon59_Then:
    call {:si_unique_call 931} IoReleaseCancelSpinLock(oldIrql_17);
    return;
}



procedure {:origName "MoxaMemCompare"} MoxaMemCompare(actual_structPtr888A: int, actual_SpanOfA: int, actual_structPtr888B: int, actual_SpanOfB: int) returns (Tmp_647: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_647 == 0 || Tmp_647 == 2 || Tmp_647 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaMemCompare"} MoxaMemCompare(actual_structPtr888A: int, actual_SpanOfA: int, actual_structPtr888B: int, actual_SpanOfB: int) returns (Tmp_647: int)
{
  var {:scalar} A: int;
  var {:scalar} B: int;
  var {:scalar} b: int;
  var {:scalar} higher: int;
  var {:scalar} lowerSpan: int;
  var {:scalar} lower: int;
  var {:scalar} a: int;
  var {:pointer} structPtr888A: int;
  var {:scalar} SpanOfA: int;
  var {:pointer} structPtr888B: int;
  var {:scalar} SpanOfB: int;

  anon0:
    call {:si_unique_call 932} A := __HAVOC_malloc(20);
    call {:si_unique_call 933} B := __HAVOC_malloc(20);
    call {:si_unique_call 934} b := __HAVOC_malloc(20);
    call {:si_unique_call 935} higher := __HAVOC_malloc(20);
    call {:si_unique_call 936} lower := __HAVOC_malloc(20);
    call {:si_unique_call 937} a := __HAVOC_malloc(20);
    structPtr888A := actual_structPtr888A;
    SpanOfA := actual_SpanOfA;
    structPtr888B := actual_structPtr888B;
    SpanOfB := actual_SpanOfB;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} structPtr888A != 0;
    assume structPtr888A > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} structPtr888A != 0;
    assume structPtr888A > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} structPtr888A != 0;
    assume structPtr888A > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} structPtr888A != 0;
    assume structPtr888A > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} structPtr888A != 0;
    assume structPtr888A > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} structPtr888B != 0;
    assume structPtr888B > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} structPtr888B != 0;
    assume structPtr888B > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} structPtr888B != 0;
    assume structPtr888B > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} structPtr888B != 0;
    assume structPtr888B > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} structPtr888B != 0;
    assume structPtr888B > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} A != 0;
    assume A > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} B != 0;
    assume B > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    Tmp_647 := 0;
    goto L1;

  L1:
    return;

  anon9_Then:
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    lowerSpan := SpanOfB;
    goto L17;

  L17:
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    goto anon8_Then, anon8_Else;

  anon8_Else:
    Tmp_647 := 2;
    goto L1;

  anon8_Then:
    Tmp_647 := 1;
    goto L1;

  anon7_Then:
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} b != 0;
    assume b > 0;
    assume {:nonnull} higher != 0;
    assume higher > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    assume {:nonnull} a != 0;
    assume a > 0;
    assume {:nonnull} lower != 0;
    assume lower > 0;
    lowerSpan := SpanOfA;
    goto L17;
}



procedure {:origName "MoxaKillAllReadsOrWrites"} MoxaKillAllReadsOrWrites(actual_DeviceObject_11: int, actual_QueueToClean: int, actual_CurrentOpIrp_2: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaKillAllReadsOrWrites"} MoxaKillAllReadsOrWrites(actual_DeviceObject_11: int, actual_QueueToClean: int, actual_CurrentOpIrp_2: int)
{
  var {:pointer} Tmp_649: int;
  var {:pointer} currentLastIrp: int;
  var {:scalar} cancelIrql: int;
  var {:pointer} Tmp_651: int;
  var {:pointer} Tmp_652: int;
  var {:scalar} sdv_226: int;
  var {:pointer} Tmp_653: int;
  var {:pointer} sdv_227: int;
  var {:scalar} cancelRoutine_1: int;
  var {:pointer} Tmp_654: int;
  var {:pointer} DeviceObject_11: int;
  var {:pointer} QueueToClean: int;
  var {:pointer} CurrentOpIrp_2: int;
  var vslice_dummy_var_136: int;
  var vslice_dummy_var_137: int;
  var vslice_dummy_var_1293: int;
  var vslice_dummy_var_1294: int;
  var vslice_dummy_var_1295: int;
  var vslice_dummy_var_1296: int;
  var vslice_dummy_var_1297: int;

  anon0:
    call {:si_unique_call 938} vslice_dummy_var_136 := __HAVOC_malloc(4);
    DeviceObject_11 := actual_DeviceObject_11;
    QueueToClean := actual_QueueToClean;
    CurrentOpIrp_2 := actual_CurrentOpIrp_2;
    call {:si_unique_call 939} Tmp_654 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_654 != 0;
    assume Tmp_654 > 0;
    Mem_T.INT4[Tmp_654] := cancelIrql;
    call {:si_unique_call 940} IoAcquireCancelSpinLock(Tmp_654);
    assume {:nonnull} Tmp_654 != 0;
    assume Tmp_654 > 0;
    cancelIrql := Mem_T.INT4[Tmp_654];
    goto L8;

  L8:
    call {:si_unique_call 941} currentLastIrp, cancelIrql, sdv_226, sdv_227, cancelRoutine_1, Tmp_654, vslice_dummy_var_137 := MoxaKillAllReadsOrWrites_loop_L8(currentLastIrp, cancelIrql, sdv_226, sdv_227, cancelRoutine_1, Tmp_654, DeviceObject_11, QueueToClean, vslice_dummy_var_137);
    goto L8_last;

  L8_last:
    call {:si_unique_call 956} sdv_226 := sdv_IsListEmpty(0);
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} sdv_226 == 0;
    assume {:nonnull} QueueToClean != 0;
    assume QueueToClean > 0;
    havoc vslice_dummy_var_1293;
    call {:si_unique_call 942} sdv_227 := sdv_containing_record(vslice_dummy_var_1293, 88);
    currentLastIrp := sdv_227;
    call {:si_unique_call 943} vslice_dummy_var_137 := sdv_RemoveEntryList(0);
    assume {:nonnull} currentLastIrp != 0;
    assume currentLastIrp > 0;
    cancelRoutine_1 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(currentLastIrp)];
    assume {:nonnull} currentLastIrp != 0;
    assume currentLastIrp > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(currentLastIrp)] := cancelIrql;
    assume {:nonnull} currentLastIrp != 0;
    assume currentLastIrp > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(currentLastIrp)] := 0;
    assume {:nonnull} currentLastIrp != 0;
    assume currentLastIrp > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} cancelRoutine_1 != 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    goto anon34_Then, anon34_Else;

  anon34_Else:
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant321;
    call {:si_unique_call 944} MoxaCancelCurrentWrite(DeviceObject_11, currentLastIrp);
    goto anon42_Then, anon42_Else;

  anon42_Else:
    assume {:partition} yogi_error != 1;
    goto L43;

  L43:
    call {:si_unique_call 945} Tmp_654 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_654 != 0;
    assume Tmp_654 > 0;
    Mem_T.INT4[Tmp_654] := cancelIrql;
    call {:si_unique_call 946} IoAcquireCancelSpinLock(Tmp_654);
    assume {:nonnull} Tmp_654 != 0;
    assume Tmp_654 > 0;
    cancelIrql := Mem_T.INT4[Tmp_654];
    goto L43_dummy;

  L43_dummy:
    assume false;
    return;

  anon42_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  LM2:
    return;

  anon35_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant188;
    call {:si_unique_call 947} MoxaCancelQueued(DeviceObject_11, currentLastIrp);
    goto L43;

  anon34_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant418;
    call {:si_unique_call 948} MoxaCancelWait(DeviceObject_11, currentLastIrp);
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} yogi_error != 1;
    goto L43;

  anon41_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon31_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant202;
    call {:si_unique_call 949} MoxaFilterCancelQueued(DeviceObject_11, currentLastIrp);
    goto L43;

  anon40_Then:
    assume {:partition} cancelRoutine_1 == 0;
    goto anon40_Then_dummy;

  anon40_Then_dummy:
    assume false;
    return;

  anon29_Then:
    assume {:partition} sdv_226 != 0;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc Tmp_652;
    assume {:nonnull} Tmp_652 != 0;
    assume Tmp_652 > 0;
    cancelRoutine_1 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_652)];
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc Tmp_651;
    assume {:nonnull} Tmp_651 != 0;
    assume Tmp_651 > 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} cancelRoutine_1 != 0;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc Tmp_649;
    assume {:nonnull} Tmp_649 != 0;
    assume Tmp_649 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_649)] := 0;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc Tmp_653;
    assume {:nonnull} Tmp_653 != 0;
    assume Tmp_653 > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(Tmp_653)] := cancelIrql;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    goto anon32_Then, anon32_Else;

  anon32_Else:
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant321;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc vslice_dummy_var_1294;
    call {:si_unique_call 950} MoxaCancelCurrentWrite(DeviceObject_11, vslice_dummy_var_1294);
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  L1:
    goto LM2;

  anon39_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon33_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant188;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc vslice_dummy_var_1295;
    call {:si_unique_call 951} MoxaCancelQueued(DeviceObject_11, vslice_dummy_var_1295);
    goto L1;

  anon32_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant418;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc vslice_dummy_var_1296;
    call {:si_unique_call 952} MoxaCancelWait(DeviceObject_11, vslice_dummy_var_1296);
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon38_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon37_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_1 == li2bplFunctionConstant202;
    assume {:nonnull} CurrentOpIrp_2 != 0;
    assume CurrentOpIrp_2 > 0;
    havoc vslice_dummy_var_1297;
    call {:si_unique_call 953} MoxaFilterCancelQueued(DeviceObject_11, vslice_dummy_var_1297);
    goto L1;

  anon36_Then:
    assume {:partition} cancelRoutine_1 == 0;
    call {:si_unique_call 954} IoReleaseCancelSpinLock(cancelIrql);
    goto L1;

  anon30_Then:
    call {:si_unique_call 955} IoReleaseCancelSpinLock(cancelIrql);
    goto L1;
}



procedure {:origName "MoxaRundownIrpRefs"} MoxaRundownIrpRefs(actual_CurrentOpIrp_3: int, actual_IntervalTimer_1: int, actual_TotalTimer_1: int, actual_pDevExt_7: int);
  modifies alloc, Mem_T.CancelRoutine__IRP, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaRundownIrpRefs"} MoxaRundownIrpRefs(actual_CurrentOpIrp_3: int, actual_IntervalTimer_1: int, actual_TotalTimer_1: int, actual_pDevExt_7: int)
{
  var {:pointer} Tmp_656: int;
  var {:pointer} Tmp_657: int;
  var {:pointer} Tmp_658: int;
  var {:pointer} sdv_229: int;
  var {:pointer} sdv_230: int;
  var {:pointer} Tmp_660: int;
  var {:scalar} sdv_232: int;
  var {:pointer} sdv_233: int;
  var {:scalar} sdv_234: int;
  var {:pointer} CurrentOpIrp_3: int;
  var {:pointer} IntervalTimer_1: int;
  var {:pointer} TotalTimer_1: int;
  var {:pointer} pDevExt_7: int;
  var vslice_dummy_var_138: int;
  var vslice_dummy_var_139: int;
  var vslice_dummy_var_1298: int;
  var vslice_dummy_var_1299: int;
  var vslice_dummy_var_1300: int;
  var vslice_dummy_var_1301: int;

  anon0:
    call {:si_unique_call 957} vslice_dummy_var_138 := __HAVOC_malloc(4);
    CurrentOpIrp_3 := actual_CurrentOpIrp_3;
    IntervalTimer_1 := actual_IntervalTimer_1;
    TotalTimer_1 := actual_TotalTimer_1;
    pDevExt_7 := actual_pDevExt_7;
    assume {:nonnull} CurrentOpIrp_3 != 0;
    assume CurrentOpIrp_3 > 0;
    havoc Tmp_660;
    assume {:nonnull} Tmp_660 != 0;
    assume Tmp_660 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:partition} Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_660)] != 0;
    assume {:nonnull} CurrentOpIrp_3 != 0;
    assume CurrentOpIrp_3 > 0;
    havoc vslice_dummy_var_1298;
    call {:si_unique_call 958} sdv_229 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1298);
    assume {:nonnull} sdv_229 != 0;
    assume sdv_229 > 0;
    Tmp_657 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_229)));
    assume {:nonnull} sdv_229 != 0;
    assume sdv_229 > 0;
    assume {:nonnull} Tmp_657 != 0;
    assume Tmp_657 > 0;
    assume {:nonnull} sdv_229 != 0;
    assume sdv_229 > 0;
    assume {:nonnull} CurrentOpIrp_3 != 0;
    assume CurrentOpIrp_3 > 0;
    havoc vslice_dummy_var_1299;
    call {:si_unique_call 959} vslice_dummy_var_139 := sdv_IoSetCancelRoutine(vslice_dummy_var_1299, 0);
    goto L4;

  L4:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} IntervalTimer_1 != 0;
    call {:si_unique_call 960} sdv_232 := MoxaCancelTimer(IntervalTimer_1, pDevExt_7);
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:partition} yogi_error != 1;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} sdv_232 != 0;
    assume {:nonnull} CurrentOpIrp_3 != 0;
    assume CurrentOpIrp_3 > 0;
    havoc vslice_dummy_var_1300;
    call {:si_unique_call 961} sdv_233 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1300);
    assume {:nonnull} sdv_233 != 0;
    assume sdv_233 > 0;
    Tmp_656 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_233)));
    assume {:nonnull} sdv_233 != 0;
    assume sdv_233 > 0;
    assume {:nonnull} Tmp_656 != 0;
    assume Tmp_656 > 0;
    assume {:nonnull} sdv_233 != 0;
    assume sdv_233 > 0;
    goto L12;

  L12:
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:partition} TotalTimer_1 != 0;
    call {:si_unique_call 962} sdv_234 := MoxaCancelTimer(TotalTimer_1, pDevExt_7);
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} yogi_error != 1;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} sdv_234 != 0;
    assume {:nonnull} CurrentOpIrp_3 != 0;
    assume CurrentOpIrp_3 > 0;
    havoc vslice_dummy_var_1301;
    call {:si_unique_call 963} sdv_230 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1301);
    assume {:nonnull} sdv_230 != 0;
    assume sdv_230 > 0;
    Tmp_658 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_230)));
    assume {:nonnull} sdv_230 != 0;
    assume sdv_230 > 0;
    assume {:nonnull} Tmp_658 != 0;
    assume Tmp_658 > 0;
    assume {:nonnull} sdv_230 != 0;
    assume sdv_230 > 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon18_Then:
    assume {:partition} sdv_234 == 0;
    goto L1;

  anon21_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon16_Then:
    assume {:partition} TotalTimer_1 == 0;
    goto L1;

  anon17_Then:
    assume {:partition} sdv_232 == 0;
    goto L12;

  anon20_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon15_Then:
    assume {:partition} IntervalTimer_1 == 0;
    goto L12;

  anon19_Then:
    assume {:partition} Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_660)] == 0;
    goto L4;
}



procedure {:origName "MoxaCancelTimer"} MoxaCancelTimer(actual_Timer: int, actual_PDevExt_6: int) returns (Tmp_664: int);
  modifies alloc, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCancelTimer"} MoxaCancelTimer(actual_Timer: int, actual_PDevExt_6: int) returns (Tmp_664: int)
{
  var {:scalar} cancelled: int;
  var {:pointer} Timer: int;
  var {:pointer} PDevExt_6: int;
  var vslice_dummy_var_1302: int;

  anon0:
    Timer := actual_Timer;
    PDevExt_6 := actual_PDevExt_6;
    call {:si_unique_call 964} cancelled := KeCancelTimer(0);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} cancelled != 0;
    assume {:nonnull} Timer != 0;
    assume Timer > 0;
    havoc vslice_dummy_var_1302;
    call {:si_unique_call 965} MoxaDpcEpilogue(PDevExt_6, vslice_dummy_var_1302);
    goto L9;

  L9:
    Tmp_664 := cancelled;
    goto LM2;

  LM2:
    return;

  anon5_Then:
    assume {:partition} cancelled == 0;
    goto L9;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaIRPEpilogue"} MoxaIRPEpilogue(actual_PDevExt_7: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIRPEpilogue"} MoxaIRPEpilogue(actual_PDevExt_7: int)
{
  var {:scalar} pendingCnt: int;
  var {:pointer} Tmp_667: int;
  var {:pointer} PDevExt_7: int;
  var vslice_dummy_var_140: int;
  var vslice_dummy_var_141: int;
  var vslice_dummy_var_1303: int;

  anon0:
    call {:si_unique_call 966} vslice_dummy_var_140 := __HAVOC_malloc(4);
    PDevExt_7 := actual_PDevExt_7;
    call {:si_unique_call 967} Tmp_667 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_7 != 0;
    assume PDevExt_7 > 0;
    assume {:nonnull} Tmp_667 != 0;
    assume Tmp_667 > 0;
    havoc vslice_dummy_var_1303;
    Mem_T.INT4[Tmp_667] := vslice_dummy_var_1303;
    call {:si_unique_call 968} pendingCnt := sdv_InterlockedDecrement(Tmp_667);
    assume {:nonnull} PDevExt_7 != 0;
    assume PDevExt_7 > 0;
    assume {:nonnull} Tmp_667 != 0;
    assume Tmp_667 > 0;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} pendingCnt == 0;
    assume {:nonnull} PDevExt_7 != 0;
    assume PDevExt_7 > 0;
    call {:si_unique_call 969} vslice_dummy_var_141 := KeSetEvent(PendingIRPEvent__MOXA_DEVICE_EXTENSION(PDevExt_7), 0, 0);
    goto L1;

  L1:
    return;

  anon3_Then:
    assume {:partition} pendingCnt != 0;
    goto L1;
}



procedure {:origName "MoxaGetNextIrp"} MoxaGetNextIrp(actual_CurrentOpIrp_4: int, actual_QueueToProcess_2: int, actual_NextIrp: int, actual_CompleteCurrent_1: int, actual_extension_22: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetNextIrp"} MoxaGetNextIrp(actual_CurrentOpIrp_4: int, actual_QueueToProcess_2: int, actual_NextIrp: int, actual_CompleteCurrent_1: int, actual_extension_22: int)
{
  var {:scalar} sdv_242: int;
  var {:scalar} oldIrql_18: int;
  var {:pointer} sdv_244: int;
  var {:pointer} oldIrp_1: int;
  var {:pointer} Tmp_670: int;
  var {:pointer} headOfList: int;
  var {:pointer} CurrentOpIrp_4: int;
  var {:pointer} QueueToProcess_2: int;
  var {:pointer} NextIrp: int;
  var {:scalar} CompleteCurrent_1: int;
  var {:pointer} extension_22: int;
  var vslice_dummy_var_142: int;
  var vslice_dummy_var_143: int;
  var vslice_dummy_var_1304: int;

  anon0:
    call {:si_unique_call 970} vslice_dummy_var_142 := __HAVOC_malloc(4);
    CurrentOpIrp_4 := actual_CurrentOpIrp_4;
    QueueToProcess_2 := actual_QueueToProcess_2;
    NextIrp := actual_NextIrp;
    CompleteCurrent_1 := actual_CompleteCurrent_1;
    extension_22 := actual_extension_22;
    call {:si_unique_call 971} Tmp_670 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_670 != 0;
    assume Tmp_670 > 0;
    Mem_T.INT4[Tmp_670] := oldIrql_18;
    call {:si_unique_call 972} IoAcquireCancelSpinLock(Tmp_670);
    assume {:nonnull} Tmp_670 != 0;
    assume Tmp_670 > 0;
    oldIrql_18 := Mem_T.INT4[Tmp_670];
    assume {:nonnull} CurrentOpIrp_4 != 0;
    assume CurrentOpIrp_4 > 0;
    havoc oldIrp_1;
    call {:si_unique_call 973} sdv_242 := sdv_IsListEmpty(0);
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} sdv_242 == 0;
    call {:si_unique_call 974} headOfList := RemoveHeadList(QueueToProcess_2);
    call {:si_unique_call 975} sdv_244 := sdv_containing_record(headOfList, 88);
    assume {:nonnull} CurrentOpIrp_4 != 0;
    assume CurrentOpIrp_4 > 0;
    assume {:nonnull} CurrentOpIrp_4 != 0;
    assume CurrentOpIrp_4 > 0;
    havoc vslice_dummy_var_1304;
    call {:si_unique_call 976} vslice_dummy_var_143 := sdv_IoSetCancelRoutine(vslice_dummy_var_1304, 0);
    goto L15;

  L15:
    assume {:nonnull} CurrentOpIrp_4 != 0;
    assume CurrentOpIrp_4 > 0;
    assume {:nonnull} NextIrp != 0;
    assume NextIrp > 0;
    call {:si_unique_call 977} IoReleaseCancelSpinLock(oldIrql_18);
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} CompleteCurrent_1 != 0;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} oldIrp_1 != 0;
    call {:si_unique_call 978} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 979} MoxaIRPEpilogue(extension_22);
    goto L1;

  L1:
    return;

  anon9_Then:
    assume {:partition} oldIrp_1 == 0;
    goto L1;

  anon8_Then:
    assume {:partition} CompleteCurrent_1 == 0;
    goto L1;

  anon7_Then:
    assume {:partition} sdv_242 != 0;
    assume {:nonnull} CurrentOpIrp_4 != 0;
    assume CurrentOpIrp_4 > 0;
    goto L15;
}



procedure {:origName "MoxaCleanInterruptShareLists"} MoxaCleanInterruptShareLists(actual_pDevExt_8: int) returns (Tmp_672: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_672 == 0 || Tmp_672 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCleanInterruptShareLists"} MoxaCleanInterruptShareLists(actual_pDevExt_8: int) returns (Tmp_672: int)
{
  var {:scalar} i_3: int;
  var {:scalar} Tmp_673: int;
  var {:pointer} Tmp_674: int;
  var {:pointer} interruptEntry_1: int;
  var {:pointer} dispatch_2: int;
  var {:scalar} sdv_246: int;
  var {:pointer} globalData_1: int;
  var {:pointer} cisrsw_2: int;
  var {:pointer} pDevExt1: int;
  var {:scalar} port_2: int;
  var {:pointer} Tmp_675: int;
  var {:pointer} Tmp_676: int;
  var {:pointer} sdv_247: int;
  var {:scalar} Tmp_678: int;
  var {:scalar} sdv_249: int;
  var {:scalar} cardNo_2: int;
  var {:pointer} Tmp_679: int;
  var {:scalar} Tmp_680: int;
  var {:pointer} pDevExt_8: int;
  var vslice_dummy_var_144: int;

  anon0:
    pDevExt_8 := actual_pDevExt_8;
    call {:si_unique_call 980} Tmp_674 := __HAVOC_malloc(512);
    call {:si_unique_call 981} Tmp_675 := __HAVOC_malloc(16);
    call {:si_unique_call 982} Tmp_679 := __HAVOC_malloc(16);
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    havoc globalData_1;
    call {:si_unique_call 983} sdv_246 := sdv_IsListEmpty(0);
    goto anon19_Then, anon19_Else;

  anon19_Else:
    assume {:partition} sdv_246 != 0;
    Tmp_672 := 0;
    goto L1;

  L1:
    return;

  anon19_Then:
    assume {:partition} sdv_246 == 0;
    i_3 := 0;
    goto L18;

  L18:
    call {:si_unique_call 984} i_3, Tmp_673, Tmp_674, pDevExt1, port_2, Tmp_679, Tmp_680 := MoxaCleanInterruptShareLists_loop_L18(i_3, Tmp_673, Tmp_674, globalData_1, pDevExt1, port_2, Tmp_679, Tmp_680, pDevExt_8);
    goto L18_last;

  L18_last:
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    havoc Tmp_673;
    assume {:nonnull} globalData_1 != 0;
    assume globalData_1 > 0;
    havoc Tmp_679;
    assume {:nonnull} Tmp_679 != 0;
    assume Tmp_679 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:partition} Mem_T.INT4[Tmp_679 + Tmp_673 * 4] > i_3;
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    havoc port_2;
    Tmp_680 := port_2;
    assume {:nonnull} globalData_1 != 0;
    assume globalData_1 > 0;
    havoc Tmp_674;
    assume {:nonnull} Tmp_674 != 0;
    assume Tmp_674 > 0;
    havoc pDevExt1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} pDevExt1 != 0;
    assume {:nonnull} pDevExt1 != 0;
    assume pDevExt1 > 0;
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    goto L23;

  L23:
    i_3 := i_3 + 1;
    goto L23_dummy;

  L23_dummy:
    assume false;
    return;

  anon20_Then:
    goto L19;

  L19:
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    havoc Tmp_678;
    assume {:nonnull} globalData_1 != 0;
    assume globalData_1 > 0;
    havoc Tmp_675;
    assume {:nonnull} Tmp_675 != 0;
    assume Tmp_675 > 0;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} i_3 != Mem_T.INT4[Tmp_675 + Tmp_678 * 4];
    Tmp_672 := 1;
    goto L1;

  anon24_Then:
    assume {:partition} i_3 == Mem_T.INT4[Tmp_675 + Tmp_678 * 4];
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    havoc Tmp_676;
    assume {:nonnull} Tmp_676 != 0;
    assume Tmp_676 > 0;
    havoc interruptEntry_1;
    goto L28;

  L28:
    call {:si_unique_call 985} interruptEntry_1, dispatch_2, cisrsw_2, sdv_247, cardNo_2 := MoxaCleanInterruptShareLists_loop_L28(interruptEntry_1, dispatch_2, cisrsw_2, sdv_247, cardNo_2, pDevExt_8);
    goto L28_last;

  L28_last:
    call {:si_unique_call 991} sdv_247 := sdv_containing_record(interruptEntry_1, 8);
    cisrsw_2 := sdv_247;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} cisrsw_2 != 0;
    assume {:nonnull} cisrsw_2 != 0;
    assume cisrsw_2 > 0;
    dispatch_2 := Dispatch__MOXA_CISR_SW(cisrsw_2);
    assume {:nonnull} dispatch_2 != 0;
    assume dispatch_2 > 0;
    havoc cardNo_2;
    assume {:nonnull} pDevExt_8 != 0;
    assume pDevExt_8 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    call {:si_unique_call 986} vslice_dummy_var_144 := MoxaRemoveLists(interruptEntry_1);
    call {:si_unique_call 987} sdv_249 := sdv_IsListEmpty(0);
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} sdv_249 != 0;
    call {:si_unique_call 988} IoDisconnectInterrupt(0);
    call {:si_unique_call 989} sdv_ExFreePool(0);
    goto L45;

  L45:
    call {:si_unique_call 990} sdv_ExFreePool(0);
    Tmp_672 := 1;
    goto L1;

  anon21_Then:
    assume {:partition} sdv_249 == 0;
    goto L45;

  anon26_Then:
    assume {:nonnull} interruptEntry_1 != 0;
    assume interruptEntry_1 > 0;
    havoc interruptEntry_1;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    Tmp_672 := 0;
    goto L1;

  anon27_Then:
    goto anon27_Then_dummy;

  anon27_Then_dummy:
    assume false;
    return;

  anon25_Then:
    assume {:partition} cisrsw_2 == 0;
    Tmp_672 := 0;
    goto L1;

  anon23_Then:
    assume {:partition} pDevExt1 == 0;
    goto L23;

  anon22_Then:
    assume {:partition} i_3 >= Mem_T.INT4[Tmp_679 + Tmp_673 * 4];
    goto L19;
}



procedure {:origName "MoxaSetDeviceFlags"} MoxaSetDeviceFlags(actual_PDevExt_9: int, actual_PFlags: int, actual_Value: int, actual_Set: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetDeviceFlags"} MoxaSetDeviceFlags(actual_PDevExt_9: int, actual_PFlags: int, actual_Value: int, actual_Set: int)
{
  var {:pointer} Tmp_681: int;
  var {:scalar} oldIrql_19: int;
  var {:pointer} PFlags: int;
  var {:scalar} Value: int;
  var {:scalar} Set: int;
  var vslice_dummy_var_145: int;

  anon0:
    call {:si_unique_call 992} vslice_dummy_var_145 := __HAVOC_malloc(4);
    PFlags := actual_PFlags;
    Value := actual_Value;
    Set := actual_Set;
    call {:si_unique_call 993} Tmp_681 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_681 != 0;
    assume Tmp_681 > 0;
    Mem_T.INT4[Tmp_681] := oldIrql_19;
    call {:si_unique_call 994} sdv_KeAcquireSpinLock(0, Tmp_681);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_681 != 0;
    assume Tmp_681 > 0;
    oldIrql_19 := Mem_T.INT4[Tmp_681];
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} Set != 0;
    assume {:nonnull} PFlags != 0;
    assume PFlags > 0;
    Mem_T.INT4[PFlags] := BOR(Mem_T.INT4[PFlags], Value);
    goto L10;

  L10:
    call {:si_unique_call 995} sdv_KeReleaseSpinLock(0, oldIrql_19);
    goto LM2;

  LM2:
    return;

  anon5_Then:
    assume {:partition} Set == 0;
    assume {:nonnull} PFlags != 0;
    assume PFlags > 0;
    Mem_T.INT4[PFlags] := BAND(Mem_T.INT4[PFlags], BNOT(Value));
    goto L10;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaPoCallDriver"} MoxaPoCallDriver(actual_PDevExt_10: int, actual_PDevObj_9: int, actual_PIrp_7: int) returns (Tmp_683: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_683 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaPoCallDriver"} MoxaPoCallDriver(actual_PDevExt_10: int, actual_PDevObj_9: int, actual_PIrp_7: int) returns (Tmp_683: int)
{
  var {:scalar} status_19: int;
  var {:pointer} PDevExt_10: int;
  var {:pointer} PIrp_7: int;

  anon0:
    PDevExt_10 := actual_PDevExt_10;
    PIrp_7 := actual_PIrp_7;
    call {:si_unique_call 996} status_19 := PoCallDriver(0, PIrp_7);
    call {:si_unique_call 997} MoxaIRPEpilogue(PDevExt_10);
    Tmp_683 := status_19;
    return;
}



procedure {:origName "MoxaKillPendingIrps"} MoxaKillPendingIrps(actual_PDevObj_10: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaKillPendingIrps"} MoxaKillPendingIrps(actual_PDevObj_10: int)
{
  var {:pointer} Tmp_685: int;
  var {:pointer} Tmp_686: int;
  var {:pointer} Tmp_687: int;
  var {:pointer} Tmp_688: int;
  var {:pointer} Tmp_689: int;
  var {:pointer} pDevExt_9: int;
  var {:scalar} cancelRoutine_2: int;
  var {:scalar} oldIrql_20: int;
  var {:pointer} PDevObj_10: int;
  var vslice_dummy_var_146: int;
  var vslice_dummy_var_147: int;
  var vslice_dummy_var_1305: int;
  var vslice_dummy_var_1306: int;
  var vslice_dummy_var_1307: int;
  var vslice_dummy_var_1308: int;

  anon0:
    call {:si_unique_call 998} vslice_dummy_var_146 := __HAVOC_malloc(4);
    PDevObj_10 := actual_PDevObj_10;
    assume {:nonnull} PDevObj_10 != 0;
    assume PDevObj_10 > 0;
    havoc pDevExt_9;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    call {:si_unique_call 999} MoxaKillAllReadsOrWrites(PDevObj_10, WriteQueue__MOXA_DEVICE_EXTENSION(pDevExt_9), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(pDevExt_9));
    goto anon31_Then, anon31_Else;

  anon31_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    call {:si_unique_call 1000} MoxaKillAllReadsOrWrites(PDevObj_10, ReadQueue__MOXA_DEVICE_EXTENSION(pDevExt_9), CurrentReadIrp__MOXA_DEVICE_EXTENSION(pDevExt_9));
    goto anon32_Then, anon32_Else;

  anon32_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    call {:si_unique_call 1001} MoxaKillAllReadsOrWrites(PDevObj_10, PurgeQueue__MOXA_DEVICE_EXTENSION(pDevExt_9), CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(pDevExt_9));
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    call {:si_unique_call 1002} MoxaKillAllReadsOrWrites(PDevObj_10, MaskQueue__MOXA_DEVICE_EXTENSION(pDevExt_9), CurrentMaskIrp__MOXA_DEVICE_EXTENSION(pDevExt_9));
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1003} Tmp_687 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_687 != 0;
    assume Tmp_687 > 0;
    Mem_T.INT4[Tmp_687] := oldIrql_20;
    call {:si_unique_call 1004} IoAcquireCancelSpinLock(Tmp_687);
    assume {:nonnull} Tmp_687 != 0;
    assume Tmp_687 > 0;
    oldIrql_20 := Mem_T.INT4[Tmp_687];
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc Tmp_685;
    assume {:nonnull} Tmp_685 != 0;
    assume Tmp_685 > 0;
    cancelRoutine_2 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_685)];
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc Tmp_689;
    assume {:nonnull} Tmp_689 != 0;
    assume Tmp_689 > 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:partition} cancelRoutine_2 != 0;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc Tmp_688;
    assume {:nonnull} Tmp_688 != 0;
    assume Tmp_688 > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(Tmp_688)] := oldIrql_20;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc Tmp_686;
    assume {:nonnull} Tmp_686 != 0;
    assume Tmp_686 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(Tmp_686)] := 0;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    goto anon29_Then, anon29_Else;

  anon29_Else:
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:IndirectCall} true;
    assume cancelRoutine_2 == li2bplFunctionConstant321;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc vslice_dummy_var_1305;
    call {:si_unique_call 1005} MoxaCancelCurrentWrite(PDevObj_10, vslice_dummy_var_1305);
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:partition} yogi_error != 1;
    goto L29;

  L29:
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    call {:si_unique_call 1006} vslice_dummy_var_147 := IoCancelIrp(0);
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    goto L35;

  L35:
    call {:si_unique_call 1007} MoxaKillAllStalled(PDevObj_10);
    goto anon37_Then, anon37_Else;

  anon37_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon37_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon28_Then:
    goto L35;

  anon39_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon30_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_2 == li2bplFunctionConstant188;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc vslice_dummy_var_1306;
    call {:si_unique_call 1008} MoxaCancelQueued(PDevObj_10, vslice_dummy_var_1306);
    goto L29;

  anon29_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_2 == li2bplFunctionConstant418;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc vslice_dummy_var_1307;
    call {:si_unique_call 1009} MoxaCancelWait(PDevObj_10, vslice_dummy_var_1307);
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} yogi_error != 1;
    goto L29;

  anon38_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon36_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_2 == li2bplFunctionConstant202;
    assume {:nonnull} pDevExt_9 != 0;
    assume pDevExt_9 > 0;
    havoc vslice_dummy_var_1308;
    call {:si_unique_call 1010} MoxaFilterCancelQueued(PDevObj_10, vslice_dummy_var_1308);
    goto L29;

  anon35_Then:
    assume {:partition} cancelRoutine_2 == 0;
    goto L29;

  anon27_Then:
    call {:si_unique_call 1011} IoReleaseCancelSpinLock(oldIrql_20);
    goto L29;

  anon34_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon33_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon32_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon31_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaLogError"} MoxaLogError(actual_DriverObject: int, actual_DeviceObject_12: int, actual_structPtr888P1: int, actual_structPtr888P2: int, actual_SequenceNumber: int, actual_MajorFunctionCode: int, actual_RetryCount: int, actual_UniqueErrorValue: int, actual_FinalStatus: int, actual_SpecificIOStatus: int, actual_LengthOfInsert1: int, actual_Insert1: int, actual_LengthOfInsert2: int, actual_Insert2: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaLogError"} MoxaLogError(actual_DriverObject: int, actual_DeviceObject_12: int, actual_structPtr888P1: int, actual_structPtr888P2: int, actual_SequenceNumber: int, actual_MajorFunctionCode: int, actual_RetryCount: int, actual_UniqueErrorValue: int, actual_FinalStatus: int, actual_SpecificIOStatus: int, actual_LengthOfInsert1: int, actual_Insert1: int, actual_LengthOfInsert2: int, actual_Insert2: int)
{
  var {:scalar} P1: int;
  var {:scalar} P2: int;
  var {:scalar} Tmp_691: int;
  var {:pointer} Tmp_693: int;
  var {:scalar} sdv_252: int;
  var {:scalar} Tmp_695: int;
  var {:pointer} errorLogEntry: int;
  var {:scalar} sdv_253: int;
  var {:pointer} Tmp_697: int;
  var {:pointer} sdv_254: int;
  var {:scalar} dumpToAllocate: int;
  var {:pointer} Tmp_699: int;
  var {:pointer} Tmp_700: int;
  var {:pointer} ptrToFirstInsert: int;
  var {:scalar} Tmp_701: int;
  var {:pointer} Tmp_702: int;
  var {:pointer} DriverObject: int;
  var {:pointer} DeviceObject_12: int;
  var {:pointer} structPtr888P1: int;
  var {:pointer} structPtr888P2: int;
  var {:scalar} SequenceNumber: int;
  var {:scalar} MajorFunctionCode: int;
  var {:scalar} RetryCount: int;
  var {:scalar} UniqueErrorValue: int;
  var {:scalar} FinalStatus: int;
  var {:scalar} SpecificIOStatus: int;
  var {:scalar} LengthOfInsert1: int;
  var {:pointer} Insert1: int;
  var {:scalar} LengthOfInsert2: int;
  var {:pointer} Insert2: int;
  var vslice_dummy_var_148: int;

  anon0:
    call {:si_unique_call 1012} P1 := __HAVOC_malloc(20);
    call {:si_unique_call 1013} P2 := __HAVOC_malloc(20);
    call {:si_unique_call 1014} Tmp_691 := __HAVOC_malloc(20);
    call {:si_unique_call 1015} Tmp_695 := __HAVOC_malloc(20);
    call {:si_unique_call 1016} vslice_dummy_var_148 := __HAVOC_malloc(4);
    DriverObject := actual_DriverObject;
    DeviceObject_12 := actual_DeviceObject_12;
    structPtr888P1 := actual_structPtr888P1;
    structPtr888P2 := actual_structPtr888P2;
    SequenceNumber := actual_SequenceNumber;
    MajorFunctionCode := actual_MajorFunctionCode;
    RetryCount := actual_RetryCount;
    UniqueErrorValue := actual_UniqueErrorValue;
    FinalStatus := actual_FinalStatus;
    SpecificIOStatus := actual_SpecificIOStatus;
    LengthOfInsert1 := actual_LengthOfInsert1;
    Insert1 := actual_Insert1;
    LengthOfInsert2 := actual_LengthOfInsert2;
    Insert2 := actual_Insert2;
    assume {:nonnull} P1 != 0;
    assume P1 > 0;
    assume {:nonnull} structPtr888P1 != 0;
    assume structPtr888P1 > 0;
    assume {:nonnull} P1 != 0;
    assume P1 > 0;
    assume {:nonnull} structPtr888P1 != 0;
    assume structPtr888P1 > 0;
    assume {:nonnull} P1 != 0;
    assume P1 > 0;
    assume {:nonnull} structPtr888P1 != 0;
    assume structPtr888P1 > 0;
    assume {:nonnull} P1 != 0;
    assume P1 > 0;
    assume {:nonnull} structPtr888P1 != 0;
    assume structPtr888P1 > 0;
    assume {:nonnull} P1 != 0;
    assume P1 > 0;
    assume {:nonnull} structPtr888P1 != 0;
    assume structPtr888P1 > 0;
    assume {:nonnull} P2 != 0;
    assume P2 > 0;
    assume {:nonnull} structPtr888P2 != 0;
    assume structPtr888P2 > 0;
    assume {:nonnull} P2 != 0;
    assume P2 > 0;
    assume {:nonnull} structPtr888P2 != 0;
    assume structPtr888P2 > 0;
    assume {:nonnull} P2 != 0;
    assume P2 > 0;
    assume {:nonnull} structPtr888P2 != 0;
    assume structPtr888P2 > 0;
    assume {:nonnull} P2 != 0;
    assume P2 > 0;
    assume {:nonnull} structPtr888P2 != 0;
    assume structPtr888P2 > 0;
    assume {:nonnull} P2 != 0;
    assume P2 > 0;
    assume {:nonnull} structPtr888P2 != 0;
    assume structPtr888P2 > 0;
    call {:si_unique_call 1017} Tmp_693 := __HAVOC_malloc(4);
    call {:si_unique_call 1018} Tmp_697 := __HAVOC_malloc(4);
    call {:si_unique_call 1019} Tmp_699 := __HAVOC_malloc(4);
    call {:si_unique_call 1020} Tmp_700 := __HAVOC_malloc(4);
    call {:si_unique_call 1021} Tmp_702 := __HAVOC_malloc(4);
    dumpToAllocate := 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} Insert1 != 0;
    goto L11;

  L11:
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} Insert2 != 0;
    goto L13;

  L13:
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:partition} DeviceObject_12 != 0;
    goto L16;

  L16:
    assume {:nonnull} Tmp_695 != 0;
    assume Tmp_695 > 0;
    assume {:nonnull} Tmp_695 != 0;
    assume Tmp_695 > 0;
    assume {:nonnull} Tmp_695 != 0;
    assume Tmp_695 > 0;
    assume {:nonnull} Tmp_695 != 0;
    assume Tmp_695 > 0;
    assume {:nonnull} Tmp_695 != 0;
    assume Tmp_695 > 0;
    call {:si_unique_call 1022} sdv_252 := MoxaMemCompare(P1, 1, Tmp_695, 1);
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} sdv_252 != 0;
    dumpToAllocate := 8;
    goto L21;

  L21:
    assume {:nonnull} Tmp_691 != 0;
    assume Tmp_691 > 0;
    assume {:nonnull} Tmp_691 != 0;
    assume Tmp_691 > 0;
    assume {:nonnull} Tmp_691 != 0;
    assume Tmp_691 > 0;
    assume {:nonnull} Tmp_691 != 0;
    assume Tmp_691 > 0;
    assume {:nonnull} Tmp_691 != 0;
    assume Tmp_691 > 0;
    call {:si_unique_call 1023} sdv_253 := MoxaMemCompare(P2, 1, Tmp_691, 1);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} sdv_253 != 0;
    dumpToAllocate := dumpToAllocate + 8;
    goto L27;

  L27:
    Tmp_701 := 48 + dumpToAllocate + LengthOfInsert1 + LengthOfInsert2;
    call {:si_unique_call 1024} sdv_254 := IoAllocateErrorLogEntry(0, Tmp_701);
    errorLogEntry := sdv_254;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} errorLogEntry != 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} dumpToAllocate != 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    havoc Tmp_697;
    call {:si_unique_call 1025} sdv_RtlCopyMemory(0, 0, 8);
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} dumpToAllocate > 8;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    havoc Tmp_693;
    call {:si_unique_call 1026} sdv_RtlCopyMemory(0, 0, 8);
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    havoc Tmp_699;
    ptrToFirstInsert := Tmp_699;
    goto L54;

  L54:
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} LengthOfInsert1 != 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    call {:si_unique_call 1027} sdv_RtlCopyMemory(0, 0, LengthOfInsert1);
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} LengthOfInsert2 != 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    call {:si_unique_call 1028} sdv_RtlCopyMemory(0, 0, LengthOfInsert2);
    goto L56;

  L56:
    call {:si_unique_call 1029} IoWriteErrorLogEntry(0);
    goto L1;

  L1:
    return;

  anon26_Then:
    assume {:partition} LengthOfInsert2 == 0;
    goto L56;

  anon30_Then:
    assume {:partition} LengthOfInsert1 == 0;
    goto L56;

  anon25_Then:
    assume {:partition} 8 >= dumpToAllocate;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    havoc Tmp_702;
    ptrToFirstInsert := Tmp_702;
    goto L54;

  anon29_Then:
    assume {:partition} dumpToAllocate == 0;
    assume {:nonnull} errorLogEntry != 0;
    assume errorLogEntry > 0;
    havoc Tmp_700;
    ptrToFirstInsert := Tmp_700;
    goto L54;

  anon28_Then:
    assume {:partition} errorLogEntry == 0;
    goto L1;

  anon24_Then:
    assume {:partition} sdv_253 == 0;
    goto L27;

  anon23_Then:
    assume {:partition} sdv_252 == 0;
    goto L21;

  anon22_Then:
    assume {:partition} DeviceObject_12 == 0;
    goto L16;

  anon21_Then:
    assume {:partition} Insert2 == 0;
    LengthOfInsert2 := 0;
    goto L13;

  anon27_Then:
    assume {:partition} Insert1 == 0;
    LengthOfInsert1 := 0;
    goto L11;
}



procedure {:origName "MoxaCommError"} MoxaCommError(actual_Dpc_7: int, actual_DeferredContext_7: int, actual_SystemContext1_7: int, actual_SystemContext2_7: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCommError"} MoxaCommError(actual_Dpc_7: int, actual_DeferredContext_7: int, actual_SystemContext1_7: int, actual_SystemContext2_7: int)
{
  var {:pointer} extension_23: int;
  var {:pointer} Dpc_7: int;
  var {:pointer} DeferredContext_7: int;
  var vslice_dummy_var_149: int;
  var vslice_dummy_var_1309: int;
  var vslice_dummy_var_1310: int;

  anon0:
    call {:si_unique_call 1030} vslice_dummy_var_149 := __HAVOC_malloc(4);
    Dpc_7 := actual_Dpc_7;
    DeferredContext_7 := actual_DeferredContext_7;
    extension_23 := DeferredContext_7;
    assume {:nonnull} extension_23 != 0;
    assume extension_23 > 0;
    havoc vslice_dummy_var_1309;
    call {:si_unique_call 1031} MoxaKillAllReadsOrWrites(vslice_dummy_var_1309, WriteQueue__MOXA_DEVICE_EXTENSION(extension_23), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(extension_23));
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} extension_23 != 0;
    assume extension_23 > 0;
    havoc vslice_dummy_var_1310;
    call {:si_unique_call 1032} MoxaKillAllReadsOrWrites(vslice_dummy_var_1310, ReadQueue__MOXA_DEVICE_EXTENSION(extension_23), CurrentReadIrp__MOXA_DEVICE_EXTENSION(extension_23));
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1033} MoxaDpcEpilogue(extension_23, Dpc_7);
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaSetTimer"} MoxaSetTimer(actual_Timer_1: int, actual_SD1_1: int, actual_Dpc_8: int, actual_PDevExt_11: int) returns (Tmp_705: int);
  modifies alloc, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaSetTimer"} MoxaSetTimer(actual_Timer_1: int, actual_SD1_1: int, actual_Dpc_8: int, actual_PDevExt_11: int) returns (Tmp_705: int)
{
  var {:scalar} DueTime_1: int;
  var {:pointer} Tmp_706: int;
  var {:scalar} set: int;
  var {:pointer} SD1_1: int;
  var {:pointer} PDevExt_11: int;
  var vslice_dummy_var_150: int;
  var vslice_dummy_var_151: int;
  var vslice_dummy_var_1311: int;
  var vslice_dummy_var_1312: int;

  anon0:
    call {:si_unique_call 1034} DueTime_1 := __HAVOC_malloc(20);
    SD1_1 := actual_SD1_1;
    PDevExt_11 := actual_PDevExt_11;
    assume {:nonnull} DueTime_1 != 0;
    assume DueTime_1 > 0;
    assume {:nonnull} SD1_1 != 0;
    assume SD1_1 > 0;
    assume {:nonnull} DueTime_1 != 0;
    assume DueTime_1 > 0;
    assume {:nonnull} SD1_1 != 0;
    assume SD1_1 > 0;
    assume {:nonnull} DueTime_1 != 0;
    assume DueTime_1 > 0;
    assume {:nonnull} SD1_1 != 0;
    assume SD1_1 > 0;
    assume {:nonnull} DueTime_1 != 0;
    assume DueTime_1 > 0;
    assume {:nonnull} SD1_1 != 0;
    assume SD1_1 > 0;
    assume {:nonnull} DueTime_1 != 0;
    assume DueTime_1 > 0;
    assume {:nonnull} SD1_1 != 0;
    assume SD1_1 > 0;
    call {:si_unique_call 1035} Tmp_706 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_11 != 0;
    assume PDevExt_11 > 0;
    assume {:nonnull} Tmp_706 != 0;
    assume Tmp_706 > 0;
    havoc vslice_dummy_var_1311;
    Mem_T.INT4[Tmp_706] := vslice_dummy_var_1311;
    call {:si_unique_call 1036} vslice_dummy_var_150 := sdv_InterlockedIncrement(Tmp_706);
    assume {:nonnull} PDevExt_11 != 0;
    assume PDevExt_11 > 0;
    assume {:nonnull} Tmp_706 != 0;
    assume Tmp_706 > 0;
    call {:si_unique_call 1037} set := KeSetTimer(0, DueTime_1, 0);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} set != 0;
    call {:si_unique_call 1038} Tmp_706 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_11 != 0;
    assume PDevExt_11 > 0;
    assume {:nonnull} Tmp_706 != 0;
    assume Tmp_706 > 0;
    havoc vslice_dummy_var_1312;
    Mem_T.INT4[Tmp_706] := vslice_dummy_var_1312;
    call {:si_unique_call 1039} vslice_dummy_var_151 := sdv_InterlockedDecrement(Tmp_706);
    assume {:nonnull} PDevExt_11 != 0;
    assume PDevExt_11 > 0;
    assume {:nonnull} Tmp_706 != 0;
    assume Tmp_706 > 0;
    goto L12;

  L12:
    Tmp_705 := set;
    goto LM2;

  LM2:
    return;

  anon5_Then:
    assume {:partition} set == 0;
    goto L12;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaCompleteIfError"} MoxaCompleteIfError(actual_DeviceObject_13: int, actual_Irp_11: int) returns (Tmp_707: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} Tmp_707 == -1073741536 || Tmp_707 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCompleteIfError"} MoxaCompleteIfError(actual_DeviceObject_13: int, actual_Irp_11: int) returns (Tmp_707: int)
{
  var {:pointer} irpSp_6: int;
  var {:scalar} status_20: int;
  var {:pointer} extension_24: int;
  var {:pointer} DeviceObject_13: int;
  var {:pointer} Irp_11: int;

  anon0:
    DeviceObject_13 := actual_DeviceObject_13;
    Irp_11 := actual_Irp_11;
    assume {:nonnull} DeviceObject_13 != 0;
    assume DeviceObject_13 > 0;
    havoc extension_24;
    status_20 := 0;
    assume {:nonnull} extension_24 != 0;
    assume extension_24 > 0;
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:nonnull} extension_24 != 0;
    assume extension_24 > 0;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    call {:si_unique_call 1040} irpSp_6 := sdv_IoGetCurrentIrpStackLocation(Irp_11);
    assume {:nonnull} irpSp_6 != 0;
    assume irpSp_6 > 0;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    goto L18;

  L18:
    status_20 := -1073741536;
    assume {:nonnull} Irp_11 != 0;
    assume Irp_11 > 0;
    assume {:nonnull} Irp_11 != 0;
    assume Irp_11 > 0;
    call {:si_unique_call 1041} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 1042} MoxaIRPEpilogue(extension_24);
    goto L9;

  L9:
    Tmp_707 := status_20;
    return;

  anon10_Then:
    assume {:nonnull} irpSp_6 != 0;
    assume irpSp_6 > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto L18;

  anon11_Then:
    goto L9;

  anon9_Then:
    goto L9;

  anon12_Then:
    goto L9;
}



procedure {:origName "MoxaRemoveLists"} MoxaRemoveLists(actual_Context_4: int) returns (Tmp_709: int);
  free ensures {:va_keep} Tmp_709 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaRemoveLists"} MoxaRemoveLists(actual_Context_4: int) returns (Tmp_709: int)
{
  var {:pointer} Context_4: int;
  var vslice_dummy_var_152: int;

  anon0:
    Context_4 := actual_Context_4;
    call {:si_unique_call 1043} vslice_dummy_var_152 := sdv_RemoveEntryList(0);
    Tmp_709 := 1;
    return;
}



procedure {:origName "MoxaIoCallDriver"} MoxaIoCallDriver(actual_PDevExt_12: int, actual_PDevObj_11: int, actual_PIrp_8: int) returns (Tmp_711: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_711 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIoCallDriver"} MoxaIoCallDriver(actual_PDevExt_12: int, actual_PDevObj_11: int, actual_PIrp_8: int) returns (Tmp_711: int)
{
  var {:scalar} status_21: int;
  var {:pointer} PDevExt_12: int;
  var {:pointer} PDevObj_11: int;
  var {:pointer} PIrp_8: int;

  anon0:
    PDevExt_12 := actual_PDevExt_12;
    PDevObj_11 := actual_PDevObj_11;
    PIrp_8 := actual_PIrp_8;
    call {:si_unique_call 1044} status_21 := sdv_IoCallDriver(PDevObj_11, PIrp_8);
    call {:si_unique_call 1045} MoxaIRPEpilogue(PDevExt_12);
    Tmp_711 := status_21;
    return;
}



procedure {:origName "MoxaReleaseResources"} MoxaReleaseResources(actual_pDevExt_10: int);
  modifies alloc, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaReleaseResources"} MoxaReleaseResources(actual_pDevExt_10: int)
{
  var {:scalar} i_4: int;
  var {:scalar} Tmp_713: int;
  var {:scalar} Tmp_714: int;
  var {:scalar} Tmp_715: int;
  var {:pointer} Tmp_716: int;
  var {:scalar} sdv_261: int;
  var {:pointer} Tmp_717: int;
  var {:scalar} Tmp_718: int;
  var {:pointer} Tmp_719: int;
  var {:scalar} sdv_263: int;
  var {:scalar} Tmp_720: int;
  var {:scalar} Tmp_721: int;
  var {:scalar} Tmp_722: int;
  var {:scalar} Tmp_723: int;
  var {:pointer} Tmp_725: int;
  var {:pointer} Tmp_726: int;
  var {:scalar} port_3: int;
  var {:pointer} pDevExt1_1: int;
  var {:pointer} Tmp_728: int;
  var {:scalar} Tmp_729: int;
  var {:scalar} Tmp_731: int;
  var {:pointer} Tmp_732: int;
  var {:scalar} Tmp_733: int;
  var {:scalar} sdv_266: int;
  var {:pointer} Tmp_734: int;
  var {:scalar} Tmp_735: int;
  var {:scalar} anyPortExist: int;
  var {:scalar} sdv_267: int;
  var {:scalar} Tmp_736: int;
  var {:pointer} Tmp_737: int;
  var {:scalar} sdv_270: int;
  var {:pointer} Tmp_738: int;
  var {:pointer} Tmp_739: int;
  var {:scalar} Tmp_740: int;
  var {:pointer} Tmp_741: int;
  var {:scalar} Tmp_742: int;
  var {:scalar} Tmp_743: int;
  var {:pointer} Tmp_744: int;
  var {:pointer} Tmp_745: int;
  var {:pointer} Tmp_746: int;
  var {:pointer} Tmp_747: int;
  var {:pointer} Tmp_748: int;
  var {:scalar} sdv_276: int;
  var {:pointer} Tmp_749: int;
  var {:scalar} Tmp_750: int;
  var {:scalar} Tmp_751: int;
  var {:scalar} sdv_277: int;
  var {:pointer} Tmp_752: int;
  var {:scalar} Tmp_753: int;
  var {:scalar} deviceLinkUnicodeString: int;
  var {:pointer} pDevObj_2: int;
  var {:pointer} Tmp_754: int;
  var {:scalar} Tmp_755: int;
  var {:pointer} Tmp_756: int;
  var {:pointer} Tmp_757: int;
  var {:pointer} Tmp_758: int;
  var {:pointer} pDevExt_10: int;
  var vslice_dummy_var_153: int;
  var vslice_dummy_var_154: int;
  var vslice_dummy_var_155: int;
  var vslice_dummy_var_156: int;
  var vslice_dummy_var_157: int;
  var vslice_dummy_var_158: int;
  var vslice_dummy_var_159: int;
  var vslice_dummy_var_160: int;
  var vslice_dummy_var_161: int;
  var vslice_dummy_var_162: int;
  var vslice_dummy_var_163: int;
  var vslice_dummy_var_164: int;
  var vslice_dummy_var_165: int;
  var vslice_dummy_var_1313: int;
  var vslice_dummy_var_1314: int;
  var vslice_dummy_var_1315: int;
  var vslice_dummy_var_1316: int;
  var vslice_dummy_var_1317: int;
  var vslice_dummy_var_1318: int;
  var vslice_dummy_var_1319: int;

  anon0:
    call {:si_unique_call 1046} vslice_dummy_var_153 := __HAVOC_malloc(4);
    call {:si_unique_call 1047} deviceLinkUnicodeString := __HAVOC_malloc(12);
    pDevExt_10 := actual_pDevExt_10;
    call {:si_unique_call 1048} Tmp_716 := __HAVOC_malloc(16);
    call {:si_unique_call 1049} Tmp_717 := __HAVOC_malloc(512);
    call {:si_unique_call 1050} Tmp_719 := __HAVOC_malloc(16);
    call {:si_unique_call 1051} Tmp_725 := __HAVOC_malloc(16);
    call {:si_unique_call 1052} Tmp_726 := __HAVOC_malloc(16);
    call {:si_unique_call 1053} Tmp_728 := __HAVOC_malloc(16);
    call {:si_unique_call 1054} Tmp_732 := __HAVOC_malloc(512);
    call {:si_unique_call 1055} Tmp_734 := __HAVOC_malloc(16);
    call {:si_unique_call 1056} Tmp_739 := __HAVOC_malloc(72);
    call {:si_unique_call 1057} Tmp_741 := __HAVOC_malloc(16);
    call {:si_unique_call 1058} Tmp_744 := __HAVOC_malloc(16);
    call {:si_unique_call 1059} Tmp_745 := __HAVOC_malloc(16);
    call {:si_unique_call 1060} Tmp_746 := __HAVOC_malloc(80);
    call {:si_unique_call 1061} Tmp_747 := __HAVOC_malloc(512);
    call {:si_unique_call 1062} Tmp_748 := __HAVOC_malloc(16);
    call {:si_unique_call 1063} Tmp_749 := __HAVOC_malloc(16);
    call {:si_unique_call 1064} Tmp_754 := __HAVOC_malloc(16);
    call {:si_unique_call 1065} Tmp_756 := __HAVOC_malloc(80);
    call {:si_unique_call 1066} Tmp_757 := __HAVOC_malloc(128);
    call {:si_unique_call 1067} Tmp_758 := __HAVOC_malloc(16);
    anyPortExist := 1;
    call {:si_unique_call 1068} vslice_dummy_var_157 := MoxaCleanInterruptShareLists(pDevExt_10);
    i_4 := 0;
    goto L14;

  L14:
    call {:si_unique_call 1069} i_4, Tmp_713, Tmp_717, port_3, pDevExt1_1, Tmp_734, Tmp_740 := MoxaReleaseResources_loop_L14(i_4, Tmp_713, Tmp_717, port_3, pDevExt1_1, Tmp_734, Tmp_740, pDevExt_10);
    goto L14_last;

  L14_last:
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_713;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_734;
    assume {:nonnull} Tmp_734 != 0;
    assume Tmp_734 > 0;
    goto anon55_Then, anon55_Else;

  anon55_Else:
    assume {:partition} Mem_T.INT4[Tmp_734 + Tmp_713 * 4] > i_4;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc port_3;
    Tmp_740 := port_3;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_717;
    assume {:nonnull} Tmp_717 != 0;
    assume Tmp_717 > 0;
    havoc pDevExt1_1;
    goto anon56_Then, anon56_Else;

  anon56_Else:
    assume {:partition} pDevExt1_1 != 0;
    assume {:nonnull} pDevExt1_1 != 0;
    assume pDevExt1_1 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto anon43_Then, anon43_Else;

  anon43_Else:
    goto L19;

  L19:
    i_4 := i_4 + 1;
    goto L19_dummy;

  L19_dummy:
    assume false;
    return;

  anon43_Then:
    goto L15;

  L15:
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_751;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_749;
    assume {:nonnull} Tmp_749 != 0;
    assume Tmp_749 > 0;
    goto anon57_Then, anon57_Else;

  anon57_Else:
    assume {:partition} i_4 == Mem_T.INT4[Tmp_749 + Tmp_751 * 4];
    anyPortExist := 0;
    i_4 := 0;
    goto L25;

  L25:
    call {:si_unique_call 1070} i_4, Tmp_715, Tmp_725 := MoxaReleaseResources_loop_L25(i_4, Tmp_715, Tmp_725, pDevExt_10);
    goto L25_last;

  L25_last:
    assume {:CounterLoop 4} {:Counter "i_4"} true;
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} 4 > i_4;
    Tmp_715 := i_4;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_725;
    assume {:nonnull} Tmp_725 != 0;
    assume Tmp_725 > 0;
    goto anon58_Then, anon58_Else;

  anon58_Else:
    assume {:partition} Mem_T.INT4[Tmp_725 + Tmp_715 * 4] != 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    goto L28;

  L28:
    i_4 := i_4 + 1;
    goto L28_dummy;

  L28_dummy:
    assume false;
    return;

  anon46_Then:
    goto L26;

  L26:
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} i_4 == 4;
    Tmp_739 := strConst__li2bpl24;
    call {:si_unique_call 1071} RtlInitUnicodeString(deviceLinkUnicodeString, Tmp_739);
    call {:si_unique_call 1072} vslice_dummy_var_154 := IoDeleteSymbolicLink(0);
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_752;
    assume {:nonnull} Tmp_752 != 0;
    assume Tmp_752 > 0;
    havoc pDevObj_2;
    goto L38;

  L38:
    call {:si_unique_call 1073} Tmp_738, pDevObj_2 := MoxaReleaseResources_loop_L38(Tmp_738, pDevObj_2);
    goto L38_last;

  L38_last:
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} pDevObj_2 != 0;
    assume {:nonnull} pDevObj_2 != 0;
    assume pDevObj_2 > 0;
    havoc Tmp_738;
    assume {:nonnull} Tmp_738 != 0;
    assume Tmp_738 > 0;
    goto anon59_Then, anon59_Else;

  anon59_Else:
    call {:si_unique_call 1074} IoDeleteDevice(0);
    goto L22;

  L22:
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    call {:si_unique_call 1075} vslice_dummy_var_158 := MoxaCancelTimer(ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(pDevExt_10), pDevExt_10);
    goto anon60_Then, anon60_Else;

  anon60_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    call {:si_unique_call 1076} vslice_dummy_var_155 := MoxaCancelTimer(ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(pDevExt_10), pDevExt_10);
    goto anon61_Then, anon61_Else;

  anon61_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    call {:si_unique_call 1077} vslice_dummy_var_156 := MoxaCancelTimer(WriteRequestTotalTimer__MOXA_DEVICE_EXTENSION(pDevExt_10), pDevExt_10);
    goto anon62_Then, anon62_Else;

  anon62_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1078} sdv_266 := KeRemoveQueueDpc(0);
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} sdv_266 != 0;
    call {:si_unique_call 1079} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1313;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1313;
    call {:si_unique_call 1080} vslice_dummy_var_159 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L58;

  L58:
    call {:si_unique_call 1081} sdv_277 := KeRemoveQueueDpc(0);
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:partition} sdv_277 != 0;
    call {:si_unique_call 1082} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1314;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1314;
    call {:si_unique_call 1083} vslice_dummy_var_160 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L65;

  L65:
    call {:si_unique_call 1084} sdv_267 := KeRemoveQueueDpc(0);
    goto anon50_Then, anon50_Else;

  anon50_Else:
    assume {:partition} sdv_267 != 0;
    call {:si_unique_call 1085} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1315;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1315;
    call {:si_unique_call 1086} vslice_dummy_var_161 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L72;

  L72:
    call {:si_unique_call 1087} sdv_270 := KeRemoveQueueDpc(0);
    goto anon51_Then, anon51_Else;

  anon51_Else:
    assume {:partition} sdv_270 != 0;
    call {:si_unique_call 1088} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1316;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1316;
    call {:si_unique_call 1089} vslice_dummy_var_162 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L79;

  L79:
    call {:si_unique_call 1090} sdv_263 := KeRemoveQueueDpc(0);
    goto anon52_Then, anon52_Else;

  anon52_Else:
    assume {:partition} sdv_263 != 0;
    call {:si_unique_call 1091} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1317;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1317;
    call {:si_unique_call 1092} vslice_dummy_var_163 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L86;

  L86:
    call {:si_unique_call 1093} sdv_276 := KeRemoveQueueDpc(0);
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} sdv_276 != 0;
    call {:si_unique_call 1094} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1318;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1318;
    call {:si_unique_call 1095} vslice_dummy_var_164 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L93;

  L93:
    call {:si_unique_call 1096} sdv_261 := KeRemoveQueueDpc(0);
    goto anon54_Then, anon54_Else;

  anon54_Else:
    assume {:partition} sdv_261 != 0;
    call {:si_unique_call 1097} Tmp_737 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc vslice_dummy_var_1319;
    Mem_T.INT4[Tmp_737] := vslice_dummy_var_1319;
    call {:si_unique_call 1098} vslice_dummy_var_165 := sdv_InterlockedDecrement(Tmp_737);
    assume {:nonnull} Tmp_737 != 0;
    assume Tmp_737 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    goto L100;

  L100:
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_750;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_747;
    assume {:nonnull} Tmp_747 != 0;
    assume Tmp_747 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_729;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_733;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_732;
    assume {:nonnull} Tmp_732 != 0;
    assume Tmp_732 > 0;
    havoc Tmp_757;
    assume {:nonnull} Tmp_757 != 0;
    assume Tmp_757 > 0;
    Tmp_721 := Mem_T.INT4[Tmp_757 + Tmp_729 * 4];
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume {:partition} anyPortExist == 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_755;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_741;
    assume {:nonnull} Tmp_741 != 0;
    assume Tmp_741 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_714;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_719;
    assume {:nonnull} Tmp_719 != 0;
    assume Tmp_719 > 0;
    Mem_T.INT4[Tmp_719 + Tmp_714 * 4] := 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_735;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_758;
    assume {:nonnull} Tmp_758 != 0;
    assume Tmp_758 > 0;
    Mem_T.INT4[Tmp_758 + Tmp_735 * 4] := 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_720;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_745;
    assume {:nonnull} Tmp_745 != 0;
    assume Tmp_745 > 0;
    Mem_T.INT4[Tmp_745 + Tmp_720 * 4] := 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_718;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_726;
    assume {:nonnull} Tmp_726 != 0;
    assume Tmp_726 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_736;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_716;
    assume {:nonnull} Tmp_716 != 0;
    assume Tmp_716 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_723;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_744;
    assume {:nonnull} Tmp_744 != 0;
    assume Tmp_744 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_722;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_754;
    assume {:nonnull} Tmp_754 != 0;
    assume Tmp_754 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_731;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_728;
    assume {:nonnull} Tmp_728 != 0;
    assume Tmp_728 > 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_743;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_748;
    assume {:nonnull} Tmp_748 != 0;
    assume Tmp_748 > 0;
    Mem_T.INT4[Tmp_748 + Tmp_743 * 4] := 0;
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_753;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_746;
    call {:si_unique_call 1099} sdv_RtlZeroMemory(0, 8);
    assume {:nonnull} pDevExt_10 != 0;
    assume pDevExt_10 > 0;
    havoc Tmp_742;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc Tmp_756;
    call {:si_unique_call 1100} sdv_RtlZeroMemory(0, 8);
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon63_Then:
    assume {:partition} anyPortExist != 0;
    goto L1;

  anon54_Then:
    assume {:partition} sdv_261 == 0;
    goto L100;

  anon53_Then:
    assume {:partition} sdv_276 == 0;
    goto L93;

  anon52_Then:
    assume {:partition} sdv_263 == 0;
    goto L86;

  anon51_Then:
    assume {:partition} sdv_270 == 0;
    goto L79;

  anon50_Then:
    assume {:partition} sdv_267 == 0;
    goto L72;

  anon49_Then:
    assume {:partition} sdv_277 == 0;
    goto L65;

  anon48_Then:
    assume {:partition} sdv_266 == 0;
    goto L58;

  anon62_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon61_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon60_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon59_Then:
    assume {:nonnull} pDevObj_2 != 0;
    assume pDevObj_2 > 0;
    havoc pDevObj_2;
    goto anon59_Then_dummy;

  anon59_Then_dummy:
    assume false;
    return;

  anon47_Then:
    assume {:partition} pDevObj_2 == 0;
    goto L22;

  anon45_Then:
    assume {:partition} i_4 != 4;
    goto L22;

  anon58_Then:
    assume {:partition} Mem_T.INT4[Tmp_725 + Tmp_715 * 4] == 0;
    goto L28;

  anon44_Then:
    assume {:partition} i_4 >= 4;
    goto L26;

  anon57_Then:
    assume {:partition} i_4 != Mem_T.INT4[Tmp_749 + Tmp_751 * 4];
    goto L22;

  anon56_Then:
    assume {:partition} pDevExt1_1 == 0;
    goto L19;

  anon55_Then:
    assume {:partition} i_4 >= Mem_T.INT4[Tmp_734 + Tmp_713 * 4];
    goto L15;
}



procedure {:origName "MoxaDpcEpilogue"} MoxaDpcEpilogue(actual_PDevExt_13: int, actual_PDpc_1: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDpcEpilogue"} MoxaDpcEpilogue(actual_PDevExt_13: int, actual_PDpc_1: int)
{
  var {:pointer} Tmp_759: int;
  var {:scalar} pendingCnt_2: int;
  var {:pointer} PDevExt_13: int;
  var vslice_dummy_var_166: int;
  var vslice_dummy_var_167: int;
  var vslice_dummy_var_1320: int;

  anon0:
    call {:si_unique_call 1101} vslice_dummy_var_166 := __HAVOC_malloc(4);
    PDevExt_13 := actual_PDevExt_13;
    call {:si_unique_call 1102} Tmp_759 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_13 != 0;
    assume PDevExt_13 > 0;
    assume {:nonnull} Tmp_759 != 0;
    assume Tmp_759 > 0;
    havoc vslice_dummy_var_1320;
    Mem_T.INT4[Tmp_759] := vslice_dummy_var_1320;
    call {:si_unique_call 1103} pendingCnt_2 := sdv_InterlockedDecrement(Tmp_759);
    assume {:nonnull} PDevExt_13 != 0;
    assume PDevExt_13 > 0;
    assume {:nonnull} Tmp_759 != 0;
    assume Tmp_759 > 0;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} pendingCnt_2 == 0;
    assume {:nonnull} PDevExt_13 != 0;
    assume PDevExt_13 > 0;
    call {:si_unique_call 1104} vslice_dummy_var_167 := KeSetEvent(PendingDpcEvent__MOXA_DEVICE_EXTENSION(PDevExt_13), 0, 0);
    goto L1;

  L1:
    return;

  anon3_Then:
    assume {:partition} pendingCnt_2 != 0;
    goto L1;
}



procedure {:origName "MoxaCancelQueued"} MoxaCancelQueued(actual_DeviceObject_14: int, actual_Irp_12: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4;
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCancelQueued"} MoxaCancelQueued(actual_DeviceObject_14: int, actual_Irp_12: int)
{
  var {:pointer} irpSp_7: int;
  var {:pointer} extension_25: int;
  var {:pointer} DeviceObject_14: int;
  var {:pointer} Irp_12: int;
  var vslice_dummy_var_168: int;
  var vslice_dummy_var_169: int;

  anon0:
    call {:si_unique_call 1105} vslice_dummy_var_168 := __HAVOC_malloc(4);
    DeviceObject_14 := actual_DeviceObject_14;
    Irp_12 := actual_Irp_12;
    assume {:nonnull} DeviceObject_14 != 0;
    assume DeviceObject_14 > 0;
    havoc extension_25;
    call {:si_unique_call 1106} irpSp_7 := sdv_IoGetCurrentIrpStackLocation(Irp_12);
    assume {:nonnull} Irp_12 != 0;
    assume Irp_12 > 0;
    assume {:nonnull} Irp_12 != 0;
    assume Irp_12 > 0;
    call {:si_unique_call 1107} vslice_dummy_var_169 := sdv_RemoveEntryList(0);
    assume {:nonnull} irpSp_7 != 0;
    assume irpSp_7 > 0;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:nonnull} extension_25 != 0;
    assume extension_25 > 0;
    assume {:nonnull} irpSp_7 != 0;
    assume irpSp_7 > 0;
    goto L16;

  L16:
    assume {:nonnull} Irp_12 != 0;
    assume Irp_12 > 0;
    call {:si_unique_call 1108} IoReleaseCancelSpinLock(Mem_T.CancelIrql__IRP[CancelIrql__IRP(Irp_12)]);
    call {:si_unique_call 1109} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 1110} MoxaIRPEpilogue(extension_25);
    return;

  anon3_Then:
    goto L16;
}



procedure {:origName "MoxaKillAllStalled"} MoxaKillAllStalled(actual_PDevObj_12: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaKillAllStalled"} MoxaKillAllStalled(actual_PDevObj_12: int)
{
  var {:pointer} currentLastIrp_1: int;
  var {:scalar} cancelIrql_1: int;
  var {:pointer} pDevExt_11: int;
  var {:scalar} sdv_284: int;
  var {:pointer} Tmp_764: int;
  var {:pointer} sdv_285: int;
  var {:scalar} cancelRoutine_3: int;
  var {:pointer} PDevObj_12: int;
  var vslice_dummy_var_170: int;
  var vslice_dummy_var_171: int;
  var vslice_dummy_var_1321: int;

  anon0:
    call {:si_unique_call 1111} vslice_dummy_var_170 := __HAVOC_malloc(4);
    PDevObj_12 := actual_PDevObj_12;
    assume {:nonnull} PDevObj_12 != 0;
    assume PDevObj_12 > 0;
    havoc pDevExt_11;
    call {:si_unique_call 1112} Tmp_764 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_764 != 0;
    assume Tmp_764 > 0;
    Mem_T.INT4[Tmp_764] := cancelIrql_1;
    call {:si_unique_call 1113} IoAcquireCancelSpinLock(Tmp_764);
    assume {:nonnull} Tmp_764 != 0;
    assume Tmp_764 > 0;
    cancelIrql_1 := Mem_T.INT4[Tmp_764];
    goto L10;

  L10:
    call {:si_unique_call 1114} currentLastIrp_1, cancelIrql_1, sdv_284, Tmp_764, sdv_285, cancelRoutine_3, vslice_dummy_var_171 := MoxaKillAllStalled_loop_L10(currentLastIrp_1, cancelIrql_1, pDevExt_11, sdv_284, Tmp_764, sdv_285, cancelRoutine_3, PDevObj_12, vslice_dummy_var_171);
    goto L10_last;

  L10_last:
    call {:si_unique_call 1124} sdv_284 := sdv_IsListEmpty(0);
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} sdv_284 == 0;
    assume {:nonnull} pDevExt_11 != 0;
    assume pDevExt_11 > 0;
    havoc vslice_dummy_var_1321;
    call {:si_unique_call 1115} sdv_285 := sdv_containing_record(vslice_dummy_var_1321, 88);
    currentLastIrp_1 := sdv_285;
    call {:si_unique_call 1116} vslice_dummy_var_171 := sdv_RemoveEntryList(0);
    assume {:nonnull} currentLastIrp_1 != 0;
    assume currentLastIrp_1 > 0;
    cancelRoutine_3 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(currentLastIrp_1)];
    assume {:nonnull} currentLastIrp_1 != 0;
    assume currentLastIrp_1 > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(currentLastIrp_1)] := cancelIrql_1;
    assume {:nonnull} currentLastIrp_1 != 0;
    assume currentLastIrp_1 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(currentLastIrp_1)] := 0;
    assume {:nonnull} currentLastIrp_1 != 0;
    assume currentLastIrp_1 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:IndirectCall} true;
    assume cancelRoutine_3 == li2bplFunctionConstant321;
    call {:si_unique_call 1117} MoxaCancelCurrentWrite(PDevObj_12, currentLastIrp_1);
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} yogi_error != 1;
    goto L32;

  L32:
    call {:si_unique_call 1118} Tmp_764 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_764 != 0;
    assume Tmp_764 > 0;
    Mem_T.INT4[Tmp_764] := cancelIrql_1;
    call {:si_unique_call 1119} IoAcquireCancelSpinLock(Tmp_764);
    assume {:nonnull} Tmp_764 != 0;
    assume Tmp_764 > 0;
    cancelIrql_1 := Mem_T.INT4[Tmp_764];
    goto L32_dummy;

  L32_dummy:
    assume false;
    return;

  anon18_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  LM2:
    return;

  anon15_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_3 == li2bplFunctionConstant188;
    call {:si_unique_call 1120} MoxaCancelQueued(PDevObj_12, currentLastIrp_1);
    goto L32;

  anon14_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_3 == li2bplFunctionConstant418;
    call {:si_unique_call 1121} MoxaCancelWait(PDevObj_12, currentLastIrp_1);
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} yogi_error != 1;
    goto L32;

  anon17_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon16_Then:
    assume {:IndirectCall} true;
    assume cancelRoutine_3 == li2bplFunctionConstant202;
    call {:si_unique_call 1122} MoxaFilterCancelQueued(PDevObj_12, currentLastIrp_1);
    goto L32;

  anon13_Then:
    assume {:partition} sdv_284 != 0;
    call {:si_unique_call 1123} IoReleaseCancelSpinLock(cancelIrql_1);
    goto LM2;
}



procedure {:origName "MoxaFunc1"} MoxaFunc1(actual_PortOfs_5: int, actual_Command_1: int, actual_Argument_3: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFunc1"} MoxaFunc1(actual_PortOfs_5: int, actual_Command_1: int, actual_Argument_3: int)
{
  var {:pointer} Tmp_765: int;
  var {:pointer} PortOfs_5: int;
  var {:scalar} Command_1: int;
  var {:scalar} Argument_3: int;
  var vslice_dummy_var_172: int;
  var vslice_dummy_var_173: int;

  anon0:
    call {:si_unique_call 1125} vslice_dummy_var_172 := __HAVOC_malloc(4);
    PortOfs_5 := actual_PortOfs_5;
    Command_1 := actual_Command_1;
    Argument_3 := actual_Argument_3;
    Tmp_765 := PortOfs_5;
    assume {:nonnull} Tmp_765 != 0;
    assume Tmp_765 > 0;
    Mem_T.INT4[Tmp_765] := Argument_3;
    assume {:nonnull} PortOfs_5 != 0;
    assume PortOfs_5 > 0;
    Mem_T.INT4[PortOfs_5] := Command_1;
    call {:si_unique_call 1126} vslice_dummy_var_173 := MoxaWaitFinish1(PortOfs_5);
    return;
}



procedure {:origName "MoxaFunc"} MoxaFunc(actual_PortOfs_6: int, actual_Command_2: int, actual_Argument_4: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFunc"} MoxaFunc(actual_PortOfs_6: int, actual_Command_2: int, actual_Argument_4: int)
{
  var {:pointer} Tmp_769: int;
  var {:pointer} PortOfs_6: int;
  var {:scalar} Command_2: int;
  var {:scalar} Argument_4: int;
  var vslice_dummy_var_174: int;
  var vslice_dummy_var_175: int;

  anon0:
    call {:si_unique_call 1127} vslice_dummy_var_174 := __HAVOC_malloc(4);
    PortOfs_6 := actual_PortOfs_6;
    Command_2 := actual_Command_2;
    Argument_4 := actual_Argument_4;
    Tmp_769 := PortOfs_6;
    assume {:nonnull} Tmp_769 != 0;
    assume Tmp_769 > 0;
    Mem_T.INT4[Tmp_769] := Argument_4;
    assume {:nonnull} PortOfs_6 != 0;
    assume PortOfs_6 > 0;
    Mem_T.INT4[PortOfs_6] := Command_2;
    call {:si_unique_call 1128} vslice_dummy_var_175 := MoxaWaitFinish(PortOfs_6);
    return;
}



procedure {:origName "MoxaIoSyncIoctlEx"} MoxaIoSyncIoctlEx(actual_Ioctl: int, actual_Internal: int, actual_PDevObj_13: int, actual_PEvent_1: int, actual_PIoStatusBlock: int, actual_PInBuffer: int, actual_InBufferLen: int, actual_POutBuffer: int, actual_OutBufferLen: int) returns (Tmp_771: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIoSyncIoctlEx"} MoxaIoSyncIoctlEx(actual_Ioctl: int, actual_Internal: int, actual_PDevObj_13: int, actual_PEvent_1: int, actual_PIoStatusBlock: int, actual_PInBuffer: int, actual_InBufferLen: int, actual_POutBuffer: int, actual_OutBufferLen: int) returns (Tmp_771: int)
{
  var {:pointer} pIrp_1: int;
  var {:scalar} status_22: int;
  var {:scalar} Ioctl: int;
  var {:scalar} Internal: int;
  var {:pointer} PDevObj_13: int;
  var {:pointer} PEvent_1: int;
  var {:pointer} PIoStatusBlock: int;
  var {:scalar} InBufferLen: int;
  var {:scalar} OutBufferLen: int;

  anon0:
    Ioctl := actual_Ioctl;
    Internal := actual_Internal;
    PDevObj_13 := actual_PDevObj_13;
    PEvent_1 := actual_PEvent_1;
    PIoStatusBlock := actual_PIoStatusBlock;
    InBufferLen := actual_InBufferLen;
    OutBufferLen := actual_OutBufferLen;
    call {:si_unique_call 1129} KeClearEvent(PEvent_1);
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1130} pIrp_1 := IoBuildDeviceIoControlRequest(Ioctl, 0, 0, InBufferLen, 0, OutBufferLen, Internal, 0, PIoStatusBlock);
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} pIrp_1 != 0;
    call {:si_unique_call 1131} status_22 := MoxaIoSyncReq(PDevObj_13, pIrp_1, PEvent_1);
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} status_22 != 0;
    goto L20;

  L20:
    Tmp_771 := status_22;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon8_Then:
    assume {:partition} status_22 == 0;
    assume {:nonnull} PIoStatusBlock != 0;
    assume PIoStatusBlock > 0;
    havoc status_22;
    goto L20;

  anon7_Then:
    assume {:partition} pIrp_1 == 0;
    Tmp_771 := -1073741670;
    goto L1;

  anon9_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaRemoveDevObj"} MoxaRemoveDevObj(actual_PDevObj_14: int) returns (Tmp_773: int);
  modifies alloc, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaRemoveDevObj"} MoxaRemoveDevObj(actual_PDevObj_14: int) returns (Tmp_773: int)
{
  var {:pointer} pDevExt_12: int;
  var {:pointer} PDevObj_14: int;

  anon0:
    PDevObj_14 := actual_PDevObj_14;
    assume {:nonnull} PDevObj_14 != 0;
    assume PDevObj_14 > 0;
    havoc pDevExt_12;
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_12)], 8) != 0;
    goto L9;

  L9:
    call {:si_unique_call 1132} IoDetachDevice(0);
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    call {:si_unique_call 1133} sdv_ExFreePool(0);
    goto L13;

  L13:
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    call {:si_unique_call 1134} sdv_ExFreePool(0);
    goto L17;

  L17:
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:nonnull} pDevExt_12 != 0;
    assume pDevExt_12 > 0;
    call {:si_unique_call 1135} sdv_ExFreePool(0);
    goto L21;

  L21:
    call {:si_unique_call 1136} IoDeleteDevice(0);
    Tmp_773 := 0;
    goto LM2;

  LM2:
    return;

  anon13_Then:
    goto L21;

  anon12_Then:
    goto L17;

  anon11_Then:
    goto L13;

  anon14_Then:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(pDevExt_12)], 8) == 0;
    call {:si_unique_call 1137} MoxaDisableInterfacesResources(PDevObj_14, 1);
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} yogi_error != 1;
    goto L9;

  anon15_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaStartOrQueue"} MoxaStartOrQueue(actual_Extension_16: int, actual_Irp_13: int, actual_QueueToExamine: int, actual_CurrentOpIrp_5: int, actual_Starter_1: int) returns (Tmp_778: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, Mem_T.CancelIrql__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartOrQueue"} MoxaStartOrQueue(actual_Extension_16: int, actual_Irp_13: int, actual_QueueToExamine: int, actual_CurrentOpIrp_5: int, actual_Starter_1: int) returns (Tmp_778: int)
{
  var {:pointer} sdv_291: int;
  var {:scalar} sdv_292: int;
  var {:scalar} oldIrql_21: int;
  var {:pointer} sdv_293: int;
  var {:pointer} Tmp_779: int;
  var {:pointer} Extension_16: int;
  var {:pointer} Irp_13: int;
  var {:pointer} QueueToExamine: int;
  var {:pointer} CurrentOpIrp_5: int;
  var {:scalar} Starter_1: int;
  var vslice_dummy_var_176: int;
  var vslice_dummy_var_177: int;

  anon0:
    Extension_16 := actual_Extension_16;
    Irp_13 := actual_Irp_13;
    QueueToExamine := actual_QueueToExamine;
    CurrentOpIrp_5 := actual_CurrentOpIrp_5;
    Starter_1 := actual_Starter_1;
    call {:si_unique_call 1138} Tmp_779 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_779 != 0;
    assume Tmp_779 > 0;
    Mem_T.INT4[Tmp_779] := oldIrql_21;
    call {:si_unique_call 1139} IoAcquireCancelSpinLock(Tmp_779);
    assume {:nonnull} Tmp_779 != 0;
    assume Tmp_779 > 0;
    oldIrql_21 := Mem_T.INT4[Tmp_779];
    call {:si_unique_call 1140} sdv_291 := sdv_IoGetCurrentIrpStackLocation(Irp_13);
    assume {:nonnull} sdv_291 != 0;
    assume sdv_291 > 0;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    call {:si_unique_call 1141} sdv_293 := sdv_IoGetCurrentIrpStackLocation(Irp_13);
    assume {:nonnull} Extension_16 != 0;
    assume Extension_16 > 0;
    assume {:nonnull} sdv_293 != 0;
    assume sdv_293 > 0;
    goto L11;

  L11:
    call {:si_unique_call 1142} sdv_292 := sdv_IsListEmpty(0);
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} sdv_292 != 0;
    assume {:nonnull} CurrentOpIrp_5 != 0;
    assume CurrentOpIrp_5 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:nonnull} CurrentOpIrp_5 != 0;
    assume CurrentOpIrp_5 > 0;
    call {:si_unique_call 1143} IoReleaseCancelSpinLock(oldIrql_21);
    goto anon29_Then, anon29_Else;

  anon29_Else:
    goto anon30_Then, anon30_Else;

  anon30_Else:
    goto anon31_Then, anon31_Else;

  anon31_Else:
    goto anon32_Then, anon32_Else;

  anon32_Else:
    assume {:IndirectCall} true;
    assume Starter_1 == li2bplFunctionConstant406;
    call {:si_unique_call 1144} Tmp_778 := MoxaStartFlush(Extension_16);
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon36_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon32_Then:
    assume {:IndirectCall} true;
    assume Starter_1 == li2bplFunctionConstant370;
    call {:si_unique_call 1145} Tmp_778 := MoxaStartMask(Extension_16);
    goto L1;

  anon31_Then:
    assume {:IndirectCall} true;
    assume Starter_1 == li2bplFunctionConstant164;
    call {:si_unique_call 1146} Tmp_778 := MoxaStartPurge(Extension_16);
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon35_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon30_Then:
    assume {:IndirectCall} true;
    assume Starter_1 == li2bplFunctionConstant140;
    call {:si_unique_call 1147} Tmp_778 := MoxaStartRead(Extension_16);
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon34_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon29_Then:
    assume {:IndirectCall} true;
    assume Starter_1 == li2bplFunctionConstant318;
    call {:si_unique_call 1148} Tmp_778 := MoxaStartWrite(Extension_16);
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  anon33_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon28_Then:
    goto L19;

  L19:
    assume {:nonnull} Irp_13 != 0;
    assume Irp_13 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:nonnull} Irp_13 != 0;
    assume Irp_13 > 0;
    call {:si_unique_call 1149} IoReleaseCancelSpinLock(oldIrql_21);
    call {:si_unique_call 1150} sdv_IoCompleteRequest(0, 0);
    call {:si_unique_call 1151} MoxaIRPEpilogue(Extension_16);
    Tmp_778 := -1073741536;
    goto L1;

  anon27_Then:
    assume {:nonnull} Irp_13 != 0;
    assume Irp_13 > 0;
    call {:si_unique_call 1152} sdv_IoMarkIrpPending(0);
    assume {:nonnull} Irp_13 != 0;
    assume Irp_13 > 0;
    call {:si_unique_call 1153} vslice_dummy_var_176 := sdv_InsertTailList(QueueToExamine, ListEntry_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(Irp_13))));
    call {:si_unique_call 1154} vslice_dummy_var_177 := sdv_IoSetCancelRoutine(Irp_13, li2bplFunctionConstant188);
    call {:si_unique_call 1155} IoReleaseCancelSpinLock(oldIrql_21);
    Tmp_778 := 259;
    goto L1;

  anon26_Then:
    assume {:partition} sdv_292 == 0;
    goto L19;

  anon25_Then:
    goto L11;
}



procedure {:origName "_sdv_init4"} _sdv_init4();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init4"} _sdv_init4()
{
  var vslice_dummy_var_178: int;

  anon0:
    call {:si_unique_call 1156} vslice_dummy_var_178 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaFuncWithDumbWait"} MoxaFuncWithDumbWait(actual_PortOfs_7: int, actual_Command_3: int, actual_Argument_5: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFuncWithDumbWait"} MoxaFuncWithDumbWait(actual_PortOfs_7: int, actual_Command_3: int, actual_Argument_5: int)
{
  var {:pointer} Tmp_784: int;
  var {:pointer} PortOfs_7: int;
  var {:scalar} Command_3: int;
  var {:scalar} Argument_5: int;
  var vslice_dummy_var_179: int;
  var vslice_dummy_var_180: int;

  anon0:
    call {:si_unique_call 1157} vslice_dummy_var_179 := __HAVOC_malloc(4);
    PortOfs_7 := actual_PortOfs_7;
    Command_3 := actual_Command_3;
    Argument_5 := actual_Argument_5;
    Tmp_784 := PortOfs_7;
    assume {:nonnull} Tmp_784 != 0;
    assume Tmp_784 > 0;
    Mem_T.INT4[Tmp_784] := Argument_5;
    assume {:nonnull} PortOfs_7 != 0;
    assume PortOfs_7 > 0;
    Mem_T.INT4[PortOfs_7] := Command_3;
    call {:si_unique_call 1158} vslice_dummy_var_180 := MoxaDumbWaitFinish(PortOfs_7);
    return;
}



procedure {:origName "GetDeviceRxQueueWithLock"} GetDeviceRxQueueWithLock(actual_Extension_17: int) returns (Tmp_785: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_current) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == 2 || sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "GetDeviceRxQueueWithLock"} GetDeviceRxQueueWithLock(actual_Extension_17: int) returns (Tmp_785: int)
{
  var {:pointer} Tmp_786: int;
  var {:scalar} count_5: int;
  var {:pointer} Tmp_787: int;
  var {:pointer} ofs_12: int;
  var {:scalar} lenMask_1: int;
  var {:pointer} rptr_1: int;
  var {:scalar} oldIrql_22: int;
  var {:pointer} Tmp_788: int;
  var {:scalar} controlIrql_2: int;
  var {:scalar} Tmp_789: int;
  var {:pointer} wptr_1: int;
  var {:pointer} Extension_17: int;
  var vslice_dummy_var_181: int;

  anon0:
    Extension_17 := actual_Extension_17;
    call {:si_unique_call 1159} Tmp_788 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_788 != 0;
    assume Tmp_788 > 0;
    Mem_T.INT4[Tmp_788] := oldIrql_22;
    call {:si_unique_call 1160} IoAcquireCancelSpinLock(Tmp_788);
    assume {:nonnull} Tmp_788 != 0;
    assume Tmp_788 > 0;
    oldIrql_22 := Mem_T.INT4[Tmp_788];
    assume {:nonnull} Extension_17 != 0;
    assume Extension_17 > 0;
    havoc ofs_12;
    rptr_1 := ofs_12;
    wptr_1 := ofs_12;
    Tmp_787 := ofs_12;
    assume {:nonnull} Tmp_787 != 0;
    assume Tmp_787 > 0;
    lenMask_1 := Mem_T.INT4[Tmp_787];
    assume {:nonnull} rptr_1 != 0;
    assume rptr_1 > 0;
    assume {:nonnull} wptr_1 != 0;
    assume wptr_1 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} Mem_T.INT4[wptr_1] >= Mem_T.INT4[rptr_1];
    assume {:nonnull} rptr_1 != 0;
    assume rptr_1 > 0;
    assume {:nonnull} wptr_1 != 0;
    assume wptr_1 > 0;
    Tmp_789 := Mem_T.INT4[wptr_1] - Mem_T.INT4[rptr_1];
    goto L20;

  L20:
    count_5 := Tmp_789;
    call {:si_unique_call 1161} Tmp_788 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_788 != 0;
    assume Tmp_788 > 0;
    Mem_T.INT4[Tmp_788] := controlIrql_2;
    call {:si_unique_call 1162} sdv_KeAcquireSpinLock(0, Tmp_788);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_788 != 0;
    assume Tmp_788 > 0;
    controlIrql_2 := Mem_T.INT4[Tmp_788];
    assume {:nonnull} ofs_12 != 0;
    assume ofs_12 > 0;
    Mem_T.INT4[ofs_12] := 27;
    call {:si_unique_call 1163} vslice_dummy_var_181 := MoxaWaitFinish(ofs_12);
    Tmp_786 := ofs_12;
    assume {:nonnull} Tmp_786 != 0;
    assume Tmp_786 > 0;
    count_5 := count_5 + Mem_T.INT4[Tmp_786];
    call {:si_unique_call 1164} sdv_KeReleaseSpinLock(0, controlIrql_2);
    call {:si_unique_call 1165} IoReleaseCancelSpinLock(oldIrql_22);
    Tmp_785 := count_5;
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    assume {:partition} Mem_T.INT4[rptr_1] > Mem_T.INT4[wptr_1];
    assume {:nonnull} rptr_1 != 0;
    assume rptr_1 > 0;
    assume {:nonnull} wptr_1 != 0;
    assume wptr_1 > 0;
    Tmp_789 := Mem_T.INT4[wptr_1] - Mem_T.INT4[rptr_1] + lenMask_1 + 1;
    goto L20;
}



procedure {:origName "MoxaWaitFinish"} MoxaWaitFinish(actual_PortOfs_8: int) returns (Tmp_790: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_790 == 0 || Tmp_790 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaWaitFinish"} MoxaWaitFinish(actual_PortOfs_8: int) returns (Tmp_790: int)
{
  var {:pointer} SD1_2: int;
  var {:pointer} SD1_3: int;
  var {:scalar} count_6: int;
  var {:scalar} cnt_1: int;
  var {:pointer} s_p_e_c_i_a_l_1: int;
  var {:pointer} Tmp_791: int;
  var {:scalar} interval_1: int;
  var {:pointer} Tmp_792: int;
  var {:scalar} currTc: int;
  var {:scalar} newTc: int;
  var {:pointer} s_p_e_c_i_a_l_2: int;
  var {:scalar} Tmp_793: int;
  var {:scalar} targetTc_1: int;
  var {:pointer} PortOfs_8: int;
  var boogieTmp: int;
  var vslice_dummy_var_182: int;
  var vslice_dummy_var_183: int;
  var vslice_dummy_var_184: int;
  var vslice_dummy_var_185: int;
  var vslice_dummy_var_186: int;
  var vslice_dummy_var_187: int;

  anon0:
    call {:si_unique_call 1166} interval_1 := __HAVOC_malloc(20);
    call {:si_unique_call 1167} currTc := __HAVOC_malloc(20);
    call {:si_unique_call 1168} newTc := __HAVOC_malloc(20);
    call {:si_unique_call 1169} vslice_dummy_var_182 := __HAVOC_malloc(20);
    call {:si_unique_call 1170} vslice_dummy_var_183 := __HAVOC_malloc(20);
    call {:si_unique_call 1171} vslice_dummy_var_184 := __HAVOC_malloc(20);
    call {:si_unique_call 1172} vslice_dummy_var_185 := __HAVOC_malloc(20);
    call {:si_unique_call 1173} vslice_dummy_var_186 := __HAVOC_malloc(20);
    call {:si_unique_call 1174} targetTc_1 := __HAVOC_malloc(20);
    PortOfs_8 := actual_PortOfs_8;
    cnt_1 := 1000;
    Tmp_791 := KeTickCount;
    assume {:nonnull} Tmp_791 != 0;
    assume Tmp_791 > 0;
    havoc s_p_e_c_i_a_l_1;
    goto L15;

  L15:
    call {:si_unique_call 1175} MoxaWaitFinish_loop_L15(s_p_e_c_i_a_l_1, currTc);
    goto L15_last;

  L15_last:
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_1 != 0;
    assume s_p_e_c_i_a_l_1 > 0;
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_1 != 0;
    assume s_p_e_c_i_a_l_1 > 0;
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_1 != 0;
    assume s_p_e_c_i_a_l_1 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    call {:si_unique_call 1176} vslice_dummy_var_187 := corral_nondet();
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    call {:si_unique_call 1177} boogieTmp := corral_nondet();
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    call {:si_unique_call 1178} boogieTmp := corral_nondet();
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    call {:si_unique_call 1179} boogieTmp := corral_nondet();
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    call {:si_unique_call 1180} boogieTmp := corral_nondet();
    assume {:nonnull} currTc != 0;
    assume currTc > 0;
    call {:si_unique_call 1181} boogieTmp := corral_nondet();
    call {:si_unique_call 1182} SD1_3 := RtlConvertUlongToLargeInteger(5000);
    assume {:nonnull} SD1_3 != 0;
    assume SD1_3 > 0;
    assume {:nonnull} interval_1 != 0;
    assume interval_1 > 0;
    assume {:nonnull} SD1_3 != 0;
    assume SD1_3 > 0;
    assume {:nonnull} interval_1 != 0;
    assume interval_1 > 0;
    assume {:nonnull} SD1_3 != 0;
    assume SD1_3 > 0;
    assume {:nonnull} interval_1 != 0;
    assume interval_1 > 0;
    assume {:nonnull} SD1_3 != 0;
    assume SD1_3 > 0;
    assume {:nonnull} interval_1 != 0;
    assume interval_1 > 0;
    assume {:nonnull} SD1_3 != 0;
    assume SD1_3 > 0;
    assume {:nonnull} interval_1 != 0;
    assume interval_1 > 0;
    call {:si_unique_call 1183} SD1_2 := RtlLargeIntegerAdd(currTc, interval_1);
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    goto L38;

  L38:
    call {:si_unique_call 1184} SD1_2, count_6, cnt_1, Tmp_792, s_p_e_c_i_a_l_2, Tmp_793, boogieTmp := MoxaWaitFinish_loop_L38(SD1_2, count_6, cnt_1, interval_1, Tmp_792, newTc, s_p_e_c_i_a_l_2, Tmp_793, targetTc_1, PortOfs_8, boogieTmp);
    goto L38_last;

  L38_last:
    count_6 := 0;
    goto L40;

  L40:
    call {:si_unique_call 1185} count_6, Tmp_792, s_p_e_c_i_a_l_2, boogieTmp := MoxaWaitFinish_loop_L40(count_6, Tmp_792, newTc, s_p_e_c_i_a_l_2, targetTc_1, boogieTmp);
    goto L40_last;

  L40_last:
    Tmp_792 := KeTickCount;
    assume {:nonnull} Tmp_792 != 0;
    assume Tmp_792 > 0;
    havoc s_p_e_c_i_a_l_2;
    goto L42;

  L42:
    call {:si_unique_call 1186} MoxaWaitFinish_loop_L42(newTc, s_p_e_c_i_a_l_2);
    goto L42_last;

  L42_last:
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_2 != 0;
    assume s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_2 != 0;
    assume s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} s_p_e_c_i_a_l_2 != 0;
    assume s_p_e_c_i_a_l_2 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    call {:si_unique_call 1187} boogieTmp := corral_nondet();
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    call {:si_unique_call 1188} boogieTmp := corral_nondet();
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    call {:si_unique_call 1189} boogieTmp := corral_nondet();
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    call {:si_unique_call 1190} boogieTmp := corral_nondet();
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    call {:si_unique_call 1191} boogieTmp := corral_nondet();
    count_6 := count_6 + 1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    goto L56;

  L56:
    assume {:nonnull} PortOfs_8 != 0;
    assume PortOfs_8 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} Mem_T.INT4[PortOfs_8] != 0;
    call {:si_unique_call 1192} SD1_2 := RtlLargeIntegerAdd(targetTc_1, interval_1);
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    assume {:nonnull} SD1_2 != 0;
    assume SD1_2 > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    Tmp_793 := cnt_1;
    cnt_1 := cnt_1 - 1;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} Tmp_793 == 0;
    Tmp_790 := 0;
    goto L1;

  L1:
    return;

  anon24_Then:
    assume {:partition} Tmp_793 != 0;
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    assume false;
    return;

  anon18_Then:
    assume {:partition} Mem_T.INT4[PortOfs_8] == 0;
    Tmp_790 := 1;
    goto L1;

  anon23_Then:
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} newTc != 0;
    assume newTc > 0;
    assume {:nonnull} targetTc_1 != 0;
    assume targetTc_1 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    goto L56;

  anon19_Then:
    goto anon19_Then_dummy;

  anon19_Then_dummy:
    assume false;
    return;

  anon20_Then:
    goto L56;

  anon17_Then:
    goto L64;

  anon22_Then:
    goto anon22_Then_dummy;

  anon22_Then_dummy:
    assume false;
    return;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    assume false;
    return;
}



procedure {:origName "GetDeviceTxQueueWithLock"} GetDeviceTxQueueWithLock(actual_Extension_18: int) returns (Tmp_795: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_current) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == 2 || sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "GetDeviceTxQueueWithLock"} GetDeviceTxQueueWithLock(actual_Extension_18: int) returns (Tmp_795: int)
{
  var {:pointer} Tmp_796: int;
  var {:scalar} count_7: int;
  var {:pointer} ofs_13: int;
  var {:scalar} lenMask_2: int;
  var {:pointer} rptr_2: int;
  var {:scalar} oldIrql_23: int;
  var {:pointer} Tmp_797: int;
  var {:pointer} Tmp_798: int;
  var {:scalar} controlIrql_3: int;
  var {:scalar} Tmp_799: int;
  var {:pointer} wptr_2: int;
  var {:pointer} Extension_18: int;
  var vslice_dummy_var_188: int;

  anon0:
    Extension_18 := actual_Extension_18;
    call {:si_unique_call 1193} Tmp_798 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_798 != 0;
    assume Tmp_798 > 0;
    Mem_T.INT4[Tmp_798] := oldIrql_23;
    call {:si_unique_call 1194} IoAcquireCancelSpinLock(Tmp_798);
    assume {:nonnull} Tmp_798 != 0;
    assume Tmp_798 > 0;
    oldIrql_23 := Mem_T.INT4[Tmp_798];
    assume {:nonnull} Extension_18 != 0;
    assume Extension_18 > 0;
    havoc ofs_13;
    rptr_2 := ofs_13;
    wptr_2 := ofs_13;
    Tmp_797 := ofs_13;
    assume {:nonnull} Tmp_797 != 0;
    assume Tmp_797 > 0;
    lenMask_2 := Mem_T.INT4[Tmp_797];
    assume {:nonnull} rptr_2 != 0;
    assume rptr_2 > 0;
    assume {:nonnull} wptr_2 != 0;
    assume wptr_2 > 0;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} Mem_T.INT4[wptr_2] >= Mem_T.INT4[rptr_2];
    assume {:nonnull} rptr_2 != 0;
    assume rptr_2 > 0;
    assume {:nonnull} wptr_2 != 0;
    assume wptr_2 > 0;
    Tmp_799 := Mem_T.INT4[wptr_2] - Mem_T.INT4[rptr_2];
    goto L20;

  L20:
    count_7 := Tmp_799;
    call {:si_unique_call 1195} Tmp_798 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_798 != 0;
    assume Tmp_798 > 0;
    Mem_T.INT4[Tmp_798] := controlIrql_3;
    call {:si_unique_call 1196} sdv_KeAcquireSpinLock(0, Tmp_798);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_798 != 0;
    assume Tmp_798 > 0;
    controlIrql_3 := Mem_T.INT4[Tmp_798];
    assume {:nonnull} ofs_13 != 0;
    assume ofs_13 > 0;
    Mem_T.INT4[ofs_13] := 28;
    call {:si_unique_call 1197} vslice_dummy_var_188 := MoxaWaitFinish(ofs_13);
    Tmp_796 := ofs_13;
    assume {:nonnull} Tmp_796 != 0;
    assume Tmp_796 > 0;
    count_7 := count_7 + Mem_T.INT4[Tmp_796];
    call {:si_unique_call 1198} sdv_KeReleaseSpinLock(0, controlIrql_3);
    call {:si_unique_call 1199} IoReleaseCancelSpinLock(oldIrql_23);
    Tmp_795 := count_7;
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    assume {:partition} Mem_T.INT4[rptr_2] > Mem_T.INT4[wptr_2];
    assume {:nonnull} rptr_2 != 0;
    assume rptr_2 > 0;
    assume {:nonnull} wptr_2 != 0;
    assume wptr_2 > 0;
    Tmp_799 := Mem_T.INT4[wptr_2] - Mem_T.INT4[rptr_2] + lenMask_2 + 1;
    goto L20;
}



procedure {:origName "MoxaDelay"} MoxaDelay(actual_t: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDelay"} MoxaDelay(actual_t: int)
{
  var {:pointer} structPtr888delay: int;
  var {:scalar} delay: int;
  var {:scalar} t: int;
  var vslice_dummy_var_189: int;
  var vslice_dummy_var_190: int;
  var vslice_dummy_var_191: int;
  var vslice_dummy_var_192: int;

  anon0:
    call {:si_unique_call 1200} vslice_dummy_var_189 := __HAVOC_malloc(4);
    call {:si_unique_call 1201} vslice_dummy_var_190 := __HAVOC_malloc(20);
    call {:si_unique_call 1202} vslice_dummy_var_191 := __HAVOC_malloc(20);
    call {:si_unique_call 1203} delay := __HAVOC_malloc(20);
    t := actual_t;
    t := t * 20000;
    call {:si_unique_call 1204} structPtr888delay := RtlConvertUlongToLargeInteger(t);
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    call {:si_unique_call 1205} structPtr888delay := RtlLargeIntegerNegate(delay);
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    assume {:nonnull} delay != 0;
    assume delay > 0;
    assume {:nonnull} structPtr888delay != 0;
    assume structPtr888delay > 0;
    call {:si_unique_call 1206} vslice_dummy_var_192 := KeDelayExecutionThread(0, 0, 0);
    return;
}



procedure {:origName "MoxaFilterCancelQueued"} MoxaFilterCancelQueued(actual_PDevObj_15: int, actual_PIrp_9: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4;
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFilterCancelQueued"} MoxaFilterCancelQueued(actual_PDevObj_15: int, actual_PIrp_9: int)
{
  var {:pointer} PDevObj_15: int;
  var {:pointer} PIrp_9: int;
  var vslice_dummy_var_193: int;
  var vslice_dummy_var_194: int;
  var vslice_dummy_var_195: int;

  anon0:
    call {:si_unique_call 1207} vslice_dummy_var_193 := __HAVOC_malloc(4);
    PDevObj_15 := actual_PDevObj_15;
    PIrp_9 := actual_PIrp_9;
    assume {:nonnull} PDevObj_15 != 0;
    assume PDevObj_15 > 0;
    call {:si_unique_call 1208} vslice_dummy_var_194 := sdv_IoGetCurrentIrpStackLocation(PIrp_9);
    assume {:nonnull} PIrp_9 != 0;
    assume PIrp_9 > 0;
    assume {:nonnull} PIrp_9 != 0;
    assume PIrp_9 > 0;
    call {:si_unique_call 1209} vslice_dummy_var_195 := sdv_RemoveEntryList(0);
    assume {:nonnull} PIrp_9 != 0;
    assume PIrp_9 > 0;
    call {:si_unique_call 1210} IoReleaseCancelSpinLock(Mem_T.CancelIrql__IRP[CancelIrql__IRP(PIrp_9)]);
    return;
}



procedure {:origName "MoxaGetDivisorFromBaud"} MoxaGetDivisorFromBaud(actual_ClockType: int, actual_DesiredBaud: int, actual_AppropriateDivisor: int) returns (Tmp_804: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} Tmp_804 == -1073741811 || Tmp_804 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaGetDivisorFromBaud"} MoxaGetDivisorFromBaud(actual_ClockType: int, actual_DesiredBaud: int, actual_AppropriateDivisor: int) returns (Tmp_804: int)
{
  var {:scalar} maxRemain: int;
  var {:scalar} remainder: int;
  var {:scalar} maxRemain11: int;
  var {:scalar} maxRemain98: int;
  var {:scalar} maxRemain14: int;
  var {:scalar} calculatedDivisor: int;
  var {:scalar} status_23: int;
  var {:scalar} clockRate: int;
  var {:scalar} denominator: int;
  var {:scalar} ClockType: int;
  var {:scalar} DesiredBaud: int;
  var {:pointer} AppropriateDivisor: int;

  anon0:
    ClockType := actual_ClockType;
    DesiredBaud := actual_DesiredBaud;
    AppropriateDivisor := actual_AppropriateDivisor;
    status_23 := 0;
    maxRemain98 := 98304;
    maxRemain11 := 110592;
    maxRemain14 := 147456;
    goto anon37_Then, anon37_Else;

  anon37_Else:
    assume {:partition} ClockType == 1;
    clockRate := 11059200;
    goto L19;

  L19:
    denominator := DesiredBaud * 16;
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} 0 >= DesiredBaud;
    assume {:nonnull} AppropriateDivisor != 0;
    assume AppropriateDivisor > 0;
    Mem_T.INT4[AppropriateDivisor] := -1;
    goto L23;

  L23:
    assume {:nonnull} AppropriateDivisor != 0;
    assume AppropriateDivisor > 0;
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} Mem_T.INT4[AppropriateDivisor] == -1;
    status_23 := -1073741811;
    goto L24;

  L24:
    Tmp_804 := status_23;
    return;

  anon29_Then:
    assume {:partition} Mem_T.INT4[AppropriateDivisor] != -1;
    goto L24;

  anon38_Then:
    assume {:partition} DesiredBaud > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} DesiredBaud > denominator;
    assume {:nonnull} AppropriateDivisor != 0;
    assume AppropriateDivisor > 0;
    Mem_T.INT4[AppropriateDivisor] := -1;
    goto L23;

  anon28_Then:
    assume {:partition} denominator >= DesiredBaud;
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} ClockType != 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    assume {:partition} ClockType == 1;
    maxRemain := maxRemain11;
    goto L32;

  L32:
    calculatedDivisor := INTDIV(clockRate, denominator);
    remainder := INTMOD(clockRate, denominator);
    goto anon39_Then, anon39_Else;

  anon39_Else:
    assume {:partition} remainder * 2 > clockRate;
    goto anon33_Then, anon33_Else;

  anon33_Else:
    assume {:partition} DesiredBaud != 110;
    calculatedDivisor := calculatedDivisor + 1;
    goto L35;

  L35:
    goto anon32_Then, anon32_Else;

  anon32_Else:
    assume {:partition} DesiredBaud >= 9600;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:partition} remainder >= maxRemain;
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} clockRate > remainder + maxRemain;
    calculatedDivisor := -1;
    goto L38;

  L38:
    goto anon34_Then, anon34_Else;

  anon34_Else:
    assume {:partition} denominator > clockRate;
    calculatedDivisor := -1;
    goto L42;

  L42:
    assume {:nonnull} AppropriateDivisor != 0;
    assume AppropriateDivisor > 0;
    Mem_T.INT4[AppropriateDivisor] := calculatedDivisor;
    goto L23;

  anon34_Then:
    assume {:partition} clockRate >= denominator;
    goto L42;

  anon36_Then:
    assume {:partition} remainder + maxRemain >= clockRate;
    goto L38;

  anon35_Then:
    assume {:partition} maxRemain > remainder;
    goto L38;

  anon32_Then:
    assume {:partition} 9600 > DesiredBaud;
    goto L38;

  anon33_Then:
    assume {:partition} DesiredBaud == 110;
    goto L35;

  anon39_Then:
    assume {:partition} clockRate >= remainder * 2;
    goto L35;

  anon31_Then:
    assume {:partition} ClockType != 1;
    maxRemain := maxRemain14;
    goto L32;

  anon30_Then:
    assume {:partition} ClockType == 0;
    maxRemain := maxRemain98;
    goto L32;

  anon37_Then:
    assume {:partition} ClockType != 1;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} ClockType == 2;
    clockRate := 14745600;
    goto L19;

  anon27_Then:
    assume {:partition} ClockType != 2;
    clockRate := 9830400;
    goto L19;
}



procedure {:origName "MoxaFilterIrps"} MoxaFilterIrps(actual_PIrp_10: int, actual_PDevExt_14: int) returns (Tmp_806: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaFilterIrps"} MoxaFilterIrps(actual_PIrp_10: int, actual_PDevExt_14: int) returns (Tmp_806: int)
{
  var {:scalar} oldIrqlFlags: int;
  var {:pointer} Tmp_807: int;
  var {:scalar} oldIrql_24: int;
  var {:pointer} pIrpStack_6: int;
  var {:pointer} PIrp_10: int;
  var {:pointer} PDevExt_14: int;
  var vslice_dummy_var_196: int;
  var vslice_dummy_var_197: int;

  anon0:
    PIrp_10 := actual_PIrp_10;
    PDevExt_14 := actual_PDevExt_14;
    call {:si_unique_call 1211} pIrpStack_6 := sdv_IoGetCurrentIrpStackLocation(PIrp_10);
    call {:si_unique_call 1212} Tmp_807 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_807 != 0;
    assume Tmp_807 > 0;
    Mem_T.INT4[Tmp_807] := oldIrqlFlags;
    call {:si_unique_call 1213} sdv_KeAcquireSpinLock(0, Tmp_807);
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Tmp_807 != 0;
    assume Tmp_807 > 0;
    oldIrqlFlags := Mem_T.INT4[Tmp_807];
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)] != 0;
    goto L14;

  L14:
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 1) != 0;
    goto L16;

  L16:
    call {:si_unique_call 1214} sdv_KeReleaseSpinLock(0, oldIrqlFlags);
    assume {:nonnull} pIrpStack_6 != 0;
    assume pIrpStack_6 > 0;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    Tmp_806 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon25_Then:
    assume {:nonnull} PIrp_10 != 0;
    assume PIrp_10 > 0;
    Tmp_806 := -1073741738;
    goto L1;

  anon23_Then:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 1) == 0;
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(PDevExt_14)], 4) == 0;
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 8) == 0;
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 2) != 0;
    call {:si_unique_call 1215} sdv_KeReleaseSpinLock(0, oldIrqlFlags);
    assume {:nonnull} pIrpStack_6 != 0;
    assume pIrpStack_6 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    Tmp_806 := 0;
    goto L1;

  anon28_Then:
    call {:si_unique_call 1216} Tmp_807 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_807 != 0;
    assume Tmp_807 > 0;
    Mem_T.INT4[Tmp_807] := oldIrql_24;
    call {:si_unique_call 1217} IoAcquireCancelSpinLock(Tmp_807);
    assume {:nonnull} Tmp_807 != 0;
    assume Tmp_807 > 0;
    oldIrql_24 := Mem_T.INT4[Tmp_807];
    assume {:nonnull} PIrp_10 != 0;
    assume PIrp_10 > 0;
    goto anon29_Then, anon29_Else;

  anon29_Else:
    call {:si_unique_call 1218} IoReleaseCancelSpinLock(oldIrql_24);
    assume {:nonnull} PIrp_10 != 0;
    assume PIrp_10 > 0;
    Tmp_806 := -1073741536;
    goto L1;

  anon29_Then:
    assume {:nonnull} PIrp_10 != 0;
    assume PIrp_10 > 0;
    call {:si_unique_call 1219} sdv_IoMarkIrpPending(0);
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    assume {:nonnull} PIrp_10 != 0;
    assume PIrp_10 > 0;
    call {:si_unique_call 1220} vslice_dummy_var_196 := sdv_InsertTailList(StalledIrpQueue__MOXA_DEVICE_EXTENSION(PDevExt_14), ListEntry_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(PIrp_10))));
    call {:si_unique_call 1221} vslice_dummy_var_197 := sdv_IoSetCancelRoutine(PIrp_10, li2bplFunctionConstant202);
    call {:si_unique_call 1222} IoReleaseCancelSpinLock(oldIrql_24);
    Tmp_806 := 259;
    goto L1;

  anon27_Then:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 2) == 0;
    call {:si_unique_call 1223} sdv_KeReleaseSpinLock(0, oldIrqlFlags);
    Tmp_806 := 0;
    goto L1;

  anon26_Then:
    assume {:partition} BAND(Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)], 8) != 0;
    goto L16;

  anon24_Then:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(PDevExt_14)], 4) != 0;
    goto L16;

  anon21_Then:
    assume {:partition} Mem_T.INT4[DevicePNPAccept__MOXA_DEVICE_EXTENSION(PDevExt_14)] == 0;
    assume {:nonnull} PDevExt_14 != 0;
    assume PDevExt_14 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(PDevExt_14)], 4) == 0;
    call {:si_unique_call 1224} sdv_KeReleaseSpinLock(0, oldIrqlFlags);
    Tmp_806 := 0;
    goto L1;

  anon22_Then:
    assume {:partition} BAND(Mem_T.INT4[Flags__MOXA_DEVICE_EXTENSION(PDevExt_14)], 4) != 0;
    goto L14;

  anon30_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaDumbWaitFinish"} MoxaDumbWaitFinish(actual_PortOfs_9: int) returns (Tmp_808: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_808 == 0 || Tmp_808 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaDumbWaitFinish"} MoxaDumbWaitFinish(actual_PortOfs_9: int) returns (Tmp_808: int)
{
  var {:pointer} structPtr888targetTc: int;
  var {:pointer} structPtr888interval: int;
  var {:scalar} count_8: int;
  var {:pointer} s_p_e_c_i_a_l_3: int;
  var {:scalar} cnt_2: int;
  var {:scalar} interval: int;
  var {:scalar} currTc_1: int;
  var {:scalar} newTc_1: int;
  var {:pointer} s_p_e_c_i_a_l_4: int;
  var {:scalar} targetTc: int;
  var {:scalar} Tmp_809: int;
  var {:pointer} Tmp_810: int;
  var {:pointer} Tmp_812: int;
  var {:pointer} PortOfs_9: int;
  var boogieTmp: int;
  var vslice_dummy_var_198: int;
  var vslice_dummy_var_199: int;
  var vslice_dummy_var_200: int;
  var vslice_dummy_var_201: int;
  var vslice_dummy_var_202: int;
  var vslice_dummy_var_203: int;

  anon0:
    call {:si_unique_call 1225} interval := __HAVOC_malloc(20);
    call {:si_unique_call 1226} currTc_1 := __HAVOC_malloc(20);
    call {:si_unique_call 1227} newTc_1 := __HAVOC_malloc(20);
    call {:si_unique_call 1228} vslice_dummy_var_198 := __HAVOC_malloc(20);
    call {:si_unique_call 1229} vslice_dummy_var_199 := __HAVOC_malloc(20);
    call {:si_unique_call 1230} vslice_dummy_var_200 := __HAVOC_malloc(20);
    call {:si_unique_call 1231} vslice_dummy_var_201 := __HAVOC_malloc(20);
    call {:si_unique_call 1232} vslice_dummy_var_202 := __HAVOC_malloc(20);
    call {:si_unique_call 1233} targetTc := __HAVOC_malloc(20);
    PortOfs_9 := actual_PortOfs_9;
    cnt_2 := 1000;
    Tmp_812 := KeTickCount;
    assume {:nonnull} Tmp_812 != 0;
    assume Tmp_812 > 0;
    havoc s_p_e_c_i_a_l_3;
    goto L15;

  L15:
    call {:si_unique_call 1234} MoxaDumbWaitFinish_loop_L15(s_p_e_c_i_a_l_3, currTc_1);
    goto L15_last;

  L15_last:
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_3 != 0;
    assume s_p_e_c_i_a_l_3 > 0;
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_3 != 0;
    assume s_p_e_c_i_a_l_3 > 0;
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_3 != 0;
    assume s_p_e_c_i_a_l_3 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    call {:si_unique_call 1235} vslice_dummy_var_203 := corral_nondet();
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    call {:si_unique_call 1236} boogieTmp := corral_nondet();
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    call {:si_unique_call 1237} boogieTmp := corral_nondet();
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    call {:si_unique_call 1238} boogieTmp := corral_nondet();
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    call {:si_unique_call 1239} boogieTmp := corral_nondet();
    assume {:nonnull} currTc_1 != 0;
    assume currTc_1 > 0;
    call {:si_unique_call 1240} boogieTmp := corral_nondet();
    call {:si_unique_call 1241} structPtr888interval := RtlConvertUlongToLargeInteger(5000);
    assume {:nonnull} interval != 0;
    assume interval > 0;
    assume {:nonnull} structPtr888interval != 0;
    assume structPtr888interval > 0;
    assume {:nonnull} interval != 0;
    assume interval > 0;
    assume {:nonnull} structPtr888interval != 0;
    assume structPtr888interval > 0;
    assume {:nonnull} interval != 0;
    assume interval > 0;
    assume {:nonnull} structPtr888interval != 0;
    assume structPtr888interval > 0;
    assume {:nonnull} interval != 0;
    assume interval > 0;
    assume {:nonnull} structPtr888interval != 0;
    assume structPtr888interval > 0;
    assume {:nonnull} interval != 0;
    assume interval > 0;
    assume {:nonnull} structPtr888interval != 0;
    assume structPtr888interval > 0;
    call {:si_unique_call 1242} structPtr888targetTc := RtlLargeIntegerAdd(currTc_1, interval);
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    goto L38;

  L38:
    call {:si_unique_call 1243} structPtr888targetTc, count_8, cnt_2, s_p_e_c_i_a_l_4, Tmp_809, Tmp_810, boogieTmp := MoxaDumbWaitFinish_loop_L38(structPtr888targetTc, count_8, cnt_2, interval, newTc_1, s_p_e_c_i_a_l_4, targetTc, Tmp_809, Tmp_810, PortOfs_9, boogieTmp);
    goto L38_last;

  L38_last:
    count_8 := 0;
    goto L40;

  L40:
    call {:si_unique_call 1244} count_8, s_p_e_c_i_a_l_4, Tmp_810, boogieTmp := MoxaDumbWaitFinish_loop_L40(count_8, newTc_1, s_p_e_c_i_a_l_4, targetTc, Tmp_810, boogieTmp);
    goto L40_last;

  L40_last:
    Tmp_810 := KeTickCount;
    assume {:nonnull} Tmp_810 != 0;
    assume Tmp_810 > 0;
    havoc s_p_e_c_i_a_l_4;
    goto L42;

  L42:
    call {:si_unique_call 1245} MoxaDumbWaitFinish_loop_L42(newTc_1, s_p_e_c_i_a_l_4);
    goto L42_last;

  L42_last:
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_4 != 0;
    assume s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_4 != 0;
    assume s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} s_p_e_c_i_a_l_4 != 0;
    assume s_p_e_c_i_a_l_4 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    call {:si_unique_call 1246} boogieTmp := corral_nondet();
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    call {:si_unique_call 1247} boogieTmp := corral_nondet();
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    call {:si_unique_call 1248} boogieTmp := corral_nondet();
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    call {:si_unique_call 1249} boogieTmp := corral_nondet();
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    call {:si_unique_call 1250} boogieTmp := corral_nondet();
    count_8 := count_8 + 1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    goto L56;

  L56:
    assume {:nonnull} PortOfs_9 != 0;
    assume PortOfs_9 > 0;
    goto anon18_Then, anon18_Else;

  anon18_Else:
    assume {:partition} Mem_T.INT4[PortOfs_9] != 0;
    call {:si_unique_call 1251} structPtr888targetTc := RtlLargeIntegerAdd(targetTc, interval);
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    assume {:nonnull} structPtr888targetTc != 0;
    assume structPtr888targetTc > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    Tmp_809 := cnt_2;
    cnt_2 := cnt_2 - 1;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} Tmp_809 == 0;
    Tmp_808 := 0;
    goto L1;

  L1:
    return;

  anon24_Then:
    assume {:partition} Tmp_809 != 0;
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    assume false;
    return;

  anon18_Then:
    assume {:partition} Mem_T.INT4[PortOfs_9] == 0;
    Tmp_808 := 1;
    goto L1;

  anon23_Then:
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} newTc_1 != 0;
    assume newTc_1 > 0;
    assume {:nonnull} targetTc != 0;
    assume targetTc > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    goto L56;

  anon19_Then:
    goto anon19_Then_dummy;

  anon19_Then_dummy:
    assume false;
    return;

  anon20_Then:
    goto L56;

  anon17_Then:
    goto L64;

  anon22_Then:
    goto anon22_Then_dummy;

  anon22_Then_dummy:
    assume false;
    return;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    assume false;
    return;
}



procedure {:origName "RtlConvertUlongToLargeInteger"} RtlConvertUlongToLargeInteger(actual_UnsignedInteger: int) returns (SD5_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlConvertUlongToLargeInteger"} RtlConvertUlongToLargeInteger(actual_UnsignedInteger: int) returns (SD5_1: int)
{
  var {:scalar} Tmp_5: int;
  var {:scalar} Result: int;
  var {:scalar} UnsignedInteger: int;

  anon0:
    call {:si_unique_call 1252} Tmp_5 := __HAVOC_malloc(20);
    call {:si_unique_call 1253} Result := __HAVOC_malloc(20);
    UnsignedInteger := actual_UnsignedInteger;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Tmp_5 != 0;
    assume Tmp_5 > 0;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Tmp_5 != 0;
    assume Tmp_5 > 0;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Tmp_5 != 0;
    assume Tmp_5 > 0;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Tmp_5 != 0;
    assume Tmp_5 > 0;
    assume {:nonnull} Result != 0;
    assume Result > 0;
    assume {:nonnull} Tmp_5 != 0;
    assume Tmp_5 > 0;
    SD5_1 := Tmp_5;
    return;
}



procedure {:origName "RtlLargeIntegerAdd"} RtlLargeIntegerAdd(actual_structPtr888Addend1: int, actual_structPtr888Addend2: int) returns (SD4_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlLargeIntegerAdd"} RtlLargeIntegerAdd(actual_structPtr888Addend1: int, actual_structPtr888Addend2: int) returns (SD4_1: int)
{
  var {:scalar} Addend1: int;
  var {:scalar} Addend2: int;
  var {:scalar} Tmp_4: int;
  var {:scalar} Sum: int;
  var {:pointer} structPtr888Addend1: int;
  var {:pointer} structPtr888Addend2: int;

  anon0:
    call {:si_unique_call 1254} Addend1 := __HAVOC_malloc(20);
    call {:si_unique_call 1255} Addend2 := __HAVOC_malloc(20);
    call {:si_unique_call 1256} Tmp_4 := __HAVOC_malloc(20);
    call {:si_unique_call 1257} Sum := __HAVOC_malloc(20);
    structPtr888Addend1 := actual_structPtr888Addend1;
    structPtr888Addend2 := actual_structPtr888Addend2;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} structPtr888Addend1 != 0;
    assume structPtr888Addend1 > 0;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} structPtr888Addend1 != 0;
    assume structPtr888Addend1 > 0;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} structPtr888Addend1 != 0;
    assume structPtr888Addend1 > 0;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} structPtr888Addend1 != 0;
    assume structPtr888Addend1 > 0;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} structPtr888Addend1 != 0;
    assume structPtr888Addend1 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} structPtr888Addend2 != 0;
    assume structPtr888Addend2 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} structPtr888Addend2 != 0;
    assume structPtr888Addend2 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} structPtr888Addend2 != 0;
    assume structPtr888Addend2 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} structPtr888Addend2 != 0;
    assume structPtr888Addend2 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} structPtr888Addend2 != 0;
    assume structPtr888Addend2 > 0;
    assume {:nonnull} Addend1 != 0;
    assume Addend1 > 0;
    assume {:nonnull} Addend2 != 0;
    assume Addend2 > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Tmp_4 != 0;
    assume Tmp_4 > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Tmp_4 != 0;
    assume Tmp_4 > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Tmp_4 != 0;
    assume Tmp_4 > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Tmp_4 != 0;
    assume Tmp_4 > 0;
    assume {:nonnull} Sum != 0;
    assume Sum > 0;
    assume {:nonnull} Tmp_4 != 0;
    assume Tmp_4 > 0;
    SD4_1 := Tmp_4;
    return;
}



procedure {:origName "InitializeListHead"} InitializeListHead(actual_ListHead: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "InitializeListHead"} InitializeListHead(actual_ListHead: int)
{
  var {:pointer} ListHead: int;
  var vslice_dummy_var_204: int;

  anon0:
    call {:si_unique_call 1258} vslice_dummy_var_204 := __HAVOC_malloc(4);
    ListHead := actual_ListHead;
    assume {:nonnull} ListHead != 0;
    assume ListHead > 0;
    assume {:nonnull} ListHead != 0;
    assume ListHead > 0;
    return;
}



procedure {:origName "RemoveHeadList"} RemoveHeadList(actual_ListHead_1: int) returns (Tmp_817: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RemoveHeadList"} RemoveHeadList(actual_ListHead_1: int) returns (Tmp_817: int)
{
  var {:pointer} Entry: int;
  var {:pointer} Flink: int;
  var {:pointer} ListHead_1: int;

  anon0:
    ListHead_1 := actual_ListHead_1;
    assume {:nonnull} ListHead_1 != 0;
    assume ListHead_1 > 0;
    havoc Entry;
    assume {:nonnull} Entry != 0;
    assume Entry > 0;
    havoc Flink;
    assume {:nonnull} ListHead_1 != 0;
    assume ListHead_1 > 0;
    assume {:nonnull} Flink != 0;
    assume Flink > 0;
    Tmp_817 := Entry;
    return;
}



procedure {:origName "RtlEnlargedUnsignedMultiply"} RtlEnlargedUnsignedMultiply(actual_Multiplicand: int, actual_Multiplier: int) returns (SD3_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlEnlargedUnsignedMultiply"} RtlEnlargedUnsignedMultiply(actual_Multiplicand: int, actual_Multiplier: int) returns (SD3_1: int)
{
  var {:scalar} Tmp_3: int;
  var {:scalar} Product: int;
  var {:scalar} Multiplicand: int;
  var {:scalar} Multiplier: int;

  anon0:
    call {:si_unique_call 1259} Tmp_3 := __HAVOC_malloc(20);
    call {:si_unique_call 1260} Product := __HAVOC_malloc(20);
    Multiplicand := actual_Multiplicand;
    Multiplier := actual_Multiplier;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Tmp_3 != 0;
    assume Tmp_3 > 0;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Tmp_3 != 0;
    assume Tmp_3 > 0;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Tmp_3 != 0;
    assume Tmp_3 > 0;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Tmp_3 != 0;
    assume Tmp_3 > 0;
    assume {:nonnull} Product != 0;
    assume Product > 0;
    assume {:nonnull} Tmp_3 != 0;
    assume Tmp_3 > 0;
    SD3_1 := Tmp_3;
    return;
}



procedure {:origName "_sdv_init1"} _sdv_init1();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init1"} _sdv_init1()
{
  var vslice_dummy_var_205: int;

  anon0:
    call {:si_unique_call 1261} vslice_dummy_var_205 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "RtlLargeIntegerNegate"} RtlLargeIntegerNegate(actual_structPtr888Subtrahend: int) returns (SD2_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlLargeIntegerNegate"} RtlLargeIntegerNegate(actual_structPtr888Subtrahend: int) returns (SD2_1: int)
{
  var {:scalar} Subtrahend: int;
  var {:scalar} Difference: int;
  var {:scalar} Tmp_2: int;
  var {:pointer} structPtr888Subtrahend: int;

  anon0:
    call {:si_unique_call 1262} Subtrahend := __HAVOC_malloc(20);
    call {:si_unique_call 1263} Difference := __HAVOC_malloc(20);
    call {:si_unique_call 1264} Tmp_2 := __HAVOC_malloc(20);
    structPtr888Subtrahend := actual_structPtr888Subtrahend;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} structPtr888Subtrahend != 0;
    assume structPtr888Subtrahend > 0;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} structPtr888Subtrahend != 0;
    assume structPtr888Subtrahend > 0;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} structPtr888Subtrahend != 0;
    assume structPtr888Subtrahend > 0;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} structPtr888Subtrahend != 0;
    assume structPtr888Subtrahend > 0;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} structPtr888Subtrahend != 0;
    assume structPtr888Subtrahend > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Subtrahend != 0;
    assume Subtrahend > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Tmp_2 != 0;
    assume Tmp_2 > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Tmp_2 != 0;
    assume Tmp_2 > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Tmp_2 != 0;
    assume Tmp_2 > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Tmp_2 != 0;
    assume Tmp_2 > 0;
    assume {:nonnull} Difference != 0;
    assume Difference > 0;
    assume {:nonnull} Tmp_2 != 0;
    assume Tmp_2 > 0;
    SD2_1 := Tmp_2;
    return;
}



procedure {:origName "MoxaCompleteWait"} MoxaCompleteWait(actual_Dpc_9: int, actual_DeferredContext_8: int, actual_SystemContext1_8: int, actual_SystemContext2_8: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCompleteWait"} MoxaCompleteWait(actual_Dpc_9: int, actual_DeferredContext_8: int, actual_SystemContext1_8: int, actual_SystemContext2_8: int)
{
  var {:scalar} oldIrql_25: int;
  var {:pointer} extension_26: int;
  var {:pointer} Tmp_824: int;
  var {:pointer} Dpc_9: int;
  var {:pointer} DeferredContext_8: int;
  var vslice_dummy_var_206: int;

  anon0:
    call {:si_unique_call 1265} vslice_dummy_var_206 := __HAVOC_malloc(4);
    Dpc_9 := actual_Dpc_9;
    DeferredContext_8 := actual_DeferredContext_8;
    extension_26 := DeferredContext_8;
    call {:si_unique_call 1266} Tmp_824 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_824 != 0;
    assume Tmp_824 > 0;
    Mem_T.INT4[Tmp_824] := oldIrql_25;
    call {:si_unique_call 1267} IoAcquireCancelSpinLock(Tmp_824);
    assume {:nonnull} Tmp_824 != 0;
    assume Tmp_824 > 0;
    oldIrql_25 := Mem_T.INT4[Tmp_824];
    assume {:nonnull} extension_26 != 0;
    assume extension_26 > 0;
    call {:si_unique_call 1268} MoxaTryToCompleteCurrent(extension_26, 0, oldIrql_25, 0, CurrentWaitIrp__MOXA_DEVICE_EXTENSION(extension_26), 0, 0, 0, 0, 0);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1269} MoxaDpcEpilogue(extension_26, Dpc_9);
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "_sdv_init17"} _sdv_init17();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init17"} _sdv_init17()
{
  var vslice_dummy_var_207: int;

  anon0:
    call {:si_unique_call 1270} vslice_dummy_var_207 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "MoxaStartMask"} MoxaStartMask(actual_Extension_19: int) returns (Tmp_827: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelRoutine__IRP, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaStartMask"} MoxaStartMask(actual_Extension_19: int) returns (Tmp_827: int)
{
  var {:pointer} Tmp_828: int;
  var {:pointer} Tmp_829: int;
  var {:pointer} Tmp_830: int;
  var {:pointer} irpSp_8: int;
  var {:pointer} Tmp_831: int;
  var {:scalar} setFirstStatus_2: int;
  var {:pointer} newIrp_5: int;
  var {:scalar} oldIrql_26: int;
  var {:pointer} sdv_321: int;
  var {:pointer} sdv_322: int;
  var {:pointer} Tmp_832: int;
  var {:pointer} Tmp_833: int;
  var {:scalar} firstStatus_2: int;
  var {:pointer} Extension_19: int;
  var vslice_dummy_var_208: int;
  var vslice_dummy_var_209: int;
  var vslice_dummy_var_210: int;
  var vslice_dummy_var_1322: int;
  var vslice_dummy_var_1323: int;
  var vslice_dummy_var_1324: int;
  var vslice_dummy_var_1325: int;

  anon0:
    call {:si_unique_call 1271} newIrp_5 := __HAVOC_malloc(4);
    Extension_19 := actual_Extension_19;
    setFirstStatus_2 := 0;
    goto L8;

  L8:
    call {:si_unique_call 1272} Tmp_828, Tmp_829, Tmp_830, irpSp_8, Tmp_831, setFirstStatus_2, oldIrql_26, sdv_321, sdv_322, Tmp_832, Tmp_833, firstStatus_2, vslice_dummy_var_208, vslice_dummy_var_209, vslice_dummy_var_210 := MoxaStartMask_loop_L8(Tmp_828, Tmp_829, Tmp_830, irpSp_8, Tmp_831, setFirstStatus_2, newIrp_5, oldIrql_26, sdv_321, sdv_322, Tmp_832, Tmp_833, firstStatus_2, Extension_19, vslice_dummy_var_208, vslice_dummy_var_209, vslice_dummy_var_210);
    goto L8_last;

  L8_last:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc vslice_dummy_var_1325;
    call {:si_unique_call 1287} irpSp_8 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1325);
    assume {:nonnull} irpSp_8 != 0;
    assume irpSp_8 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    call {:si_unique_call 1273} vslice_dummy_var_208 := KeSynchronizeExecution(0, li2bplFunctionConstant417, 0);
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc Tmp_833;
    assume {:nonnull} Tmp_833 != 0;
    assume Tmp_833 > 0;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} setFirstStatus_2 != 0;
    goto L20;

  L20:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    call {:si_unique_call 1274} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(Extension_19), newIrp_5, 1, Extension_19);
    goto L23;

  L23:
    assume {:nonnull} newIrp_5 != 0;
    assume newIrp_5 > 0;
    goto anon21_Then, anon21_Else;

  anon21_Else:
    Tmp_827 := firstStatus_2;
    return;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    assume false;
    return;

  anon25_Then:
    assume {:partition} setFirstStatus_2 == 0;
    firstStatus_2 := 0;
    setFirstStatus_2 := 1;
    goto L20;

  anon19_Then:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    call {:si_unique_call 1275} Tmp_832 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_832 != 0;
    assume Tmp_832 > 0;
    Mem_T.INT4[Tmp_832] := oldIrql_26;
    call {:si_unique_call 1276} IoAcquireCancelSpinLock(Tmp_832);
    assume {:nonnull} Tmp_832 != 0;
    assume Tmp_832 > 0;
    oldIrql_26 := Mem_T.INT4[Tmp_832];
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc Tmp_830;
    assume {:nonnull} Tmp_830 != 0;
    assume Tmp_830 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc Tmp_831;
    assume {:nonnull} Tmp_831 != 0;
    assume Tmp_831 > 0;
    call {:si_unique_call 1277} IoReleaseCancelSpinLock(oldIrql_26);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} setFirstStatus_2 != 0;
    goto L40;

  L40:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    call {:si_unique_call 1278} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(Extension_19), newIrp_5, 1, Extension_19);
    goto L23;

  anon24_Then:
    assume {:partition} setFirstStatus_2 == 0;
    firstStatus_2 := -1073741536;
    setFirstStatus_2 := 1;
    goto L40;

  anon27_Then:
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} setFirstStatus_2 != 0;
    goto L45;

  L45:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc vslice_dummy_var_1322;
    call {:si_unique_call 1279} sdv_321 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1322);
    assume {:nonnull} sdv_321 != 0;
    assume sdv_321 > 0;
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc vslice_dummy_var_1323;
    call {:si_unique_call 1280} vslice_dummy_var_209 := sdv_IoSetCancelRoutine(vslice_dummy_var_1323, li2bplFunctionConstant418);
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc vslice_dummy_var_1324;
    call {:si_unique_call 1281} sdv_322 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1324);
    assume {:nonnull} sdv_322 != 0;
    assume sdv_322 > 0;
    Tmp_829 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(sdv_322)));
    assume {:nonnull} sdv_322 != 0;
    assume sdv_322 > 0;
    assume {:nonnull} Tmp_829 != 0;
    assume Tmp_829 > 0;
    assume {:nonnull} sdv_322 != 0;
    assume sdv_322 > 0;
    call {:si_unique_call 1282} vslice_dummy_var_210 := KeSynchronizeExecution(0, li2bplFunctionConstant419, 0);
    call {:si_unique_call 1283} IoReleaseCancelSpinLock(oldIrql_26);
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    call {:si_unique_call 1284} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(Extension_19), newIrp_5, 0, Extension_19);
    goto L23;

  anon23_Then:
    assume {:partition} setFirstStatus_2 == 0;
    firstStatus_2 := 259;
    setFirstStatus_2 := 1;
    call {:si_unique_call 1285} sdv_IoMarkIrpPending(0);
    goto L45;

  anon22_Then:
    goto L26;

  L26:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    havoc Tmp_828;
    assume {:nonnull} Tmp_828 != 0;
    assume Tmp_828 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} setFirstStatus_2 != 0;
    goto L72;

  L72:
    assume {:nonnull} Extension_19 != 0;
    assume Extension_19 > 0;
    call {:si_unique_call 1286} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(Extension_19), newIrp_5, 1, Extension_19);
    goto L23;

  anon26_Then:
    assume {:partition} setFirstStatus_2 == 0;
    firstStatus_2 := -1073741811;
    setFirstStatus_2 := 1;
    goto L72;

  anon20_Then:
    goto L26;
}



procedure {:origName "MoxaCancelWait"} MoxaCancelWait(actual_DeviceObject_15: int, actual_Irp_14: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_5) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_5) || sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaCancelWait"} MoxaCancelWait(actual_DeviceObject_15: int, actual_Irp_14: int)
{
  var {:pointer} extension_27: int;
  var {:pointer} DeviceObject_15: int;
  var {:pointer} Irp_14: int;
  var vslice_dummy_var_211: int;

  anon0:
    call {:si_unique_call 1288} vslice_dummy_var_211 := __HAVOC_malloc(4);
    DeviceObject_15 := actual_DeviceObject_15;
    Irp_14 := actual_Irp_14;
    assume {:nonnull} DeviceObject_15 != 0;
    assume DeviceObject_15 > 0;
    havoc extension_27;
    assume {:nonnull} Irp_14 != 0;
    assume Irp_14 > 0;
    assume {:nonnull} extension_27 != 0;
    assume extension_27 > 0;
    call {:si_unique_call 1289} MoxaTryToCompleteCurrent(extension_27, li2bplFunctionConstant420, Mem_T.CancelIrql__IRP[CancelIrql__IRP(Irp_14)], -1073741536, CurrentWaitIrp__MOXA_DEVICE_EXTENSION(extension_27), 0, 0, 0, 0, 0);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "sdv_InsertTailList"} sdv_InsertTailList(actual_sdv_336: int, actual_sdv_337: int) returns (Tmp_846: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_InsertTailList"} sdv_InsertTailList(actual_sdv_336: int, actual_sdv_337: int) returns (Tmp_846: int)
{
  var {:scalar} sdv_338: int;

  anon0:
    call {:si_unique_call 1290} Tmp_846 := __HAVOC_malloc(4);
    call {:si_unique_call 1291} sdv_338 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_846 != 0;
    assume Tmp_846 > 0;
    assume {:nonnull} sdv_338 != 0;
    assume sdv_338 > 0;
    Mem_T.INT4[Tmp_846] := Mem_T.INT4[sdv_338];
    return;
}



procedure {:origName "sdv_IoCopyCurrentIrpStackLocationToNext"} {:osmodel} sdv_IoCopyCurrentIrpStackLocationToNext(actual_pirp: int);
  modifies alloc, Mem_T.MinorFunction__IO_STACK_LOCATION;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoCopyCurrentIrpStackLocationToNext"} {:osmodel} sdv_IoCopyCurrentIrpStackLocationToNext(actual_pirp: int)
{
  var {:pointer} pirp: int;
  var vslice_dummy_var_212: int;

  anon0:
    call {:si_unique_call 1292} vslice_dummy_var_212 := __HAVOC_malloc(4);
    pirp := actual_pirp;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} pirp == sdv_harnessIrp;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_harnessStackLocation_next)] := Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_harnessStackLocation)];
    goto L4;

  L4:
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} pirp == sdv_other_harnessIrp;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_other_harnessStackLocation_next)] := Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_other_harnessStackLocation)];
    goto L1;

  L1:
    return;

  anon6_Then:
    assume {:partition} pirp != sdv_other_harnessIrp;
    goto L1;

  anon5_Then:
    assume {:partition} pirp != sdv_harnessIrp;
    goto L4;
}



procedure {:origName "sdv_containing_record"} {:osmodel} sdv_containing_record(actual_Address: int, actual_FieldOffset: int) returns (Tmp_856: int);
  free ensures {:va_keep} Tmp_856 == actual_Address;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_containing_record"} {:osmodel} sdv_containing_record(actual_Address: int, actual_FieldOffset: int) returns (Tmp_856: int)
{
  var {:pointer} record: int;
  var {:pointer} Address: int;

  anon0:
    Address := actual_Address;
    record := Address;
    Tmp_856 := record;
    return;
}



procedure {:origName "sdv_KeAcquireSpinLock"} {:osmodel} sdv_KeAcquireSpinLock(actual_SpinLock: int, actual_p: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> sdv_irql_current <= 2 && sdv_irql_previous <= 2 && sdv_irql_previous_2 <= 2 && sdv_irql_previous_3 <= 2 && sdv_irql_current >= 0 && sdv_irql_previous >= 0 && sdv_irql_previous_2 >= 0 && sdv_irql_previous_3 >= 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous) || sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == 2 || sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_current) || sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_KeAcquireSpinLock"} {:osmodel} sdv_KeAcquireSpinLock(actual_SpinLock: int, actual_p: int)
{
  var {:pointer} p: int;
  var vslice_dummy_var_213: int;

  anon0:
    call {:si_unique_call 1293} vslice_dummy_var_213 := __HAVOC_malloc(4);
    p := actual_p;
    call {:si_unique_call 1294} SLIC_sdv_KeAcquireSpinLock_entry(strConst__li2bpl25);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    assume {:nonnull} p != 0;
    assume p > 0;
    Mem_T.INT4[p] := sdv_irql_previous;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "KeSetTimer"} {:osmodel} KeSetTimer(actual_Timer_2: int, actual_structPtr888DueTime: int, actual_Dpc_10: int) returns (Tmp_860: int);
  modifies alloc, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeSetTimer"} {:osmodel} KeSetTimer(actual_Timer_2: int, actual_structPtr888DueTime: int, actual_Dpc_10: int) returns (Tmp_860: int)
{
  var {:scalar} DueTime: int;
  var {:pointer} structPtr888DueTime: int;

  anon0:
    call {:si_unique_call 1295} DueTime := __HAVOC_malloc(20);
    structPtr888DueTime := actual_structPtr888DueTime;
    assume {:nonnull} DueTime != 0;
    assume DueTime > 0;
    assume {:nonnull} structPtr888DueTime != 0;
    assume structPtr888DueTime > 0;
    assume {:nonnull} DueTime != 0;
    assume DueTime > 0;
    assume {:nonnull} structPtr888DueTime != 0;
    assume structPtr888DueTime > 0;
    assume {:nonnull} DueTime != 0;
    assume DueTime > 0;
    assume {:nonnull} structPtr888DueTime != 0;
    assume structPtr888DueTime > 0;
    assume {:nonnull} DueTime != 0;
    assume DueTime > 0;
    assume {:nonnull} structPtr888DueTime != 0;
    assume structPtr888DueTime > 0;
    assume {:nonnull} DueTime != 0;
    assume DueTime > 0;
    assume {:nonnull} structPtr888DueTime != 0;
    assume structPtr888DueTime > 0;
    call {:si_unique_call 1296} SLIC_KeSetTimer_entry(strConst__li2bpl25);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    Tmp_860 := 1;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon5_Then:
    Tmp_860 := 0;
    goto L1;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "sdv_IoGetNextIrpStackLocation"} {:osmodel} sdv_IoGetNextIrpStackLocation(actual_pirp_1: int) returns (Tmp_862: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoGetNextIrpStackLocation"} {:osmodel} sdv_IoGetNextIrpStackLocation(actual_pirp_1: int) returns (Tmp_862: int)
{
  var {:pointer} pirp_1: int;

  anon0:
    pirp_1 := actual_pirp_1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} pirp_1 == sdv_harnessIrp;
    Tmp_862 := sdv_harnessStackLocation_next;
    goto L1;

  L1:
    return;

  anon5_Then:
    assume {:partition} pirp_1 != sdv_harnessIrp;
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} pirp_1 == sdv_other_harnessIrp;
    Tmp_862 := sdv_other_harnessStackLocation_next;
    goto L1;

  anon6_Then:
    assume {:partition} pirp_1 != sdv_other_harnessIrp;
    Tmp_862 := sdv_harnessStackLocation;
    goto L1;
}



procedure {:origName "IoDetachDevice"} {:osmodel} IoDetachDevice(actual_TargetDevice: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoDetachDevice"} {:osmodel} IoDetachDevice(actual_TargetDevice: int)
{
  var vslice_dummy_var_214: int;

  anon0:
    call {:si_unique_call 1297} vslice_dummy_var_214 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_IoSetCancelRoutine"} {:osmodel} sdv_IoSetCancelRoutine(actual_pirp_2: int, actual_CancelRoutine: int) returns (Tmp_866: int);
  modifies Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoSetCancelRoutine"} {:osmodel} sdv_IoSetCancelRoutine(actual_pirp_2: int, actual_CancelRoutine: int) returns (Tmp_866: int)
{
  var {:scalar} r: int;
  var {:pointer} pirp_2: int;
  var {:scalar} CancelRoutine: int;

  anon0:
    pirp_2 := actual_pirp_2;
    CancelRoutine := actual_CancelRoutine;
    assume {:nonnull} pirp_2 != 0;
    assume pirp_2 > 0;
    r := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(pirp_2)];
    assume {:nonnull} pirp_2 != 0;
    assume pirp_2 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(pirp_2)] := CancelRoutine;
    Tmp_866 := r;
    return;
}



procedure {:origName "sdv_SetPowerIrpMinorFunction"} {:osmodel} sdv_SetPowerIrpMinorFunction(actual_pirp_3: int);
  modifies alloc, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.Type_unnamed_tag_38;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_SetPowerIrpMinorFunction"} {:osmodel} sdv_SetPowerIrpMinorFunction(actual_pirp_3: int)
{
  var {:pointer} r_1: int;
  var {:pointer} pirp_3: int;
  var vslice_dummy_var_215: int;

  anon0:
    call {:si_unique_call 1298} vslice_dummy_var_215 := __HAVOC_malloc(4);
    pirp_3 := actual_pirp_3;
    assume {:nonnull} pirp_3 != 0;
    assume pirp_3 > 0;
    r_1 := Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(pirp_3)))];
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(r_1)] := 0;
    goto L1;

  L1:
    return;

  anon12_Then:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(r_1)] := 1;
    goto L1;

  anon13_Then:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(r_1)] := 3;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(r_1)))] := 1;
    goto L1;

  anon15_Then:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(r_1)))] := 0;
    goto L1;

  anon11_Then:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(r_1)] := 2;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(r_1)))] := 1;
    goto L1;

  anon14_Then:
    assume {:nonnull} r_1 != 0;
    assume r_1 > 0;
    Mem_T.Type_unnamed_tag_38[Type_unnamed_tag_38(Power_unnamed_tag_9(Parameters__IO_STACK_LOCATION(r_1)))] := 0;
    goto L1;
}



procedure {:origName "sdv_stub_dispatch_end"} {:osmodel} sdv_stub_dispatch_end(actual_s: int, actual_pirp_4: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_stub_dispatch_end"} {:osmodel} sdv_stub_dispatch_end(actual_s: int, actual_pirp_4: int)
{
  var vslice_dummy_var_216: int;

  anon0:
    call {:si_unique_call 1299} vslice_dummy_var_216 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "OneOfTwoBOOLEAN"} {:osmodel} OneOfTwoBOOLEAN() returns (Tmp_872: int);
  free ensures {:va_keep} Tmp_872 == 1 || Tmp_872 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "OneOfTwoBOOLEAN"} {:osmodel} OneOfTwoBOOLEAN() returns (Tmp_872: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_872 := 1;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_872 := 0;
    goto L1;
}



procedure {:origName "sdv_RunISRRoutines"} {:osmodel} sdv_RunISRRoutines(actual_ki: int, actual_pv1: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RunISRRoutines"} {:osmodel} sdv_RunISRRoutines(actual_ki: int, actual_pv1: int)
{
  var {:pointer} ki: int;
  var {:pointer} pv1: int;
  var vslice_dummy_var_217: int;
  var vslice_dummy_var_218: int;

  anon0:
    call {:si_unique_call 1300} vslice_dummy_var_217 := __HAVOC_malloc(4);
    ki := actual_ki;
    pv1 := actual_pv1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 4;
    call {:si_unique_call 1301} vslice_dummy_var_218 := MoxaISR(ki, pv1);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon5_Then:
    goto L1;
}



procedure {:origName "sdv_SetStatus"} {:osmodel} sdv_SetStatus(actual_pirp_5: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_SetStatus"} {:osmodel} sdv_SetStatus(actual_pirp_5: int)
{
  var {:pointer} pirp_5: int;
  var vslice_dummy_var_219: int;

  anon0:
    call {:si_unique_call 1302} vslice_dummy_var_219 := __HAVOC_malloc(4);
    pirp_5 := actual_pirp_5;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:nonnull} pirp_5 != 0;
    assume pirp_5 > 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    assume {:nonnull} pirp_5 != 0;
    assume pirp_5 > 0;
    goto L1;
}



procedure {:origName "KeRemoveQueueDpc"} {:osmodel} KeRemoveQueueDpc(actual_Dpc_11: int) returns (Tmp_878: int);
  free ensures {:va_keep} Tmp_878 == 1 || Tmp_878 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeRemoveQueueDpc"} {:osmodel} KeRemoveQueueDpc(actual_Dpc_11: int) returns (Tmp_878: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_878 := 1;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_878 := 0;
    goto L1;
}



procedure {:origName "KeDelayExecutionThread"} {:osmodel} KeDelayExecutionThread(actual_WaitMode: int, actual_Alertable: int, actual_Interval: int) returns (Tmp_880: int);
  free ensures {:va_keep} Tmp_880 == 0 || Tmp_880 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeDelayExecutionThread"} {:osmodel} KeDelayExecutionThread(actual_WaitMode: int, actual_Alertable: int, actual_Interval: int) returns (Tmp_880: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_880 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_880 := -1073741823;
    goto L1;
}



procedure {:origName "HalGetInterruptVector"} {:osmodel} HalGetInterruptVector(actual_InterfaceType: int, actual_BusNumber: int, actual_BusInterruptLevel: int, actual_BusInterruptVector: int, actual_Irql: int, actual_Affinity: int) returns (Tmp_882: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "HalGetInterruptVector"} {:osmodel} HalGetInterruptVector(actual_InterfaceType: int, actual_BusNumber: int, actual_BusInterruptLevel: int, actual_BusInterruptVector: int, actual_Irql: int, actual_Affinity: int) returns (Tmp_882: int)
{
  var {:scalar} sdv_354: int;

  anon0:
    Tmp_882 := sdv_354;
    return;
}



procedure {:nohoudini} {:origName "sdv_main"} {:osmodel} sdv_main();
  modifies alloc, Mem_T.CancelRoutine__IRP, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.INT4, Mem_T.Type_unnamed_tag_38, Mem_T.CancelIrql__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_main"} {:osmodel} sdv_main()
{
  var vslice_dummy_var_220: int;
  var vslice_dummy_var_221: int;

  anon0:
    call {:si_unique_call 1303} vslice_dummy_var_220 := __HAVOC_malloc(4);
    call {:si_unique_call 1304} sdv_stub_driver_init();
    call {:si_unique_call 1305} vslice_dummy_var_221 := sdv_RunDispatchFunction(sdv_p_devobj_fdo, sdv_irp);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "IoCreateSymbolicLink"} {:osmodel} IoCreateSymbolicLink(actual_SymbolicLinkName: int, actual_DeviceName: int) returns (Tmp_886: int);
  free ensures {:va_keep} Tmp_886 == 0 || Tmp_886 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoCreateSymbolicLink"} {:osmodel} IoCreateSymbolicLink(actual_SymbolicLinkName: int, actual_DeviceName: int) returns (Tmp_886: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_886 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_886 := -1073741823;
    goto L1;
}



procedure {:origName "IoDeleteSymbolicLink"} {:osmodel} IoDeleteSymbolicLink(actual_SymbolicLinkName_1: int) returns (Tmp_888: int);
  free ensures {:va_keep} Tmp_888 == 0 || Tmp_888 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoDeleteSymbolicLink"} {:osmodel} IoDeleteSymbolicLink(actual_SymbolicLinkName_1: int) returns (Tmp_888: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_888 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_888 := -1073741823;
    goto L1;
}



procedure {:origName "IoAllocateErrorLogEntry"} {:osmodel} IoAllocateErrorLogEntry(actual_IoObject: int, actual_EntrySize: int) returns (Tmp_890: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoAllocateErrorLogEntry"} {:osmodel} IoAllocateErrorLogEntry(actual_IoObject: int, actual_EntrySize: int) returns (Tmp_890: int)
{
  var {:pointer} sdv_359: int;

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    call {:si_unique_call 1306} sdv_359 := __HAVOC_malloc(1);
    Tmp_890 := sdv_359;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_890 := 0;
    goto L1;
}



procedure {:origName "PoCallDriver"} {:osmodel} PoCallDriver(actual_DeviceObject_16: int, actual_Irp_15: int) returns (Tmp_892: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_892 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "PoCallDriver"} {:osmodel} PoCallDriver(actual_DeviceObject_16: int, actual_Irp_15: int) returns (Tmp_892: int)
{
  var {:dopa} {:scalar} completion: int;
  var {:scalar} status_24: int;
  var {:pointer} Irp_15: int;
  var vslice_dummy_var_222: int;
  var vslice_dummy_var_223: int;
  var vslice_dummy_var_224: int;
  var vslice_dummy_var_225: int;
  var vslice_dummy_var_1326: int;
  var vslice_dummy_var_1327: int;
  var vslice_dummy_var_1328: int;
  var vslice_dummy_var_1329: int;

  anon0:
    call {:si_unique_call 1307} completion := __HAVOC_malloc(4);
    Irp_15 := actual_Irp_15;
    assume {:nonnull} completion != 0;
    assume completion > 0;
    Mem_T.INT4[completion] := 0;
    status_24 := 259;
    goto anon45_Then, anon45_Else;

  anon45_Else:
    goto anon62_Then, anon62_Else;

  anon62_Else:
    goto anon61_Then, anon61_Else;

  anon61_Else:
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    goto anon65_Then, anon65_Else;

  anon65_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_15;
    goto L19;

  L19:
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L21;

  L21:
    goto anon47_Then, anon47_Else;

  anon47_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L23;

  L23:
    goto anon48_Then, anon48_Else;

  anon48_Else:
    goto L29;

  L29:
    Tmp_892 := status_24;
    return;

  anon48_Then:
    havoc vslice_dummy_var_1326;
    call {:si_unique_call 1308} vslice_dummy_var_222 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_15, vslice_dummy_var_1326, completion);
    goto L29;

  anon47_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_15;
    goto L23;

  anon46_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_15;
    goto L21;

  anon65_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_15;
    goto L19;

  anon61_Then:
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_15;
    goto L58;

  L58:
    goto anon57_Then, anon57_Else;

  anon57_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L60;

  L60:
    goto anon58_Then, anon58_Else;

  anon58_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L62;

  L62:
    goto anon59_Then, anon59_Else;

  anon59_Else:
    goto anon60_Then, anon60_Else;

  anon60_Else:
    havoc vslice_dummy_var_1327;
    call {:si_unique_call 1309} vslice_dummy_var_225 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_15, vslice_dummy_var_1327, completion);
    goto L29;

  anon60_Then:
    goto L29;

  anon59_Then:
    goto L29;

  anon58_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_15;
    goto L62;

  anon57_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_15;
    goto L60;

  anon66_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_15;
    goto L58;

  anon62_Then:
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_15;
    goto L32;

  L32:
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L34;

  L34:
    goto anon50_Then, anon50_Else;

  anon50_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L36;

  L36:
    goto anon51_Then, anon51_Else;

  anon51_Else:
    goto anon52_Then, anon52_Else;

  anon52_Else:
    havoc vslice_dummy_var_1328;
    call {:si_unique_call 1310} vslice_dummy_var_223 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_15, vslice_dummy_var_1328, completion);
    goto L29;

  anon52_Then:
    goto L29;

  anon51_Then:
    goto L29;

  anon50_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_15;
    goto L36;

  anon49_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_15;
    goto L34;

  anon64_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_15;
    goto L32;

  anon45_Then:
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    assume {:nonnull} Irp_15 != 0;
    assume Irp_15 > 0;
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_15;
    goto L45;

  L45:
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L47;

  L47:
    goto anon54_Then, anon54_Else;

  anon54_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_15;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L49;

  L49:
    goto anon55_Then, anon55_Else;

  anon55_Else:
    goto anon56_Then, anon56_Else;

  anon56_Else:
    havoc vslice_dummy_var_1329;
    call {:si_unique_call 1311} vslice_dummy_var_224 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_15, vslice_dummy_var_1329, completion);
    goto L29;

  anon56_Then:
    goto L29;

  anon55_Then:
    goto L29;

  anon54_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_15;
    goto L49;

  anon53_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_15;
    goto L47;

  anon63_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_15;
    goto L45;
}



procedure {:origName "PoSetPowerState"} {:osmodel} PoSetPowerState(actual_DeviceObject_17: int, actual_Type: int, actual_structPtr888State: int) returns (structPtr888Tmp: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "PoSetPowerState"} {:osmodel} PoSetPowerState(actual_DeviceObject_17: int, actual_Type: int, actual_structPtr888State: int) returns (structPtr888Tmp: int)
{
  var {:scalar} State: int;
  var {:scalar} Tmp: int;
  var {:scalar} r_2: int;
  var {:pointer} structPtr888State: int;

  anon0:
    call {:si_unique_call 1312} State := __HAVOC_malloc(8);
    call {:si_unique_call 1313} Tmp := __HAVOC_malloc(8);
    call {:si_unique_call 1314} r_2 := __HAVOC_malloc(8);
    structPtr888State := actual_structPtr888State;
    assume {:nonnull} State != 0;
    assume State > 0;
    assume {:nonnull} structPtr888State != 0;
    assume structPtr888State > 0;
    assume {:nonnull} State != 0;
    assume State > 0;
    assume {:nonnull} structPtr888State != 0;
    assume structPtr888State > 0;
    assume {:nonnull} Tmp != 0;
    assume Tmp > 0;
    assume {:nonnull} r_2 != 0;
    assume r_2 > 0;
    assume {:nonnull} Tmp != 0;
    assume Tmp > 0;
    assume {:nonnull} r_2 != 0;
    assume r_2 > 0;
    structPtr888Tmp := Tmp;
    return;
}



procedure {:origName "KeCancelTimer"} {:osmodel} KeCancelTimer(actual_Timer_3: int) returns (Tmp_895: int);
  modifies yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeCancelTimer"} {:osmodel} KeCancelTimer(actual_Timer_3: int) returns (Tmp_895: int)
{

  anon0:
    call {:si_unique_call 1315} SLIC_KeCancelTimer_entry(strConst__li2bpl25);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    Tmp_895 := 1;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon5_Then:
    Tmp_895 := 0;
    goto L1;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "IoWriteErrorLogEntry"} {:osmodel} IoWriteErrorLogEntry(actual_ElEntry: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoWriteErrorLogEntry"} {:osmodel} IoWriteErrorLogEntry(actual_ElEntry: int)
{
  var vslice_dummy_var_226: int;

  anon0:
    call {:si_unique_call 1316} vslice_dummy_var_226 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_IoSetCompletionRoutine"} {:osmodel} sdv_IoSetCompletionRoutine(actual_pirp_6: int, actual_CompletionRoutine: int, actual_Context_5: int, actual_InvokeOnSuccess: int, actual_InvokeOnError: int, actual_InvokeOnCancel: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoSetCompletionRoutine"} {:osmodel} sdv_IoSetCompletionRoutine(actual_pirp_6: int, actual_CompletionRoutine: int, actual_Context_5: int, actual_InvokeOnSuccess: int, actual_InvokeOnError: int, actual_InvokeOnCancel: int)
{
  var {:pointer} irpSp_9: int;
  var {:pointer} pirp_6: int;
  var {:scalar} CompletionRoutine: int;
  var {:pointer} Context_5: int;
  var {:scalar} InvokeOnSuccess: int;
  var {:scalar} InvokeOnError: int;
  var {:scalar} InvokeOnCancel: int;
  var vslice_dummy_var_227: int;

  anon0:
    call {:si_unique_call 1317} vslice_dummy_var_227 := __HAVOC_malloc(4);
    pirp_6 := actual_pirp_6;
    CompletionRoutine := actual_CompletionRoutine;
    Context_5 := actual_Context_5;
    InvokeOnSuccess := actual_InvokeOnSuccess;
    InvokeOnError := actual_InvokeOnError;
    InvokeOnCancel := actual_InvokeOnCancel;
    call {:si_unique_call 1318} irpSp_9 := sdv_IoGetNextIrpStackLocation(pirp_6);
    assume {:nonnull} irpSp_9 != 0;
    assume irpSp_9 > 0;
    return;
}



procedure {:origName "ExAcquireFastMutex"} {:osmodel} ExAcquireFastMutex(actual_FastMutex: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> sdv_irql_current <= 2 && sdv_irql_previous <= 2 && sdv_irql_previous_2 <= 2 && sdv_irql_previous_3 <= 2 && sdv_irql_current >= 0 && sdv_irql_previous >= 0 && sdv_irql_previous_2 >= 0 && sdv_irql_previous_3 >= 0;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_current == 1;
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "ExAcquireFastMutex"} {:osmodel} ExAcquireFastMutex(actual_FastMutex: int)
{
  var vslice_dummy_var_228: int;

  anon0:
    call {:si_unique_call 1319} vslice_dummy_var_228 := __HAVOC_malloc(4);
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 1;
    return;
}



procedure {:origName "sdv_RemoveEntryList"} {:osmodel} sdv_RemoveEntryList(actual_Entry_1: int) returns (Tmp_903: int);
  free ensures {:va_keep} Tmp_903 == 1 || Tmp_903 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RemoveEntryList"} {:osmodel} sdv_RemoveEntryList(actual_Entry_1: int) returns (Tmp_903: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_903 := 1;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_903 := 0;
    goto L1;
}



procedure {:origName "RtlDeleteRegistryValue"} {:osmodel} RtlDeleteRegistryValue(actual_RelativeTo: int, actual_Path: int, actual_ValueName: int) returns (Tmp_905: int);
  free ensures {:va_keep} Tmp_905 == 0 || Tmp_905 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlDeleteRegistryValue"} {:osmodel} RtlDeleteRegistryValue(actual_RelativeTo: int, actual_Path: int, actual_ValueName: int) returns (Tmp_905: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_905 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_905 := -1073741823;
    goto L1;
}



procedure {:origName "PoStartNextPowerIrp"} {:osmodel} PoStartNextPowerIrp(actual_Irp_16: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "PoStartNextPowerIrp"} {:osmodel} PoStartNextPowerIrp(actual_Irp_16: int)
{
  var vslice_dummy_var_229: int;

  anon0:
    call {:si_unique_call 1320} vslice_dummy_var_229 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "KeWaitForSingleObject"} {:osmodel} KeWaitForSingleObject(actual_Object: int, actual_WaitReason: int, actual_WaitMode_1: int, actual_Alertable_1: int, actual_Timeout: int) returns (Tmp_909: int);
  free ensures {:va_keep} Tmp_909 == 258 || Tmp_909 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeWaitForSingleObject"} {:osmodel} KeWaitForSingleObject(actual_Object: int, actual_WaitReason: int, actual_WaitMode_1: int, actual_Alertable_1: int, actual_Timeout: int) returns (Tmp_909: int)
{
  var {:pointer} Timeout: int;

  anon0:
    Timeout := actual_Timeout;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} Timeout != 0;
    goto anon6_Then, anon6_Else;

  anon6_Else:
    Tmp_909 := 258;
    goto L1;

  L1:
    return;

  anon6_Then:
    Tmp_909 := 0;
    goto L1;

  anon5_Then:
    assume {:partition} Timeout == 0;
    Tmp_909 := 0;
    goto L1;
}



procedure {:origName "IoDeleteDevice"} {:osmodel} IoDeleteDevice(actual_DeviceObject_18: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoDeleteDevice"} {:osmodel} IoDeleteDevice(actual_DeviceObject_18: int)
{
  var vslice_dummy_var_230: int;

  anon0:
    call {:si_unique_call 1321} vslice_dummy_var_230 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "KeSetEvent"} {:osmodel} KeSetEvent(actual_Event: int, actual_Increment: int, actual_Wait: int) returns (Tmp_913: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeSetEvent"} {:osmodel} KeSetEvent(actual_Event: int, actual_Increment: int, actual_Wait: int) returns (Tmp_913: int)
{
  var {:scalar} OldState: int;
  var {:pointer} Event: int;

  anon0:
    Event := actual_Event;
    assume {:nonnull} Event != 0;
    assume Event > 0;
    havoc OldState;
    assume {:nonnull} Event != 0;
    assume Event > 0;
    Tmp_913 := OldState;
    return;
}



procedure {:origName "sdv_IoGetCurrentIrpStackLocation"} {:osmodel} sdv_IoGetCurrentIrpStackLocation(actual_pirp_7: int) returns (Tmp_917: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoGetCurrentIrpStackLocation"} {:osmodel} sdv_IoGetCurrentIrpStackLocation(actual_pirp_7: int) returns (Tmp_917: int)
{
  var {:pointer} pirp_7: int;

  anon0:
    pirp_7 := actual_pirp_7;
    assume {:nonnull} pirp_7 != 0;
    assume pirp_7 > 0;
    Tmp_917 := Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(pirp_7)))];
    return;
}



procedure {:origName "IoReleaseCancelSpinLock"} {:osmodel} IoReleaseCancelSpinLock(actual_new: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4;
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_current == actual_new;
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoReleaseCancelSpinLock"} {:osmodel} IoReleaseCancelSpinLock(actual_new: int)
{
  var {:scalar} new: int;
  var vslice_dummy_var_231: int;

  anon0:
    call {:si_unique_call 1322} vslice_dummy_var_231 := __HAVOC_malloc(4);
    new := actual_new;
    sdv_irql_current := new;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    return;
}



procedure {:origName "PoRequestPowerIrp"} {:osmodel} PoRequestPowerIrp(actual_DeviceObject_19: int, actual_MinorFunction: int, actual_SD1_5: int, actual_CompletionFunction: int, actual_Context_6: int, actual_Irp_17: int) returns (Tmp_923: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_923 == -1073741584 || Tmp_923 == 259 || Tmp_923 == -1073741670;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "PoRequestPowerIrp"} {:osmodel} PoRequestPowerIrp(actual_DeviceObject_19: int, actual_MinorFunction: int, actual_SD1_5: int, actual_CompletionFunction: int, actual_Context_6: int, actual_Irp_17: int) returns (Tmp_923: int)
{
  var {:scalar} PowerState_1: int;
  var {:scalar} MinorFunction: int;
  var {:pointer} SD1_5: int;
  var {:scalar} CompletionFunction: int;
  var vslice_dummy_var_232: int;

  anon0:
    call {:si_unique_call 1323} PowerState_1 := __HAVOC_malloc(8);
    MinorFunction := actual_MinorFunction;
    SD1_5 := actual_SD1_5;
    CompletionFunction := actual_CompletionFunction;
    assume {:nonnull} PowerState_1 != 0;
    assume PowerState_1 > 0;
    assume {:nonnull} SD1_5 != 0;
    assume SD1_5 > 0;
    assume {:nonnull} PowerState_1 != 0;
    assume PowerState_1 > 0;
    assume {:nonnull} SD1_5 != 0;
    assume SD1_5 > 0;
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} MinorFunction != 3;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} MinorFunction != 2;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} MinorFunction != 0;
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    Tmp_923 := -1073741584;
    goto L1;

  L1:
    return;

  anon11_Then:
    assume {:partition} MinorFunction == 0;
    goto L13;

  L13:
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    call {:si_unique_call 1324} vslice_dummy_var_232 := sdv_RunPowerCompletionRoutines(0, MinorFunction, PowerState_1, 0, 0, CompletionFunction);
    Tmp_923 := 259;
    goto L1;

  anon9_Then:
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    assume {:nonnull} sdv_power_irp != 0;
    assume sdv_power_irp > 0;
    Tmp_923 := -1073741670;
    goto L1;

  anon10_Then:
    assume {:partition} MinorFunction == 2;
    goto L13;

  anon12_Then:
    assume {:partition} MinorFunction == 3;
    goto L13;
}



procedure {:nohoudini} {:origName "main"} {:osmodel} {:entrypoint} main() returns (Tmp_925: int, dup_assertVar: bool);
  modifies alloc, yogi_error, Mem_T.INT4, Mem_T.CurrentStackLocation_unnamed_tag_7, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.Type_unnamed_tag_38, Mem_T.CancelIrql__IRP;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "main"} {:osmodel} main() returns (Tmp_925: int, dup_assertVar: bool)
{
  var {:scalar} Tmp_926: int;
  var {:scalar} Tmp_928: int;
  var boogieTmp: int;
  var WHEA_ERROR_PACKET_SECTION_GUID__Loc: int;
  var MoxaPortModemStatusGuid__Loc: int;
  var SerialPortNameGuid__Loc: int;
  var SerailPortPerfGuid__Loc: int;
  var SerialPortPropertiesGuid__Loc: int;
  var SerialPortHWGuid__Loc: int;
  var SerialPortCommGuid__Loc: int;
  var pollTimer__Loc: int;
  var pollDpc__Loc: int;
  var MoxaPhysicalZero__Loc: int;
  var GUID_DEVINTERFACE_COMPORT__Loc: int;
  var KeTickCount__Loc: int;
  var sdv_harnessStackLocation_next__Loc: int;
  var sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX__Loc: int;
  var sdv_IoBuildAsynchronousFsdRequest_harnessIrp__Loc: int;
  var sdv_IoGetDeviceToVerify_DEVICE_OBJECT__Loc: int;
  var sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next__Loc: int;
  var sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock__Loc: int;
  var sdv_ControllerIrp__Loc: int;
  var sdv_devobj_pdo__Loc: int;
  var sdv_IoGetDmaAdapter_DMA_ADAPTER__Loc: int;
  var sdv_IoInitializeIrp_harnessIrp__Loc: int;
  var sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT__Loc: int;
  var sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next__Loc: int;
  var sdv_IoCreateSynchronizationEvent_KEVENT__Loc: int;
  var sdv_harnessStackLocation__Loc: int;
  var sdv_other_harnessStackLocation_next__Loc: int;
  var sdv_IoCreateController_CONTROLLER_OBJECT__Loc: int;
  var sdv_devobj_top__Loc: int;
  var sdv_kdpc_val3__Loc: int;
  var sdv_IoBuildSynchronousFsdRequest_harnessIrp__Loc: int;
  var sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT__Loc: int;
  var sdv_MapRegisterBase_val__Loc: int;
  var sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING__Loc: int;
  var sdv_IoMakeAssociatedIrp_harnessIrp__Loc: int;
  var sdv_devobj_child_pdo__Loc: int;
  var sdv_harnessIrp__Loc: int;
  var sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next__Loc: int;
  var sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock__Loc: int;
  var sdv_kinterrupt_val__Loc: int;
  var sdv_devobj_fdo__Loc: int;
  var sdv_DpcContext__Loc: int;
  var sdv_StartIoIrp__Loc: int;
  var sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock__Loc: int;
  var sdv_PowerIrp__Loc: int;
  var sdv_IoBuildDeviceIoControlRequest_harnessIrp__Loc: int;
  var sdv_other_harnessIrp__Loc: int;
  var sdv_IoCreateNotificationEvent_KEVENT__Loc: int;
  var sdv_other_harnessStackLocation__Loc: int;
  var vslice_dummy_var_266: int;
  var vslice_dummy_var_267: int;
  var vslice_dummy_var_268: int;
  var vslice_dummy_var_269: int;
  var vslice_dummy_var_270: int;
  var vslice_dummy_var_271: int;
  var vslice_dummy_var_272: int;
  var vslice_dummy_var_273: int;
  var vslice_dummy_var_274: int;
  var vslice_dummy_var_275: int;
  var vslice_dummy_var_276: int;
  var vslice_dummy_var_277: int;
  var vslice_dummy_var_278: int;
  var vslice_dummy_var_279: int;
  var vslice_dummy_var_280: int;
  var vslice_dummy_var_281: int;
  var vslice_dummy_var_282: int;
  var vslice_dummy_var_283: int;
  var vslice_dummy_var_284: int;
  var vslice_dummy_var_285: int;
  var vslice_dummy_var_286: int;
  var vslice_dummy_var_287: int;
  var vslice_dummy_var_288: int;
  var vslice_dummy_var_289: int;
  var vslice_dummy_var_290: int;
  var vslice_dummy_var_291: int;
  var vslice_dummy_var_292: int;
  var vslice_dummy_var_293: int;
  var vslice_dummy_var_294: int;
  var vslice_dummy_var_295: int;
  var vslice_dummy_var_296: int;
  var vslice_dummy_var_297: int;
  var vslice_dummy_var_298: int;
  var vslice_dummy_var_299: int;
  var vslice_dummy_var_300: int;
  var vslice_dummy_var_301: int;
  var vslice_dummy_var_302: int;
  var vslice_dummy_var_303: int;
  var vslice_dummy_var_304: int;
  var vslice_dummy_var_305: int;
  var vslice_dummy_var_306: int;
  var vslice_dummy_var_307: int;
  var vslice_dummy_var_308: int;
  var vslice_dummy_var_309: int;
  var vslice_dummy_var_310: int;
  var vslice_dummy_var_311: int;
  var vslice_dummy_var_312: int;
  var vslice_dummy_var_313: int;
  var vslice_dummy_var_314: int;
  var vslice_dummy_var_315: int;
  var vslice_dummy_var_316: int;
  var vslice_dummy_var_317: int;
  var vslice_dummy_var_318: int;
  var vslice_dummy_var_319: int;
  var vslice_dummy_var_320: int;
  var vslice_dummy_var_321: int;
  var vslice_dummy_var_322: int;
  var vslice_dummy_var_323: int;
  var vslice_dummy_var_324: int;
  var vslice_dummy_var_325: int;
  var vslice_dummy_var_326: int;
  var vslice_dummy_var_327: int;
  var vslice_dummy_var_328: int;
  var vslice_dummy_var_329: int;
  var vslice_dummy_var_330: int;
  var vslice_dummy_var_331: int;
  var vslice_dummy_var_332: int;
  var vslice_dummy_var_333: int;
  var vslice_dummy_var_334: int;
  var vslice_dummy_var_335: int;
  var vslice_dummy_var_336: int;
  var vslice_dummy_var_337: int;
  var vslice_dummy_var_338: int;
  var vslice_dummy_var_339: int;
  var vslice_dummy_var_340: int;
  var vslice_dummy_var_341: int;
  var vslice_dummy_var_342: int;
  var vslice_dummy_var_343: int;
  var vslice_dummy_var_344: int;
  var vslice_dummy_var_345: int;
  var vslice_dummy_var_346: int;
  var vslice_dummy_var_347: int;
  var vslice_dummy_var_348: int;
  var vslice_dummy_var_349: int;
  var vslice_dummy_var_350: int;
  var vslice_dummy_var_351: int;
  var vslice_dummy_var_352: int;
  var vslice_dummy_var_353: int;
  var vslice_dummy_var_354: int;
  var vslice_dummy_var_355: int;
  var vslice_dummy_var_356: int;
  var vslice_dummy_var_1330: int;
  var vslice_dummy_var_1331: int;
  var vslice_dummy_var_1332: int;
  var vslice_dummy_var_1333: int;
  var vslice_dummy_var_1334: int;
  var vslice_dummy_var_1335: int;
  var vslice_dummy_var_1336: int;
  var vslice_dummy_var_1337: int;
  var vslice_dummy_var_1338: int;
  var vslice_dummy_var_1339: int;
  var vslice_dummy_var_1340: int;
  var vslice_dummy_var_1341: int;

  anon0:
    dup_assertVar := true;
    assume alloc > 0;
    call {:si_unique_call 1325} WHEA_ERROR_PACKET_SECTION_GUID__Loc := __HAVOC_malloc_or_null(16);
    assume WHEA_ERROR_PACKET_SECTION_GUID__Loc == WHEA_ERROR_PACKET_SECTION_GUID;
    assume WHEA_ERROR_PACKET_SECTION_GUID != 0;
    call {:si_unique_call 1326} MoxaPortModemStatusGuid__Loc := __HAVOC_malloc_or_null(16);
    assume MoxaPortModemStatusGuid__Loc == MoxaPortModemStatusGuid;
    assume MoxaPortModemStatusGuid != 0;
    call {:si_unique_call 1327} SerialPortNameGuid__Loc := __HAVOC_malloc_or_null(16);
    assume SerialPortNameGuid__Loc == SerialPortNameGuid;
    assume SerialPortNameGuid != 0;
    call {:si_unique_call 1328} SerailPortPerfGuid__Loc := __HAVOC_malloc_or_null(16);
    assume SerailPortPerfGuid__Loc == SerailPortPerfGuid;
    assume SerailPortPerfGuid != 0;
    call {:si_unique_call 1329} SerialPortPropertiesGuid__Loc := __HAVOC_malloc_or_null(16);
    assume SerialPortPropertiesGuid__Loc == SerialPortPropertiesGuid;
    assume SerialPortPropertiesGuid != 0;
    call {:si_unique_call 1330} SerialPortHWGuid__Loc := __HAVOC_malloc_or_null(16);
    assume SerialPortHWGuid__Loc == SerialPortHWGuid;
    assume SerialPortHWGuid != 0;
    call {:si_unique_call 1331} SerialPortCommGuid__Loc := __HAVOC_malloc_or_null(16);
    assume SerialPortCommGuid__Loc == SerialPortCommGuid;
    assume SerialPortCommGuid != 0;
    call {:si_unique_call 1332} pollTimer__Loc := __HAVOC_malloc_or_null(160);
    assume pollTimer__Loc == pollTimer;
    assume pollTimer != 0;
    call {:si_unique_call 1333} pollDpc__Loc := __HAVOC_malloc_or_null(40);
    assume pollDpc__Loc == pollDpc;
    assume pollDpc != 0;
    call {:si_unique_call 1334} MoxaPhysicalZero__Loc := __HAVOC_malloc_or_null(20);
    assume MoxaPhysicalZero__Loc == MoxaPhysicalZero;
    assume MoxaPhysicalZero != 0;
    call {:si_unique_call 1335} GUID_DEVINTERFACE_COMPORT__Loc := __HAVOC_malloc_or_null(16);
    assume GUID_DEVINTERFACE_COMPORT__Loc == GUID_DEVINTERFACE_COMPORT;
    assume GUID_DEVINTERFACE_COMPORT != 0;
    call {:si_unique_call 1336} KeTickCount__Loc := __HAVOC_malloc_or_null(12);
    assume KeTickCount__Loc == KeTickCount;
    assume KeTickCount != 0;
    call {:si_unique_call 1337} sdv_harnessStackLocation_next__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_harnessStackLocation_next__Loc == sdv_harnessStackLocation_next;
    assume sdv_harnessStackLocation_next != 0;
    call {:si_unique_call 1338} sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX__Loc := __HAVOC_malloc_or_null(76);
    assume sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX__Loc == sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX;
    assume sdv_IoReadPartitionTableEx_DRIVE_LAYOUT_INFORMATION_EX != 0;
    call {:si_unique_call 1339} sdv_IoBuildAsynchronousFsdRequest_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_IoBuildAsynchronousFsdRequest_harnessIrp__Loc == sdv_IoBuildAsynchronousFsdRequest_harnessIrp;
    assume sdv_IoBuildAsynchronousFsdRequest_harnessIrp != 0;
    call {:si_unique_call 1340} sdv_IoGetDeviceToVerify_DEVICE_OBJECT__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_IoGetDeviceToVerify_DEVICE_OBJECT__Loc == sdv_IoGetDeviceToVerify_DEVICE_OBJECT;
    assume sdv_IoGetDeviceToVerify_DEVICE_OBJECT != 0;
    call {:si_unique_call 1341} sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next__Loc == sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next;
    assume sdv_IoBuildDeviceIoControlRequest_harnessStackLocation_next != 0;
    call {:si_unique_call 1342} sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock__Loc := __HAVOC_malloc_or_null(12);
    assume sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock__Loc == sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock;
    assume sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    call {:si_unique_call 1343} sdv_ControllerIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_ControllerIrp__Loc == sdv_ControllerIrp;
    assume sdv_ControllerIrp != 0;
    call {:si_unique_call 1344} sdv_devobj_pdo__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_devobj_pdo__Loc == sdv_devobj_pdo;
    assume sdv_devobj_pdo != 0;
    call {:si_unique_call 1345} sdv_IoGetDmaAdapter_DMA_ADAPTER__Loc := __HAVOC_malloc_or_null(12);
    assume sdv_IoGetDmaAdapter_DMA_ADAPTER__Loc == sdv_IoGetDmaAdapter_DMA_ADAPTER;
    assume sdv_IoGetDmaAdapter_DMA_ADAPTER != 0;
    call {:si_unique_call 1346} sdv_IoInitializeIrp_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_IoInitializeIrp_harnessIrp__Loc == sdv_IoInitializeIrp_harnessIrp;
    assume sdv_IoInitializeIrp_harnessIrp != 0;
    call {:si_unique_call 1347} sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT__Loc == sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT;
    assume sdv_IoGetRelatedDeviceObject_DEVICE_OBJECT != 0;
    call {:si_unique_call 1348} sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next__Loc == sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next;
    assume sdv_IoBuildSynchronousFsdRequest_harnessStackLocation_next != 0;
    call {:si_unique_call 1349} sdv_IoCreateSynchronizationEvent_KEVENT__Loc := __HAVOC_malloc_or_null(124);
    assume sdv_IoCreateSynchronizationEvent_KEVENT__Loc == sdv_IoCreateSynchronizationEvent_KEVENT;
    assume sdv_IoCreateSynchronizationEvent_KEVENT != 0;
    call {:si_unique_call 1350} sdv_harnessStackLocation__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_harnessStackLocation__Loc == sdv_harnessStackLocation;
    assume sdv_harnessStackLocation != 0;
    call {:si_unique_call 1351} sdv_other_harnessStackLocation_next__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_other_harnessStackLocation_next__Loc == sdv_other_harnessStackLocation_next;
    assume sdv_other_harnessStackLocation_next != 0;
    call {:si_unique_call 1352} sdv_IoCreateController_CONTROLLER_OBJECT__Loc := __HAVOC_malloc_or_null(60);
    assume sdv_IoCreateController_CONTROLLER_OBJECT__Loc == sdv_IoCreateController_CONTROLLER_OBJECT;
    assume sdv_IoCreateController_CONTROLLER_OBJECT != 0;
    call {:si_unique_call 1353} sdv_devobj_top__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_devobj_top__Loc == sdv_devobj_top;
    assume sdv_devobj_top != 0;
    call {:si_unique_call 1354} sdv_kdpc_val3__Loc := __HAVOC_malloc_or_null(40);
    assume sdv_kdpc_val3__Loc == sdv_kdpc_val3;
    assume sdv_kdpc_val3 != 0;
    call {:si_unique_call 1355} sdv_IoBuildSynchronousFsdRequest_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_IoBuildSynchronousFsdRequest_harnessIrp__Loc == sdv_IoBuildSynchronousFsdRequest_harnessIrp;
    assume sdv_IoBuildSynchronousFsdRequest_harnessIrp != 0;
    call {:si_unique_call 1356} sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT__Loc == sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT;
    assume sdv_IoGetDeviceObjectPointer_DEVICE_OBJECT != 0;
    call {:si_unique_call 1357} sdv_MapRegisterBase_val__Loc := __HAVOC_malloc_or_null(4);
    assume sdv_MapRegisterBase_val__Loc == sdv_MapRegisterBase_val;
    assume sdv_MapRegisterBase_val != 0;
    call {:si_unique_call 1358} sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING__Loc := __HAVOC_malloc_or_null(16);
    assume sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING__Loc == sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING;
    assume sdv_IoGetFileObjectGenericMapping_GENERIC_MAPPING != 0;
    call {:si_unique_call 1359} sdv_IoMakeAssociatedIrp_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_IoMakeAssociatedIrp_harnessIrp__Loc == sdv_IoMakeAssociatedIrp_harnessIrp;
    assume sdv_IoMakeAssociatedIrp_harnessIrp != 0;
    call {:si_unique_call 1360} sdv_devobj_child_pdo__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_devobj_child_pdo__Loc == sdv_devobj_child_pdo;
    assume sdv_devobj_child_pdo != 0;
    call {:si_unique_call 1361} sdv_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_harnessIrp__Loc == sdv_harnessIrp;
    assume sdv_harnessIrp != 0;
    call {:si_unique_call 1362} sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next__Loc == sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next;
    assume sdv_IoBuildAsynchronousFsdRequest_harnessStackLocation_next != 0;
    call {:si_unique_call 1363} sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock__Loc := __HAVOC_malloc_or_null(12);
    assume sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock__Loc == sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock;
    assume sdv_harness_IoBuildDeviceIoControlRequest_IoStatusBlock != 0;
    call {:si_unique_call 1364} sdv_kinterrupt_val__Loc := __HAVOC_malloc_or_null(0);
    assume sdv_kinterrupt_val__Loc == sdv_kinterrupt_val;
    assume sdv_kinterrupt_val != 0;
    call {:si_unique_call 1365} sdv_devobj_fdo__Loc := __HAVOC_malloc_or_null(320);
    assume sdv_devobj_fdo__Loc == sdv_devobj_fdo;
    assume sdv_devobj_fdo != 0;
    call {:si_unique_call 1366} sdv_DpcContext__Loc := __HAVOC_malloc_or_null(4);
    assume sdv_DpcContext__Loc == sdv_DpcContext;
    assume sdv_DpcContext != 0;
    call {:si_unique_call 1367} sdv_StartIoIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_StartIoIrp__Loc == sdv_StartIoIrp;
    assume sdv_StartIoIrp != 0;
    call {:si_unique_call 1368} sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock__Loc := __HAVOC_malloc_or_null(12);
    assume sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock__Loc == sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock;
    assume sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    call {:si_unique_call 1369} sdv_PowerIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_PowerIrp__Loc == sdv_PowerIrp;
    assume sdv_PowerIrp != 0;
    call {:si_unique_call 1370} sdv_IoBuildDeviceIoControlRequest_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_IoBuildDeviceIoControlRequest_harnessIrp__Loc == sdv_IoBuildDeviceIoControlRequest_harnessIrp;
    assume sdv_IoBuildDeviceIoControlRequest_harnessIrp != 0;
    call {:si_unique_call 1371} sdv_other_harnessIrp__Loc := __HAVOC_malloc_or_null(248);
    assume sdv_other_harnessIrp__Loc == sdv_other_harnessIrp;
    assume sdv_other_harnessIrp != 0;
    call {:si_unique_call 1372} sdv_IoCreateNotificationEvent_KEVENT__Loc := __HAVOC_malloc_or_null(124);
    assume sdv_IoCreateNotificationEvent_KEVENT__Loc == sdv_IoCreateNotificationEvent_KEVENT;
    assume sdv_IoCreateNotificationEvent_KEVENT != 0;
    call {:si_unique_call 1373} sdv_other_harnessStackLocation__Loc := __HAVOC_malloc_or_null(496);
    assume sdv_other_harnessStackLocation__Loc == sdv_other_harnessStackLocation;
    assume sdv_other_harnessStackLocation != 0;
    call {:si_unique_call 1374} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1375} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIbuff == boogieTmp;
    call {:si_unique_call 1376} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIwptr == boogieTmp;
    call {:si_unique_call 1377} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1378} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1379} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1380} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIofs == boogieTmp;
    call {:si_unique_call 1381} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIrptr == boogieTmp;
    call {:si_unique_call 1382} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1383} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1384} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1385} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIbase == boogieTmp;
    call {:si_unique_call 1386} boogieTmp := __HAVOC_malloc_or_null(4);
    assume LIdataBuffer == boogieTmp;
    call {:si_unique_call 1387} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1388} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1389} boogieTmp := __HAVOC_malloc_or_null(108);
    assume MoxaGlobalData == boogieTmp;
    call {:si_unique_call 1390} boogieTmp := __HAVOC_malloc_or_null(12);
    call {:si_unique_call 1391} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1392} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1393} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1394} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1395} boogieTmp := __HAVOC_malloc_or_null(8);
    call {:si_unique_call 1396} boogieTmp := __HAVOC_malloc_or_null(8);
    call {:si_unique_call 1397} boogieTmp := __HAVOC_malloc_or_null(8);
    call {:si_unique_call 1398} boogieTmp := __HAVOC_malloc_or_null(8);
    call {:si_unique_call 1399} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDrptr == boogieTmp;
    call {:si_unique_call 1400} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBrptr == boogieTmp;
    call {:si_unique_call 1401} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDbuff == boogieTmp;
    call {:si_unique_call 1402} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDwptr == boogieTmp;
    call {:si_unique_call 1403} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBbase == boogieTmp;
    call {:si_unique_call 1404} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDofs == boogieTmp;
    call {:si_unique_call 1405} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBbuff == boogieTmp;
    call {:si_unique_call 1406} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBofs == boogieTmp;
    call {:si_unique_call 1407} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDbase == boogieTmp;
    call {:si_unique_call 1408} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PDwriteChar == boogieTmp;
    call {:si_unique_call 1409} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBwptr == boogieTmp;
    call {:si_unique_call 1410} boogieTmp := __HAVOC_malloc_or_null(4);
    assume PBwriteChar == boogieTmp;
    call {:si_unique_call 1411} boogieTmp := __HAVOC_malloc_or_null(4);
    assume sdv_harnessDeviceExtension_two == boogieTmp;
    call {:si_unique_call 1412} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1413} boogieTmp := __HAVOC_malloc_or_null(4);
    assume sdv_pv3 == boogieTmp;
    call {:si_unique_call 1414} boogieTmp := __HAVOC_malloc_or_null(4);
    assume sdv_pv2 == boogieTmp;
    call {:si_unique_call 1415} boogieTmp := __HAVOC_malloc_or_null(4);
    call {:si_unique_call 1416} boogieTmp := __HAVOC_malloc_or_null(4);
    assume sdv_harnessDeviceExtension == boogieTmp;
    call {:si_unique_call 1417} boogieTmp := __HAVOC_malloc_or_null(4);
    assume igdoe == boogieTmp;
    call {:si_unique_call 1418} boogieTmp := __HAVOC_malloc_or_null(248);
    assume sicrni == boogieTmp;
    call {:si_unique_call 1419} vslice_dummy_var_266 := __HAVOC_malloc(4);
    call {:si_unique_call 1420} vslice_dummy_var_267 := __HAVOC_malloc(4);
    call {:si_unique_call 1421} vslice_dummy_var_268 := __HAVOC_malloc(4);
    call {:si_unique_call 1422} vslice_dummy_var_269 := __HAVOC_malloc(4);
    call {:si_unique_call 1423} vslice_dummy_var_270 := __HAVOC_malloc(4);
    call {:si_unique_call 1424} vslice_dummy_var_271 := __HAVOC_malloc(4);
    call {:si_unique_call 1425} vslice_dummy_var_272 := __HAVOC_malloc(4);
    call {:si_unique_call 1426} vslice_dummy_var_273 := __HAVOC_malloc(4);
    call {:si_unique_call 1427} vslice_dummy_var_274 := __HAVOC_malloc(4);
    call {:si_unique_call 1428} vslice_dummy_var_275 := __HAVOC_malloc(4);
    call {:si_unique_call 1429} vslice_dummy_var_1330 := __HAVOC_malloc(72);
    call {:si_unique_call 1430} vslice_dummy_var_1331 := __HAVOC_malloc(512);
    call {:si_unique_call 1431} vslice_dummy_var_276 := __HAVOC_malloc(4);
    call {:si_unique_call 1432} vslice_dummy_var_277 := __HAVOC_malloc(4);
    call {:si_unique_call 1433} vslice_dummy_var_278 := __HAVOC_malloc(4);
    call {:si_unique_call 1434} vslice_dummy_var_279 := __HAVOC_malloc(4);
    call {:si_unique_call 1435} vslice_dummy_var_280 := __HAVOC_malloc(4);
    call {:si_unique_call 1436} vslice_dummy_var_281 := __HAVOC_malloc(4);
    call {:si_unique_call 1437} vslice_dummy_var_1332 := __HAVOC_malloc(512);
    call {:si_unique_call 1438} vslice_dummy_var_1333 := __HAVOC_malloc(1028);
    call {:si_unique_call 1439} vslice_dummy_var_282 := __HAVOC_malloc(4);
    call {:si_unique_call 1440} vslice_dummy_var_283 := __HAVOC_malloc(4);
    call {:si_unique_call 1441} vslice_dummy_var_284 := __HAVOC_malloc(4);
    call {:si_unique_call 1442} vslice_dummy_var_285 := __HAVOC_malloc(4);
    call {:si_unique_call 1443} vslice_dummy_var_1334 := __HAVOC_malloc(512);
    call {:si_unique_call 1444} vslice_dummy_var_1335 := __HAVOC_malloc(512);
    call {:si_unique_call 1445} vslice_dummy_var_286 := __HAVOC_malloc(4);
    call {:si_unique_call 1446} vslice_dummy_var_287 := __HAVOC_malloc(4);
    call {:si_unique_call 1447} vslice_dummy_var_288 := __HAVOC_malloc(4);
    call {:si_unique_call 1448} vslice_dummy_var_289 := __HAVOC_malloc(4);
    call {:si_unique_call 1449} vslice_dummy_var_290 := __HAVOC_malloc(4);
    call {:si_unique_call 1450} vslice_dummy_var_1336 := __HAVOC_malloc(512);
    call {:si_unique_call 1451} vslice_dummy_var_291 := __HAVOC_malloc(4);
    call {:si_unique_call 1452} vslice_dummy_var_292 := __HAVOC_malloc(1024);
    call {:si_unique_call 1453} vslice_dummy_var_293 := __HAVOC_malloc(4);
    call {:si_unique_call 1454} vslice_dummy_var_294 := __HAVOC_malloc(4);
    call {:si_unique_call 1455} vslice_dummy_var_295 := __HAVOC_malloc(4);
    call {:si_unique_call 1456} vslice_dummy_var_296 := __HAVOC_malloc(4);
    call {:si_unique_call 1457} vslice_dummy_var_297 := __HAVOC_malloc(4);
    call {:si_unique_call 1458} vslice_dummy_var_298 := __HAVOC_malloc(4);
    call {:si_unique_call 1459} vslice_dummy_var_299 := __HAVOC_malloc(4);
    call {:si_unique_call 1460} vslice_dummy_var_300 := __HAVOC_malloc(4);
    call {:si_unique_call 1461} vslice_dummy_var_301 := __HAVOC_malloc(4);
    call {:si_unique_call 1462} vslice_dummy_var_302 := __HAVOC_malloc(4);
    call {:si_unique_call 1463} vslice_dummy_var_303 := __HAVOC_malloc(4);
    call {:si_unique_call 1464} vslice_dummy_var_304 := __HAVOC_malloc(4);
    call {:si_unique_call 1465} vslice_dummy_var_305 := __HAVOC_malloc(4);
    call {:si_unique_call 1466} vslice_dummy_var_306 := __HAVOC_malloc(4);
    call {:si_unique_call 1467} vslice_dummy_var_307 := __HAVOC_malloc(4);
    call {:si_unique_call 1468} vslice_dummy_var_308 := __HAVOC_malloc(4);
    call {:si_unique_call 1469} vslice_dummy_var_309 := __HAVOC_malloc(4);
    call {:si_unique_call 1470} vslice_dummy_var_310 := __HAVOC_malloc(4);
    call {:si_unique_call 1471} vslice_dummy_var_311 := __HAVOC_malloc(4);
    call {:si_unique_call 1472} vslice_dummy_var_312 := __HAVOC_malloc(4);
    call {:si_unique_call 1473} vslice_dummy_var_313 := __HAVOC_malloc(4);
    call {:si_unique_call 1474} vslice_dummy_var_314 := __HAVOC_malloc(4);
    call {:si_unique_call 1475} vslice_dummy_var_315 := __HAVOC_malloc(4);
    call {:si_unique_call 1476} vslice_dummy_var_316 := __HAVOC_malloc(4);
    call {:si_unique_call 1477} vslice_dummy_var_1337 := __HAVOC_malloc(512);
    call {:si_unique_call 1478} vslice_dummy_var_317 := __HAVOC_malloc(4);
    call {:si_unique_call 1479} vslice_dummy_var_318 := __HAVOC_malloc(4);
    call {:si_unique_call 1480} vslice_dummy_var_319 := __HAVOC_malloc(4);
    call {:si_unique_call 1481} vslice_dummy_var_320 := __HAVOC_malloc(4);
    call {:si_unique_call 1482} vslice_dummy_var_321 := __HAVOC_malloc(4);
    call {:si_unique_call 1483} vslice_dummy_var_1338 := __HAVOC_malloc(512);
    call {:si_unique_call 1484} vslice_dummy_var_322 := __HAVOC_malloc(4);
    call {:si_unique_call 1485} vslice_dummy_var_323 := __HAVOC_malloc(4);
    call {:si_unique_call 1486} vslice_dummy_var_324 := __HAVOC_malloc(4);
    call {:si_unique_call 1487} vslice_dummy_var_325 := __HAVOC_malloc(4);
    call {:si_unique_call 1488} vslice_dummy_var_326 := __HAVOC_malloc(4);
    call {:si_unique_call 1489} vslice_dummy_var_327 := __HAVOC_malloc(4);
    call {:si_unique_call 1490} vslice_dummy_var_328 := __HAVOC_malloc(4);
    call {:si_unique_call 1491} vslice_dummy_var_329 := __HAVOC_malloc(4);
    call {:si_unique_call 1492} vslice_dummy_var_330 := __HAVOC_malloc(4);
    call {:si_unique_call 1493} vslice_dummy_var_331 := __HAVOC_malloc(4);
    call {:si_unique_call 1494} vslice_dummy_var_332 := __HAVOC_malloc(4);
    call {:si_unique_call 1495} vslice_dummy_var_1339 := __HAVOC_malloc(1028);
    call {:si_unique_call 1496} vslice_dummy_var_333 := __HAVOC_malloc(4);
    call {:si_unique_call 1497} vslice_dummy_var_334 := __HAVOC_malloc(4);
    call {:si_unique_call 1498} vslice_dummy_var_335 := __HAVOC_malloc(4);
    call {:si_unique_call 1499} vslice_dummy_var_336 := __HAVOC_malloc(4);
    call {:si_unique_call 1500} vslice_dummy_var_1340 := __HAVOC_malloc(72);
    call {:si_unique_call 1501} vslice_dummy_var_337 := __HAVOC_malloc(4);
    call {:si_unique_call 1502} vslice_dummy_var_1341 := __HAVOC_malloc(1028);
    call {:si_unique_call 1503} vslice_dummy_var_338 := __HAVOC_malloc(4);
    call {:si_unique_call 1504} vslice_dummy_var_339 := __HAVOC_malloc(4);
    call {:si_unique_call 1505} vslice_dummy_var_340 := __HAVOC_malloc(4);
    call {:si_unique_call 1506} vslice_dummy_var_341 := __HAVOC_malloc(4);
    call {:si_unique_call 1507} vslice_dummy_var_342 := __HAVOC_malloc(4);
    call {:si_unique_call 1508} vslice_dummy_var_343 := __HAVOC_malloc(4);
    call {:si_unique_call 1509} vslice_dummy_var_344 := __HAVOC_malloc(4);
    call {:si_unique_call 1510} vslice_dummy_var_345 := __HAVOC_malloc(4);
    call {:si_unique_call 1511} vslice_dummy_var_346 := __HAVOC_malloc(4);
    call {:si_unique_call 1512} vslice_dummy_var_347 := __HAVOC_malloc(4);
    call {:si_unique_call 1513} vslice_dummy_var_348 := __HAVOC_malloc(4);
    call {:si_unique_call 1514} vslice_dummy_var_349 := __HAVOC_malloc(4);
    call {:si_unique_call 1515} vslice_dummy_var_350 := __HAVOC_malloc(4);
    call {:si_unique_call 1516} vslice_dummy_var_351 := __HAVOC_malloc(4);
    call {:si_unique_call 1517} vslice_dummy_var_352 := __HAVOC_malloc(4);
    call {:si_unique_call 1518} vslice_dummy_var_353 := __HAVOC_malloc(4);
    call {:si_unique_call 1519} vslice_dummy_var_354 := __HAVOC_malloc(4);
    call {:si_unique_call 1520} vslice_dummy_var_355 := __HAVOC_malloc(4);
    call {:si_unique_call 1521} vslice_dummy_var_356 := __HAVOC_malloc(4);
    assume {:mainInitDone} true;
    call {:si_unique_call 1522} corralExtraInit();
    call {:si_unique_call 1523} corralExplainErrorInit();
    call {:si_unique_call 1524} _sdv_init20();
    call {:si_unique_call 1525} _sdv_init18();
    call {:si_unique_call 1526} _sdv_init17();
    call {:si_unique_call 1527} _sdv_init1();
    call {:si_unique_call 1528} _sdv_init4();
    call {:si_unique_call 1529} _sdv_init5();
    call {:si_unique_call 1530} _sdv_init3();
    call {:si_unique_call 1531} _sdv_init16();
    call {:si_unique_call 1532} _sdv_init14();
    call {:si_unique_call 1533} _sdv_init6();
    call {:si_unique_call 1534} _sdv_init15();
    call {:si_unique_call 1535} _sdv_init10();
    call {:si_unique_call 1536} _sdv_init11();
    call {:si_unique_call 1537} _sdv_init9();
    call {:si_unique_call 1538} _sdv_init12();
    call {:si_unique_call 1539} _sdv_init13();
    call {:si_unique_call 1540} _sdv_init7();
    call {:si_unique_call 1541} _sdv_init8();
    call {:si_unique_call 1542} _sdv_init2();
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} sdv_harnessDeviceExtension == 0;
    Tmp_928 := 0;
    goto L43;

  L43:
    assume Tmp_928 != 0;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:partition} sdv_harnessDeviceExtension_two == 0;
    Tmp_926 := 0;
    goto L47;

  L47:
    assume Tmp_926 != 0;
    assume {:nonnull} sdv_irp != 0;
    assume sdv_irp > 0;
    Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(sdv_irp)))] := sdv_harnessStackLocation;
    assume {:nonnull} sdv_other_irp != 0;
    assume sdv_other_irp > 0;
    Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(sdv_other_irp)))] := sdv_other_harnessStackLocation;
    call {:si_unique_call 1543} sdv_main();
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error == 1;
    goto L41;

  L41:
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume yogi_error == 1;
    dup_assertVar := false;
    goto L_BAF_0, L_BAF_1;

  L_BAF_1:
    assume dup_assertVar;
    goto L_BAF_2;

  L_BAF_2:
    return;

  L_BAF_0:
    assume !dup_assertVar;
    return;

  anon11_Then:
    assume yogi_error == 0;
    goto LM2;

  LM2:
    return;

  anon12_Then:
    assume {:partition} yogi_error != 1;
    goto L41;

  anon10_Then:
    assume {:partition} sdv_harnessDeviceExtension_two != 0;
    Tmp_926 := 1;
    goto L47;

  anon9_Then:
    assume {:partition} sdv_harnessDeviceExtension != 0;
    Tmp_928 := 1;
    goto L43;
}



procedure {:origName "IoGetConfigurationInformation"} {:osmodel} IoGetConfigurationInformation() returns (Tmp_929: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoGetConfigurationInformation"} {:osmodel} IoGetConfigurationInformation() returns (Tmp_929: int)
{
  var {:pointer} sdv_372: int;

  anon0:
    call {:si_unique_call 1544} sdv_372 := __HAVOC_malloc(1);
    Tmp_929 := sdv_372;
    return;
}



procedure {:origName "sdv_IoSkipCurrentIrpStackLocation"} {:osmodel} sdv_IoSkipCurrentIrpStackLocation(actual_pirp_8: int);
  modifies alloc, Mem_T.MinorFunction__IO_STACK_LOCATION;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoSkipCurrentIrpStackLocation"} {:osmodel} sdv_IoSkipCurrentIrpStackLocation(actual_pirp_8: int)
{
  var {:pointer} pirp_8: int;
  var vslice_dummy_var_233: int;

  anon0:
    call {:si_unique_call 1545} vslice_dummy_var_233 := __HAVOC_malloc(4);
    pirp_8 := actual_pirp_8;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} pirp_8 == sdv_harnessIrp;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_harnessStackLocation_next)] := Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_harnessStackLocation)];
    goto L4;

  L4:
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} pirp_8 == sdv_other_harnessIrp;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_other_harnessStackLocation_next)] := Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(sdv_other_harnessStackLocation)];
    goto L1;

  L1:
    return;

  anon6_Then:
    assume {:partition} pirp_8 != sdv_other_harnessIrp;
    goto L1;

  anon5_Then:
    assume {:partition} pirp_8 != sdv_harnessIrp;
    goto L4;
}



procedure {:origName "IoCancelIrp"} {:osmodel} IoCancelIrp(actual_Irp_18: int) returns (Tmp_933: int);
  free ensures {:va_keep} Tmp_933 == 0 || Tmp_933 == 1;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoCancelIrp"} {:osmodel} IoCancelIrp(actual_Irp_18: int) returns (Tmp_933: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_933 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_933 := 1;
    goto L1;
}



procedure {:origName "sdv_InterlockedDecrement"} {:osmodel} sdv_InterlockedDecrement(actual_Addend: int) returns (Tmp_935: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_InterlockedDecrement"} {:osmodel} sdv_InterlockedDecrement(actual_Addend: int) returns (Tmp_935: int)
{
  var {:pointer} Addend: int;

  anon0:
    Addend := actual_Addend;
    assume {:nonnull} Addend != 0;
    assume Addend > 0;
    Mem_T.INT4[Addend] := Mem_T.INT4[Addend] - 1;
    assume {:nonnull} Addend != 0;
    assume Addend > 0;
    Tmp_935 := Mem_T.INT4[Addend];
    return;
}



procedure {:origName "sdv_RunPowerCompletionRoutines"} {:osmodel} sdv_RunPowerCompletionRoutines(actual_DeviceObject_20: int, actual_MinorFunction_1: int, actual_structPtr888PowerState: int, actual_Context_7: int, actual_IoStatus: int, actual_CompletionFunction_1: int) returns (Tmp_937: int);
  modifies alloc;
  free ensures {:va_keep} Tmp_937 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RunPowerCompletionRoutines"} {:osmodel} sdv_RunPowerCompletionRoutines(actual_DeviceObject_20: int, actual_MinorFunction_1: int, actual_structPtr888PowerState: int, actual_Context_7: int, actual_IoStatus: int, actual_CompletionFunction_1: int) returns (Tmp_937: int)
{
  var {:scalar} PowerState: int;
  var {:scalar} CompletionFunction_2: int;
  var {:pointer} structPtr888PowerState: int;

  anon0:
    call {:si_unique_call 1546} PowerState := __HAVOC_malloc(8);
    structPtr888PowerState := actual_structPtr888PowerState;
    assume {:nonnull} PowerState != 0;
    assume PowerState > 0;
    assume {:nonnull} structPtr888PowerState != 0;
    assume structPtr888PowerState > 0;
    assume {:nonnull} PowerState != 0;
    assume PowerState > 0;
    assume {:nonnull} structPtr888PowerState != 0;
    assume structPtr888PowerState > 0;
    CompletionFunction_2 := 0;
    Tmp_937 := CompletionFunction_2;
    return;
}



procedure {:origName "RtlInitUnicodeString"} {:osmodel} RtlInitUnicodeString(actual_DestinationString: int, actual_SourceString: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlInitUnicodeString"} {:osmodel} RtlInitUnicodeString(actual_DestinationString: int, actual_SourceString: int)
{
  var {:pointer} DestinationString: int;
  var {:pointer} SourceString: int;
  var vslice_dummy_var_234: int;

  anon0:
    call {:si_unique_call 1547} vslice_dummy_var_234 := __HAVOC_malloc(4);
    DestinationString := actual_DestinationString;
    SourceString := actual_SourceString;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    assume {:partition} DestinationString != 0;
    assume {:nonnull} DestinationString != 0;
    assume DestinationString > 0;
    assume {:nonnull} DestinationString != 0;
    assume DestinationString > 0;
    goto L4;

  L4:
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} SourceString == 0;
    assume {:nonnull} DestinationString != 0;
    assume DestinationString > 0;
    assume {:nonnull} DestinationString != 0;
    assume DestinationString > 0;
    goto L1;

  L1:
    return;

  anon6_Then:
    assume {:partition} SourceString != 0;
    goto L1;

  anon5_Then:
    assume {:partition} DestinationString == 0;
    goto L4;
}



procedure {:origName "sdv_RtlZeroMemory"} {:osmodel} sdv_RtlZeroMemory(actual_Destination: int, actual_Length: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RtlZeroMemory"} {:osmodel} sdv_RtlZeroMemory(actual_Destination: int, actual_Length: int)
{
  var vslice_dummy_var_235: int;

  anon0:
    call {:si_unique_call 1548} vslice_dummy_var_235 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_IoMarkIrpPending"} {:osmodel} sdv_IoMarkIrpPending(actual_pirp_9: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoMarkIrpPending"} {:osmodel} sdv_IoMarkIrpPending(actual_pirp_9: int)
{
  var vslice_dummy_var_236: int;

  anon0:
    call {:si_unique_call 1549} vslice_dummy_var_236 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_RunDispatchFunction"} {:osmodel} sdv_RunDispatchFunction(actual_po: int, actual_pirp_10: int) returns (Tmp_945: int);
  modifies alloc, Mem_T.CancelRoutine__IRP, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.INT4, Mem_T.Type_unnamed_tag_38, Mem_T.CancelIrql__IRP, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RunDispatchFunction"} {:osmodel} sdv_RunDispatchFunction(actual_po: int, actual_pirp_10: int) returns (Tmp_945: int)
{
  var {:pointer} ps: int;
  var {:scalar} minor: int;
  var {:scalar} sdv_382: int;
  var {:scalar} Tmp_947: int;
  var {:scalar} status_26: int;
  var {:scalar} Tmp_948: int;
  var {:pointer} po: int;
  var {:pointer} pirp_10: int;

  anon0:
    po := actual_po;
    pirp_10 := actual_pirp_10;
    status_26 := 0;
    minor := sdv_382;
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    ps := Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(pirp_10)))];
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    call {:si_unique_call 1550} sdv_SetStatus(pirp_10);
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(pirp_10)] := 0;
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    assume {:nonnull} ps != 0;
    assume ps > 0;
    Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] := minor;
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1551} sdv_stub_dispatch_begin();
    goto anon65_Then, anon65_Else;

  anon65_Else:
    goto anon84_Then, anon84_Else;

  anon84_Else:
    goto anon83_Then, anon83_Else;

  anon83_Else:
    goto anon82_Then, anon82_Else;

  anon82_Else:
    goto anon81_Then, anon81_Else;

  anon81_Else:
    goto anon80_Then, anon80_Else;

  anon80_Else:
    goto anon79_Then, anon79_Else;

  anon79_Else:
    goto anon78_Then, anon78_Else;

  anon78_Else:
    goto anon77_Then, anon77_Else;

  anon77_Else:
    goto anon76_Then, anon76_Else;

  anon76_Else:
    goto anon75_Then, anon75_Else;

  anon75_Else:
    goto anon74_Then, anon74_Else;

  anon74_Else:
    goto anon73_Then, anon73_Else;

  anon73_Else:
    goto anon72_Then, anon72_Else;

  anon72_Else:
    goto anon71_Then, anon71_Else;

  anon71_Else:
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    assume {:nonnull} ps != 0;
    assume ps > 0;
    goto anon95_Then, anon95_Else;

  anon95_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] != 0;
    goto L60;

  L60:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    goto anon67_Then, anon67_Else;

  anon67_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] == 3;
    goto anon69_Then, anon69_Else;

  anon69_Else:
    Tmp_948 := 0;
    goto L218;

  L218:
    assume Tmp_948 != 0;
    goto L61;

  L61:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    goto anon68_Then, anon68_Else;

  anon68_Else:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] == 2;
    goto L66;

  L66:
    call {:si_unique_call 1552} status_26 := MoxaPnpDispatch(po, pirp_10);
    goto anon96_Then, anon96_Else;

  anon96_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  L72:
    call {:si_unique_call 1553} sdv_stub_dispatch_end(status_26, 0);
    assume {:nonnull} pirp_10 != 0;
    assume pirp_10 > 0;
    Tmp_945 := status_26;
    goto LM2;

  LM2:
    return;

  anon96_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon68_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] != 2;
    goto L66;

  anon69_Then:
    Tmp_948 := 1;
    goto L218;

  anon67_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] != 3;
    goto L61;

  anon95_Then:
    assume {:partition} Mem_T.MinorFunction__IO_STACK_LOCATION[MinorFunction__IO_STACK_LOCATION(ps)] == 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume {:partition} sdv_start_irp_already_issued != 0;
    Tmp_947 := 0;
    goto L224;

  L224:
    assume Tmp_947 != 0;
    goto L60;

  anon66_Then:
    assume {:partition} sdv_start_irp_already_issued == 0;
    Tmp_947 := 1;
    goto L224;

  anon70_Then:
    call {:si_unique_call 1554} status_26 := sdv_DoNothing();
    goto L72;

  anon71_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1555} status_26 := sdv_DoNothing();
    goto L72;

  anon72_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1556} sdv_SetPowerIrpMinorFunction(pirp_10);
    call {:si_unique_call 1557} status_26 := MoxaPowerDispatch(po, pirp_10);
    goto anon94_Then, anon94_Else;

  anon94_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon94_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon73_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1558} status_26 := MoxaCleanup(po, pirp_10);
    goto anon93_Then, anon93_Else;

  anon93_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon93_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon74_Then:
    call {:si_unique_call 1559} status_26 := sdv_DoNothing();
    goto L72;

  anon75_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1560} status_26 := sdv_DoNothing();
    goto L72;

  anon76_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1561} status_26 := sdv_DoNothing();
    goto L72;

  anon77_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1562} status_26 := MoxaIoControl(po, pirp_10);
    goto anon92_Then, anon92_Else;

  anon92_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon92_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon78_Then:
    call {:si_unique_call 1563} status_26 := sdv_DoNothing();
    goto L72;

  anon79_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1564} status_26 := MoxaFlush(po, pirp_10);
    goto anon91_Then, anon91_Else;

  anon91_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon91_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon80_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1565} status_26 := MoxaSetInformationFile(po, pirp_10);
    goto anon90_Then, anon90_Else;

  anon90_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon90_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon81_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1566} status_26 := MoxaQueryInformationFile(po, pirp_10);
    goto anon89_Then, anon89_Else;

  anon89_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon89_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon82_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1567} status_26 := MoxaWrite(po, pirp_10);
    goto anon88_Then, anon88_Else;

  anon88_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon88_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon83_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1568} status_26 := MoxaRead(po, pirp_10);
    goto anon87_Then, anon87_Else;

  anon87_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon87_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon84_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1569} status_26 := MoxaClose(po, pirp_10);
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon86_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon65_Then:
    assume {:nonnull} ps != 0;
    assume ps > 0;
    call {:si_unique_call 1570} status_26 := MoxaCreateOpen(po, pirp_10);
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume {:partition} yogi_error != 1;
    goto L72;

  anon85_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "sdv_KeReleaseSpinLock"} {:osmodel} sdv_KeReleaseSpinLock(actual_SpinLock_1: int, actual_new_1: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4;
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_current == actual_new_1;
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_KeReleaseSpinLock"} {:osmodel} sdv_KeReleaseSpinLock(actual_SpinLock_1: int, actual_new_1: int)
{
  var {:scalar} new_1: int;
  var vslice_dummy_var_237: int;

  anon0:
    call {:si_unique_call 1571} vslice_dummy_var_237 := __HAVOC_malloc(4);
    new_1 := actual_new_1;
    sdv_irql_current := new_1;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    return;
}



procedure {:origName "sdv_IoCompleteRequest"} {:osmodel} sdv_IoCompleteRequest(actual_pirp_11: int, actual_PriorityBoost: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoCompleteRequest"} {:osmodel} sdv_IoCompleteRequest(actual_pirp_11: int, actual_PriorityBoost: int)
{
  var vslice_dummy_var_238: int;

  anon0:
    call {:si_unique_call 1572} vslice_dummy_var_238 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_RtlCopyMemory"} {:osmodel} sdv_RtlCopyMemory(actual_Destination_1: int, actual_Source: int, actual_Length_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RtlCopyMemory"} {:osmodel} sdv_RtlCopyMemory(actual_Destination_1: int, actual_Source: int, actual_Length_1: int)
{
  var vslice_dummy_var_239: int;

  anon0:
    call {:si_unique_call 1573} vslice_dummy_var_239 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "ZwQueryValueKey"} {:osmodel} ZwQueryValueKey(actual_KeyHandle: int, actual_ValueName_1: int, actual_KeyValueInformationClass: int, actual_KeyValueInformation: int, actual_Length_2: int, actual_ResultLength: int) returns (Tmp_955: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} Tmp_955 == -1073741811 || Tmp_955 == -1073741823 || Tmp_955 == 0 || Tmp_955 == 5 || Tmp_955 == -1073741789;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "ZwQueryValueKey"} {:osmodel} ZwQueryValueKey(actual_KeyHandle: int, actual_ValueName_1: int, actual_KeyValueInformationClass: int, actual_KeyValueInformation: int, actual_Length_2: int, actual_ResultLength: int) returns (Tmp_955: int)
{
  var {:scalar} L: int;
  var {:scalar} sdv_393: int;
  var {:scalar} Length_2: int;
  var {:pointer} ResultLength: int;

  anon0:
    Length_2 := actual_Length_2;
    ResultLength := actual_ResultLength;
    L := sdv_393;
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} 0 >= L;
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} L == 0;
    Tmp_955 := -1073741811;
    goto L1;

  L1:
    return;

  anon12_Then:
    assume {:partition} L != 0;
    Tmp_955 := -1073741823;
    goto L1;

  anon15_Then:
    assume {:partition} L > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:partition} L == Length_2;
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} Length_2 != 0;
    assume {:nonnull} ResultLength != 0;
    assume ResultLength > 0;
    Mem_T.INT4[ResultLength] := L;
    Tmp_955 := 0;
    goto L1;

  anon14_Then:
    assume {:partition} Length_2 == 0;
    goto L13;

  L13:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} L > Length_2;
    assume {:nonnull} ResultLength != 0;
    assume ResultLength > 0;
    Mem_T.INT4[ResultLength] := L;
    Tmp_955 := 5;
    goto L1;

  anon13_Then:
    assume {:partition} Length_2 >= L;
    assume {:nonnull} ResultLength != 0;
    assume ResultLength > 0;
    Mem_T.INT4[ResultLength] := L;
    Tmp_955 := -1073741789;
    goto L1;

  anon11_Then:
    assume {:partition} L != Length_2;
    goto L13;
}



procedure {:origName "KeSynchronizeExecution"} {:osmodel} KeSynchronizeExecution(actual_Interrupt: int, actual_SynchronizeRoutine: int, actual_SynchronizeContext: int) returns (Tmp_957: int);
  free ensures {:va_keep} Tmp_957 == 1 || Tmp_957 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeSynchronizeExecution"} {:osmodel} KeSynchronizeExecution(actual_Interrupt: int, actual_SynchronizeRoutine: int, actual_SynchronizeContext: int) returns (Tmp_957: int)
{
  var {:scalar} b_1: int;

  anon0:
    call {:si_unique_call 1574} b_1 := OneOfTwoBOOLEAN();
    Tmp_957 := b_1;
    return;
}



procedure {:origName "sdv_ExFreePool"} {:osmodel} sdv_ExFreePool(actual_P: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_ExFreePool"} {:osmodel} sdv_ExFreePool(actual_P: int)
{
  var vslice_dummy_var_240: int;

  anon0:
    call {:si_unique_call 1575} vslice_dummy_var_240 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_InterlockedIncrement"} {:osmodel} sdv_InterlockedIncrement(actual_Addend_1: int) returns (Tmp_963: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_InterlockedIncrement"} {:osmodel} sdv_InterlockedIncrement(actual_Addend_1: int) returns (Tmp_963: int)
{
  var {:pointer} Addend_1: int;

  anon0:
    Addend_1 := actual_Addend_1;
    assume {:nonnull} Addend_1 != 0;
    assume Addend_1 > 0;
    Mem_T.INT4[Addend_1] := Mem_T.INT4[Addend_1] + 1;
    assume {:nonnull} Addend_1 != 0;
    assume Addend_1 > 0;
    Tmp_963 := Mem_T.INT4[Addend_1];
    return;
}



procedure {:origName "ExReleaseFastMutex"} {:osmodel} ExReleaseFastMutex(actual_FastMutex_1: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4;
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "ExReleaseFastMutex"} {:osmodel} ExReleaseFastMutex(actual_FastMutex_1: int)
{
  var vslice_dummy_var_241: int;

  anon0:
    call {:si_unique_call 1576} vslice_dummy_var_241 := __HAVOC_malloc(4);
    sdv_irql_current := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    return;
}



procedure {:origName "sdv_IsListEmpty"} {:osmodel} sdv_IsListEmpty(actual_ListHead_2: int) returns (Tmp_967: int);
  free ensures {:va_keep} Tmp_967 == 1 || Tmp_967 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IsListEmpty"} {:osmodel} sdv_IsListEmpty(actual_ListHead_2: int) returns (Tmp_967: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_967 := 1;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_967 := 0;
    goto L1;
}



procedure {:origName "IofCallDriver"} {:osmodel} IofCallDriver(actual_DeviceObject_21: int, actual_Irp_19: int) returns (Tmp_969: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_969 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IofCallDriver"} {:osmodel} IofCallDriver(actual_DeviceObject_21: int, actual_Irp_19: int) returns (Tmp_969: int)
{
  var {:dopa} {:scalar} completion_1: int;
  var {:scalar} status_27: int;
  var {:pointer} Irp_19: int;
  var vslice_dummy_var_242: int;
  var vslice_dummy_var_243: int;
  var vslice_dummy_var_244: int;
  var vslice_dummy_var_245: int;
  var vslice_dummy_var_1342: int;
  var vslice_dummy_var_1343: int;
  var vslice_dummy_var_1344: int;
  var vslice_dummy_var_1345: int;

  anon0:
    call {:si_unique_call 1577} completion_1 := __HAVOC_malloc(4);
    Irp_19 := actual_Irp_19;
    assume {:nonnull} completion_1 != 0;
    assume completion_1 > 0;
    Mem_T.INT4[completion_1] := 0;
    status_27 := 259;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    goto anon61_Then, anon61_Else;

  anon61_Else:
    goto anon60_Then, anon60_Else;

  anon60_Else:
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    goto anon65_Then, anon65_Else;

  anon65_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_19;
    goto L19;

  L19:
    goto anon45_Then, anon45_Else;

  anon45_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L21;

  L21:
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L23;

  L23:
    goto anon47_Then, anon47_Else;

  anon47_Else:
    goto L29;

  L29:
    Tmp_969 := status_27;
    return;

  anon47_Then:
    havoc vslice_dummy_var_1342;
    call {:si_unique_call 1578} vslice_dummy_var_242 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_19, vslice_dummy_var_1342, completion_1);
    goto L29;

  anon46_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_19;
    goto L23;

  anon45_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_19;
    goto L21;

  anon65_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_19;
    goto L19;

  anon60_Then:
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_19;
    goto L58;

  L58:
    goto anon56_Then, anon56_Else;

  anon56_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L60;

  L60:
    goto anon57_Then, anon57_Else;

  anon57_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L62;

  L62:
    goto anon58_Then, anon58_Else;

  anon58_Else:
    goto anon59_Then, anon59_Else;

  anon59_Else:
    havoc vslice_dummy_var_1343;
    call {:si_unique_call 1579} vslice_dummy_var_245 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_19, vslice_dummy_var_1343, completion_1);
    goto L29;

  anon59_Then:
    goto L29;

  anon58_Then:
    goto L29;

  anon57_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_19;
    goto L62;

  anon56_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_19;
    goto L60;

  anon66_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_19;
    goto L58;

  anon61_Then:
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_19;
    goto L32;

  L32:
    goto anon48_Then, anon48_Else;

  anon48_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L34;

  L34:
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L36;

  L36:
    goto anon50_Then, anon50_Else;

  anon50_Else:
    goto anon51_Then, anon51_Else;

  anon51_Else:
    havoc vslice_dummy_var_1344;
    call {:si_unique_call 1580} vslice_dummy_var_243 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_19, vslice_dummy_var_1344, completion_1);
    goto L29;

  anon51_Then:
    goto L29;

  anon50_Then:
    goto L29;

  anon49_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_19;
    goto L36;

  anon48_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_19;
    goto L34;

  anon64_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_19;
    goto L32;

  anon62_Then:
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    assume {:nonnull} Irp_19 != 0;
    assume Irp_19 > 0;
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp == Irp_19;
    goto L45;

  L45:
    goto anon52_Then, anon52_Else;

  anon52_Else:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildSynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock > 0;
    goto L47;

  L47:
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp == Irp_19;
    assume {:nonnull} sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock != 0;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock > 0;
    goto L49;

  L49:
    goto anon54_Then, anon54_Else;

  anon54_Else:
    goto anon55_Then, anon55_Else;

  anon55_Else:
    havoc vslice_dummy_var_1345;
    call {:si_unique_call 1581} vslice_dummy_var_244 := sdv_RunIoCompletionRoutines(sdv_p_devobj_fdo, Irp_19, vslice_dummy_var_1345, completion_1);
    goto L29;

  anon55_Then:
    goto L29;

  anon54_Then:
    goto L29;

  anon53_Then:
    assume {:partition} sdv_IoBuildAsynchronousFsdRequest_irp != Irp_19;
    goto L49;

  anon52_Then:
    assume {:partition} sdv_IoBuildSynchronousFsdRequest_irp != Irp_19;
    goto L47;

  anon63_Then:
    assume {:partition} sdv_IoBuildDeviceIoControlRequest_irp != Irp_19;
    goto L45;
}



procedure {:origName "IoDisconnectInterrupt"} {:osmodel} IoDisconnectInterrupt(actual_InterruptObject_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoDisconnectInterrupt"} {:osmodel} IoDisconnectInterrupt(actual_InterruptObject_1: int)
{
  var vslice_dummy_var_246: int;

  anon0:
    call {:si_unique_call 1582} vslice_dummy_var_246 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_RunIoCompletionRoutines"} {:osmodel} sdv_RunIoCompletionRoutines(actual_DeviceObject_22: int, actual_Irp_20: int, actual_Context_8: int, actual_Completion: int) returns (Tmp_973: int);
  modifies sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_973 == -1073741802 || Tmp_973 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RunIoCompletionRoutines"} {:osmodel} sdv_RunIoCompletionRoutines(actual_DeviceObject_22: int, actual_Irp_20: int, actual_Context_8: int, actual_Completion: int) returns (Tmp_973: int)
{
  var {:scalar} Status: int;
  var {:pointer} irpsp: int;
  var {:pointer} DeviceObject_22: int;
  var {:pointer} Irp_20: int;
  var {:pointer} Context_8: int;
  var {:pointer} Completion: int;

  anon0:
    DeviceObject_22 := actual_DeviceObject_22;
    Irp_20 := actual_Irp_20;
    Context_8 := actual_Context_8;
    Completion := actual_Completion;
    call {:si_unique_call 1583} irpsp := sdv_IoGetNextIrpStackLocation(Irp_20);
    Status := 0;
    assume {:nonnull} irpsp != 0;
    assume irpsp > 0;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1584} Status := MoxaSyncCompletion(DeviceObject_22, Irp_20, Context_8);
    sdv_irql_current := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    assume {:nonnull} Completion != 0;
    assume Completion > 0;
    Mem_T.INT4[Completion] := 1;
    goto L11;

  L11:
    Tmp_973 := Status;
    return;

  anon3_Then:
    goto L11;
}



procedure {:origName "KeInitializeEvent"} {:osmodel} KeInitializeEvent(actual_Event_1: int, actual_Type_1: int, actual_State_1: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeInitializeEvent"} {:osmodel} KeInitializeEvent(actual_Event_1: int, actual_Type_1: int, actual_State_1: int)
{
  var {:pointer} Event_1: int;
  var {:scalar} Type_1: int;
  var {:scalar} State_1: int;
  var vslice_dummy_var_247: int;

  anon0:
    call {:si_unique_call 1585} vslice_dummy_var_247 := __HAVOC_malloc(4);
    Event_1 := actual_Event_1;
    Type_1 := actual_Type_1;
    State_1 := actual_State_1;
    assume {:nonnull} Event_1 != 0;
    assume Event_1 > 0;
    assume {:nonnull} Event_1 != 0;
    assume Event_1 > 0;
    assume {:nonnull} Event_1 != 0;
    assume Event_1 > 0;
    assume {:nonnull} Event_1 != 0;
    assume Event_1 > 0;
    return;
}



procedure {:origName "_sdv_init18"} {:osmodel} _sdv_init18();
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> sdv_irql_current <= 2 && sdv_irql_previous <= 2 && sdv_irql_previous_2 <= 2 && sdv_irql_previous_3 <= 2 && sdv_irql_current >= 0 && sdv_irql_previous >= 0 && sdv_irql_previous_2 >= 0 && sdv_irql_previous_3 >= 0;
  free ensures {:va_keep} sdv_irql_previous_5 == 0;
  free ensures {:va_keep} sdv_irql_previous_2 == 0;
  free ensures {:va_keep} sdv_irql_current == 0;
  free ensures {:va_keep} sdv_irql_previous == 0;
  free ensures {:va_keep} sdv_irql_previous_4 == 0;
  free ensures {:va_keep} sdv_irql_previous_3 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "_sdv_init18"} {:osmodel} _sdv_init18()
{
  var vslice_dummy_var_248: int;

  anon0:
    call {:si_unique_call 1586} vslice_dummy_var_248 := __HAVOC_malloc(4);
    assume sdv_apc_disabled == 0;
    assume sdv_ControllerPirp == sdv_ControllerIrp;
    assume sdv_StartIopirp == sdv_StartIoIrp;
    assume sdv_power_irp == sdv_PowerIrp;
    assume sdv_irp == sdv_harnessIrp;
    assume sdv_other_irp == sdv_other_harnessIrp;
    assume sdv_IoMakeAssociatedIrp_irp == sdv_IoMakeAssociatedIrp_harnessIrp;
    assume sdv_IoBuildDeviceIoControlRequest_irp == sdv_IoBuildDeviceIoControlRequest_harnessIrp;
    assume sdv_IoBuildSynchronousFsdRequest_irp == sdv_IoBuildSynchronousFsdRequest_harnessIrp;
    assume sdv_IoBuildSynchronousFsdRequest_IoStatusBlock == sdv_harness_IoBuildSynchronousFsdRequest_IoStatusBlock;
    assume sdv_IoBuildAsynchronousFsdRequest_irp == sdv_IoBuildAsynchronousFsdRequest_harnessIrp;
    assume sdv_IoBuildAsynchronousFsdRequest_IoStatusBlock == sdv_harness_IoBuildAsynchronousFsdRequest_IoStatusBlock;
    assume sdv_IoInitializeIrp_irp == sdv_IoInitializeIrp_harnessIrp;
    assume sdv_io_create_device_called == 0;
    sdv_irql_current := 0;
    sdv_irql_previous := 0;
    sdv_irql_previous_2 := 0;
    sdv_irql_previous_3 := 0;
    sdv_irql_previous_4 := 0;
    sdv_irql_previous_5 := 0;
    assume sdv_maskedEflags == 0;
    assume sdv_p_devobj_fdo == sdv_devobj_fdo;
    assume sdv_inside_init_entrypoint == 0;
    assume sdv_p_devobj_pdo == sdv_devobj_pdo;
    assume sdv_p_devobj_child_pdo == sdv_devobj_child_pdo;
    assume sdv_kinterrupt == sdv_kinterrupt_val;
    assume sdv_MapRegisterBase == sdv_MapRegisterBase_val;
    assume sdv_start_irp_already_issued == 0;
    assume sdv_Io_Removelock_release_wait_returned == 0;
    assume sdv_ke_dpc == li2bplFunctionConstant472;
    assume sdv_io_dpc == li2bplFunctionConstant475;
    assume sdv_p_devobj_top == sdv_devobj_top;
    assume sdv_MmMapIoSpace_int == 0;
    return;
}



procedure {:origName "sdv_IoCallDriver"} {:osmodel} sdv_IoCallDriver(actual_DeviceObject_23: int, actual_Irp_21: int) returns (Tmp_979: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} Tmp_979 == 259;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_IoCallDriver"} {:osmodel} sdv_IoCallDriver(actual_DeviceObject_23: int, actual_Irp_21: int) returns (Tmp_979: int)
{
  var {:pointer} Irp_21: int;

  anon0:
    Irp_21 := actual_Irp_21;
    call {:si_unique_call 1587} Tmp_979 := IofCallDriver(0, Irp_21);
    return;
}



procedure {:origName "IoBuildDeviceIoControlRequest"} {:osmodel} IoBuildDeviceIoControlRequest(actual_IoControlCode: int, actual_DeviceObject_24: int, actual_InputBuffer: int, actual_InputBufferLength: int, actual_OutputBuffer: int, actual_OutputBufferLength: int, actual_InternalDeviceIoControl: int, actual_Event_2: int, actual_IoStatusBlock_1: int) returns (Tmp_981: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoBuildDeviceIoControlRequest"} {:osmodel} IoBuildDeviceIoControlRequest(actual_IoControlCode: int, actual_DeviceObject_24: int, actual_InputBuffer: int, actual_InputBufferLength: int, actual_OutputBuffer: int, actual_OutputBufferLength: int, actual_InternalDeviceIoControl: int, actual_Event_2: int, actual_IoStatusBlock_1: int) returns (Tmp_981: int)
{
  var {:pointer} Tmp_982: int;
  var {:pointer} Tmp_983: int;
  var {:scalar} InternalDeviceIoControl: int;
  var {:pointer} IoStatusBlock_1: int;

  anon0:
    InternalDeviceIoControl := actual_InternalDeviceIoControl;
    IoStatusBlock_1 := actual_IoStatusBlock_1;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} InternalDeviceIoControl != 0;
    assume {:nonnull} sdv_IoBuildDeviceIoControlRequest_irp != 0;
    assume sdv_IoBuildDeviceIoControlRequest_irp > 0;
    Tmp_982 := Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(sdv_IoBuildDeviceIoControlRequest_irp)))];
    assume {:nonnull} Tmp_982 != 0;
    assume Tmp_982 > 0;
    goto L14;

  L14:
    assume {:nonnull} sdv_IoBuildDeviceIoControlRequest_irp != 0;
    assume sdv_IoBuildDeviceIoControlRequest_irp > 0;
    assume {:nonnull} IoStatusBlock_1 != 0;
    assume IoStatusBlock_1 > 0;
    Tmp_981 := sdv_IoBuildDeviceIoControlRequest_irp;
    goto L1;

  L1:
    return;

  anon6_Then:
    assume {:partition} InternalDeviceIoControl == 0;
    assume {:nonnull} sdv_IoBuildDeviceIoControlRequest_irp != 0;
    assume sdv_IoBuildDeviceIoControlRequest_irp > 0;
    Tmp_983 := Mem_T.CurrentStackLocation_unnamed_tag_7[CurrentStackLocation_unnamed_tag_7(Overlay_unnamed_tag_6(Tail__IRP(sdv_IoBuildDeviceIoControlRequest_irp)))];
    assume {:nonnull} Tmp_983 != 0;
    assume Tmp_983 > 0;
    goto L14;

  anon5_Then:
    assume {:nonnull} IoStatusBlock_1 != 0;
    assume IoStatusBlock_1 > 0;
    Tmp_981 := 0;
    goto L1;
}



procedure {:origName "IoAcquireCancelSpinLock"} {:osmodel} IoAcquireCancelSpinLock(actual_p_2: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> sdv_irql_current <= 2 && sdv_irql_previous <= 2 && sdv_irql_previous_2 <= 2 && sdv_irql_previous_3 <= 2 && sdv_irql_current >= 0 && sdv_irql_previous >= 0 && sdv_irql_previous_2 >= 0 && sdv_irql_previous_3 >= 0;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_current == 2;
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoAcquireCancelSpinLock"} {:osmodel} IoAcquireCancelSpinLock(actual_p_2: int)
{
  var {:pointer} p_2: int;
  var vslice_dummy_var_249: int;

  anon0:
    call {:si_unique_call 1588} vslice_dummy_var_249 := __HAVOC_malloc(4);
    p_2 := actual_p_2;
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    assume {:nonnull} p_2 != 0;
    assume p_2 > 0;
    Mem_T.INT4[p_2] := sdv_irql_previous;
    return;
}



procedure {:origName "ExAllocatePoolWithTag"} {:osmodel} ExAllocatePoolWithTag(actual_PoolType: int, actual_NumberOfBytes: int, actual_Tag: int) returns (Tmp_989: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "ExAllocatePoolWithTag"} {:osmodel} ExAllocatePoolWithTag(actual_PoolType: int, actual_NumberOfBytes: int, actual_Tag: int) returns (Tmp_989: int)
{
  var {:pointer} sdv_407: int;
  var {:scalar} NumberOfBytes: int;

  anon0:
    NumberOfBytes := actual_NumberOfBytes;
    goto anon3_Then, anon3_Else;

  anon3_Else:
    call {:si_unique_call 1589} sdv_407 := __HAVOC_malloc(NumberOfBytes);
    Tmp_989 := sdv_407;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_989 := 0;
    goto L1;
}



procedure {:origName "RtlWriteRegistryValue"} {:osmodel} RtlWriteRegistryValue(actual_RelativeTo_1: int, actual_Path_1: int, actual_ValueName_2: int, actual_ValueType: int, actual_ValueData: int, actual_ValueLength: int) returns (Tmp_991: int);
  free ensures {:va_keep} Tmp_991 == 0 || Tmp_991 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "RtlWriteRegistryValue"} {:osmodel} RtlWriteRegistryValue(actual_RelativeTo_1: int, actual_Path_1: int, actual_ValueName_2: int, actual_ValueType: int, actual_ValueData: int, actual_ValueLength: int) returns (Tmp_991: int)
{

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    Tmp_991 := 0;
    goto L1;

  L1:
    return;

  anon3_Then:
    Tmp_991 := -1073741823;
    goto L1;
}



procedure {:origName "IoSetDeviceInterfaceState"} {:osmodel} IoSetDeviceInterfaceState(actual_SymbolicLinkName_2: int, actual_Enable: int) returns (Tmp_993: int);
  free ensures {:va_keep} Tmp_993 == -1073741772 || Tmp_993 == -1073741824 || Tmp_993 == -1073741789 || Tmp_993 == -1073741670 || Tmp_993 == -1073741808 || Tmp_993 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoSetDeviceInterfaceState"} {:osmodel} IoSetDeviceInterfaceState(actual_SymbolicLinkName_2: int, actual_Enable: int) returns (Tmp_993: int)
{

  anon0:
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    Tmp_993 := -1073741772;
    goto L1;

  L1:
    return;

  anon12_Then:
    Tmp_993 := -1073741824;
    goto L1;

  anon13_Then:
    Tmp_993 := -1073741789;
    goto L1;

  anon14_Then:
    Tmp_993 := -1073741670;
    goto L1;

  anon15_Then:
    Tmp_993 := -1073741808;
    goto L1;

  anon11_Then:
    Tmp_993 := 0;
    goto L1;
}



procedure {:origName "IoConnectInterrupt"} {:osmodel} IoConnectInterrupt(actual_InterruptObject_2: int, actual_ServiceRoutine: int, actual_ServiceContext: int, actual_SpinLock_2: int, actual_Vector: int, actual_Irql_1: int, actual_SynchronizeIrql: int, actual_InterruptMode: int, actual_ShareVector: int, actual_ProcessorEnableMask: int, actual_FloatingSave: int) returns (Tmp_995: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoConnectInterrupt"} {:osmodel} IoConnectInterrupt(actual_InterruptObject_2: int, actual_ServiceRoutine: int, actual_ServiceContext: int, actual_SpinLock_2: int, actual_Vector: int, actual_Irql_1: int, actual_SynchronizeIrql: int, actual_InterruptMode: int, actual_ShareVector: int, actual_ProcessorEnableMask: int, actual_FloatingSave: int) returns (Tmp_995: int)
{
  var {:pointer} InterruptObject_2: int;
  var {:scalar} ServiceRoutine: int;
  var {:pointer} ServiceContext: int;

  anon0:
    InterruptObject_2 := actual_InterruptObject_2;
    ServiceRoutine := actual_ServiceRoutine;
    ServiceContext := actual_ServiceContext;
    goto anon8_Then, anon8_Else;

  anon8_Else:
    goto anon7_Then, anon7_Else;

  anon7_Else:
    Tmp_995 := -1073741811;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon7_Then:
    Tmp_995 := -1073741670;
    goto L1;

  anon8_Then:
    call {:si_unique_call 1590} sdv_RunISRRoutines(InterruptObject_2, ServiceContext);
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} yogi_error != 1;
    Tmp_995 := 0;
    goto L1;

  anon9_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "sdv_stub_driver_init"} {:osmodel} sdv_stub_driver_init();
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_stub_driver_init"} {:osmodel} sdv_stub_driver_init()
{
  var vslice_dummy_var_250: int;

  anon0:
    call {:si_unique_call 1591} vslice_dummy_var_250 := __HAVOC_malloc(4);
    return;
}



procedure {:origName "sdv_stub_dispatch_begin"} {:osmodel} sdv_stub_dispatch_begin();
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> sdv_irql_current <= 2 && sdv_irql_previous <= 2 && sdv_irql_previous_2 <= 2 && sdv_irql_previous_3 <= 2 && sdv_irql_current >= 0 && sdv_irql_previous >= 0 && sdv_irql_previous_2 >= 0 && sdv_irql_previous_3 >= 0;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_current == 0;
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_stub_dispatch_begin"} {:osmodel} sdv_stub_dispatch_begin()
{
  var vslice_dummy_var_251: int;

  anon0:
    call {:si_unique_call 1592} vslice_dummy_var_251 := __HAVOC_malloc(4);
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 0;
    return;
}



procedure {:origName "IoOpenDeviceRegistryKey"} {:osmodel} IoOpenDeviceRegistryKey(actual_DeviceObject_25: int, actual_DevInstKeyType: int, actual_DesiredAccess: int, actual_DevInstRegKey: int) returns (Tmp_1001: int);
  free ensures {:va_keep} Tmp_1001 == -1073741811 || Tmp_1001 == -1073741808 || Tmp_1001 == -1073741823 || Tmp_1001 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoOpenDeviceRegistryKey"} {:osmodel} IoOpenDeviceRegistryKey(actual_DeviceObject_25: int, actual_DevInstKeyType: int, actual_DesiredAccess: int, actual_DevInstRegKey: int) returns (Tmp_1001: int)
{

  anon0:
    goto anon7_Then, anon7_Else;

  anon7_Else:
    goto anon9_Then, anon9_Else;

  anon9_Else:
    goto anon8_Then, anon8_Else;

  anon8_Else:
    Tmp_1001 := -1073741811;
    goto L1;

  L1:
    return;

  anon8_Then:
    Tmp_1001 := -1073741808;
    goto L1;

  anon9_Then:
    Tmp_1001 := -1073741823;
    goto L1;

  anon7_Then:
    Tmp_1001 := 0;
    goto L1;
}



procedure {:origName "ZwClose"} {:osmodel} ZwClose(actual_Handle_1: int) returns (Tmp_1003: int);
  free ensures {:va_keep} Tmp_1003 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "ZwClose"} {:osmodel} ZwClose(actual_Handle_1: int) returns (Tmp_1003: int)
{

  anon0:
    Tmp_1003 := 0;
    return;
}



procedure {:origName "sdv_DoNothing"} {:osmodel} sdv_DoNothing() returns (Tmp_1005: int);
  free ensures {:va_keep} Tmp_1005 == -1073741823;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_DoNothing"} {:osmodel} sdv_DoNothing() returns (Tmp_1005: int)
{

  anon0:
    Tmp_1005 := -1073741823;
    return;
}



procedure {:origName "IoWMIRegistrationControl"} {:osmodel} IoWMIRegistrationControl(actual_DeviceObject_26: int, actual_Action: int) returns (Tmp_1007: int);
  free ensures {:va_keep} Tmp_1007 == -1073741823 || Tmp_1007 == -1073741811 || Tmp_1007 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "IoWMIRegistrationControl"} {:osmodel} IoWMIRegistrationControl(actual_DeviceObject_26: int, actual_Action: int) returns (Tmp_1007: int)
{

  anon0:
    goto anon5_Then, anon5_Else;

  anon5_Else:
    goto anon6_Then, anon6_Else;

  anon6_Else:
    Tmp_1007 := -1073741823;
    goto L1;

  L1:
    return;

  anon6_Then:
    Tmp_1007 := -1073741811;
    goto L1;

  anon5_Then:
    Tmp_1007 := 0;
    goto L1;
}



procedure {:origName "KeClearEvent"} {:osmodel} KeClearEvent(actual_Event_3: int);
  modifies alloc, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeClearEvent"} {:osmodel} KeClearEvent(actual_Event_3: int)
{
  var {:pointer} Event_3: int;
  var vslice_dummy_var_252: int;

  anon0:
    call {:si_unique_call 1593} vslice_dummy_var_252 := __HAVOC_malloc(4);
    Event_3 := actual_Event_3;
    call {:si_unique_call 1594} SLIC_KeClearEvent_entry(strConst__li2bpl25);
    goto anon3_Then, anon3_Else;

  anon3_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} Event_3 != 0;
    assume Event_3 > 0;
    goto LM2;

  LM2:
    return;

  anon3_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:dopa "Mem_T.INT4"} dummy_for_pa();



procedure corralExplainErrorInit();



procedure corralExtraInit();
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation corralExtraInit()
{

  anon0:
    assume 0 < alloc_init;
    assume alloc_init < alloc;
    assume (forall x: int :: { Mem_T.CancelRoutine__IRP[x] } Mem_T.CancelRoutine__IRP[x] <= 0 || Mem_T.CancelRoutine__IRP[x] > 475);
    return;
}



function {:inline true} {:fieldmap "Mem_T.AllocationSize__FILE_STANDARD_INFORMATION"} {:fieldname "AllocationSize"} AllocationSize__FILE_STANDARD_INFORMATION(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.PVOID"} {:fieldname "Argument4"} Argument4_unnamed_tag_41(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.unnamed_tag_3"} {:fieldname "AssociatedIrp"} AssociatedIrp__IRP(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.BankAddr__MOXA_GLOBAL_DATA"} {:fieldname "BankAddr"} BankAddr__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 192
}

function {:inline true} {:fieldmap "Mem_T.BaseIOAddress__SERIAL_WMI_HW_DATA"} {:fieldname "BaseIOAddress"} BaseIOAddress__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.BaudRate__MOXA_IOCTL_PortStatus"} {:fieldname "BaudRate"} BaudRate__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.BaudRate__SERIAL_BAUD_RATE"} {:fieldname "BaudRate"} BaudRate__SERIAL_BAUD_RATE(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.BitsPerByte__SERIAL_WMI_COMM_DATA"} {:fieldname "BitsPerByte"} BitsPerByte__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Blink__LIST_ENTRY"} {:fieldname "Blink"} Blink__LIST_ENTRY(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.BoardNo__MOXA_DEVICE_EXTENSION"} {:fieldname "BoardNo"} BoardNo__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1304
}

function {:inline true} {:fieldmap "Mem_T.BoardNo__SERIAL_MULTIPORT_DISPATCH"} {:fieldname "BoardNo"} BoardNo__SERIAL_MULTIPORT_DISPATCH(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.BoardReady__MOXA_GLOBAL_DATA"} {:fieldname "BoardReady"} BoardReady__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 1972
}

function {:inline true} {:fieldmap "Mem_T.BreakChar__SERIAL_CHARS"} {:fieldname "BreakChar"} BreakChar__SERIAL_CHARS(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.BufferOverrunErrorCount__SERIALPERF_STATS"} {:fieldname "BufferOverrunErrorCount"} BufferOverrunErrorCount__SERIALPERF_STATS(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.BufferSizePt8__MOXA_DEVICE_EXTENSION"} {:fieldname "BufferSizePt8"} BufferSizePt8__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 180
}

function {:inline true} {:fieldmap "Mem_T.Buffer__UNICODE_STRING"} {:fieldname "Buffer"} Buffer__UNICODE_STRING(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.CancelIrql__IRP"} {:fieldname "CancelIrql"} CancelIrql__IRP(x: int) : int
{
  x + 68
}

function {:inline true} {:fieldmap "Mem_T.CancelRoutine__IRP"} {:fieldname "CancelRoutine"} CancelRoutine__IRP(x: int) : int
{
  x + 120
}

function {:inline true} {:fieldmap "Mem_T.Cancel__IRP"} {:fieldname "Cancel"} Cancel__IRP(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.Capabilities_unnamed_tag_29"} {:fieldname "Capabilities"} Capabilities_unnamed_tag_29(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.CardBase__MOXA_GLOBAL_DATA"} {:fieldname "CardBase"} CardBase__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 368
}

function {:inline true} {:fieldmap "Mem_T.CardType__MOXA_GLOBAL_DATA"} {:fieldname "CardType"} CardType__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 320
}

function {:inline true} {:fieldmap "Mem_T.ClockType__MOXA_DEVICE_EXTENSION"} {:fieldname "ClockType"} ClockType__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 52
}

function {:inline true} {:fieldmap "Mem_T.ComNo__MOXA_GLOBAL_DATA"} {:fieldname "ComNo"} ComNo__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 944
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "CommErrorDpc"} CommErrorDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 980
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "CommWaitDpc"} CommWaitDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1020
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "CompleteReadDpc"} CompleteReadDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 820
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "CompleteWriteDpc"} CompleteWriteDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 780
}

function {:inline true} {:fieldmap "Mem_T.CompletionRoutine__IO_STACK_LOCATION"} {:fieldname "CompletionRoutine"} CompletionRoutine__IO_STACK_LOCATION(x: int) : int
{
  x + 496
}

function {:inline true} {:fieldmap "Mem_T.ControlDevice__MOXA_DEVICE_EXTENSION"} {:fieldname "ControlDevice"} ControlDevice__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.ControlHandShake__SERIAL_HANDFLOW"} {:fieldname "ControlHandShake"} ControlHandShake__SERIAL_HANDFLOW(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.CountOnLastRead__MOXA_DEVICE_EXTENSION"} {:fieldname "CountOnLastRead"} CountOnLastRead__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 216
}

function {:inline true} {:fieldmap "Mem_T.Create_unnamed_tag_9"} {:fieldname "Create"} Create_unnamed_tag_9(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.CreatedSerialCommEntry__MOXA_DEVICE_EXTENSION"} {:fieldname "CreatedSerialCommEntry"} CreatedSerialCommEntry__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1360
}

function {:inline true} {:fieldmap "Mem_T.CreatedSymbolicLink__MOXA_DEVICE_EXTENSION"} {:fieldname "CreatedSymbolicLink"} CreatedSymbolicLink__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1356
}

function {:inline true} {:fieldmap "Mem_T.CurrentBaud__MOXA_DEVICE_EXTENSION"} {:fieldname "CurrentBaud"} CurrentBaud__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 56
}

function {:inline true} {:fieldmap "Mem_T.CurrentByteOffset__FILE_POSITION_INFORMATION"} {:fieldname "CurrentByteOffset"} CurrentByteOffset__FILE_POSITION_INFORMATION(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.P_IRP"} {:fieldname "CurrentMaskIrp"} CurrentMaskIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 288
}

function {:inline true} {:fieldmap "Mem_T.P_IRP"} {:fieldname "CurrentPurgeIrp"} CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 292
}

function {:inline true} {:fieldmap "Mem_T.P_IRP"} {:fieldname "CurrentReadIrp"} CurrentReadIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 280
}

function {:inline true} {:fieldmap "Mem_T.CurrentRxQueue__SERIAL_COMMPROP"} {:fieldname "CurrentRxQueue"} CurrentRxQueue__SERIAL_COMMPROP(x: int) : int
{
  x + 56
}

function {:inline true} {:fieldmap "Mem_T.CurrentStackLocation_unnamed_tag_7"} {:fieldname "CurrentStackLocation"} CurrentStackLocation_unnamed_tag_7(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T.CurrentTxQueue__SERIAL_COMMPROP"} {:fieldname "CurrentTxQueue"} CurrentTxQueue__SERIAL_COMMPROP(x: int) : int
{
  x + 52
}

function {:inline true} {:fieldmap "Mem_T.P_IRP"} {:fieldname "CurrentWaitIrp"} CurrentWaitIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 296
}

function {:inline true} {:fieldmap "Mem_T.P_IRP"} {:fieldname "CurrentWriteIrp"} CurrentWriteIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 284
}

function {:inline true} {:fieldmap "Mem_T.CutOverAmount__MOXA_DEVICE_EXTENSION"} {:fieldname "CutOverAmount"} CutOverAmount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1244
}

function {:inline true} {:fieldmap "Mem_T.Data1__GUID"} {:fieldname "Data1"} Data1__GUID(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.Data2__GUID"} {:fieldname "Data2"} Data2__GUID(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Data3__GUID"} {:fieldname "Data3"} Data3__GUID(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.Data4__GUID"} {:fieldname "Data4"} Data4__GUID(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.DataLength__KEY_VALUE_FULL_INFORMATION"} {:fieldname "DataLength"} DataLength__KEY_VALUE_FULL_INFORMATION(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.DataMode__MOXA_DEVICE_EXTENSION"} {:fieldname "DataMode"} DataMode__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 60
}

function {:inline true} {:fieldmap "Mem_T.DataMode__MOXA_IOCTL_PortStatus"} {:fieldname "DataMode"} DataMode__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.Data__MOXA_IOCTL_SYNC"} {:fieldname "Data"} Data__MOXA_IOCTL_SYNC(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.DeferredRoutine__KDPC"} {:fieldname "DeferredRoutine"} DeferredRoutine__KDPC(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.DeletePending__FILE_STANDARD_INFORMATION"} {:fieldname "DeletePending"} DeletePending__FILE_STANDARD_INFORMATION(x: int) : int
{
  x + 44
}

function {:inline true} {:fieldmap "Mem_T.DeviceCapabilities_unnamed_tag_9"} {:fieldname "DeviceCapabilities"} DeviceCapabilities_unnamed_tag_9(x: int) : int
{
  x + 312
}

function {:inline true} {:fieldmap "Mem_T._UNICODE_STRING"} {:fieldname "DeviceClassSymbolicName"} DeviceClassSymbolicName__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1504
}

function {:inline true} {:fieldmap "Mem_T.DeviceExtension__DEVICE_OBJECT"} {:fieldname "DeviceExtension"} DeviceExtension__DEVICE_OBJECT(x: int) : int
{
  x + 44
}

function {:inline true} {:fieldmap "Mem_T.DeviceIoControl_unnamed_tag_9"} {:fieldname "DeviceIoControl"} DeviceIoControl_unnamed_tag_9(x: int) : int
{
  x + 216
}

function {:inline true} {:fieldmap "Mem_T.DeviceIsOpened__MOXA_DEVICE_EXTENSION"} {:fieldname "DeviceIsOpened"} DeviceIsOpened__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 44
}

function {:inline true} {:fieldmap "Mem_T._UNICODE_STRING"} {:fieldname "DeviceName"} DeviceName__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1332
}

function {:inline true} {:fieldmap "Mem_T.DeviceObject__DEVOBJ_EXTENSION"} {:fieldname "DeviceObject"} DeviceObject__DEVOBJ_EXTENSION(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.DeviceObject__IO_STACK_LOCATION"} {:fieldname "DeviceObject"} DeviceObject__IO_STACK_LOCATION(x: int) : int
{
  x + 488
}

function {:inline true} {:fieldmap "Mem_T.DeviceObject__MOXA_DEVICE_EXTENSION"} {:fieldname "DeviceObject"} DeviceObject__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.INT4"} {:fieldname "DevicePNPAccept"} DevicePNPAccept__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1520
}

function {:inline true} {:fieldmap "Mem_T.DeviceStateMap__MOXA_DEVICE_EXTENSION"} {:fieldname "DeviceStateMap"} DeviceStateMap__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1792
}

function {:inline true} {:fieldmap "Mem_T.DeviceState__DEVICE_CAPABILITIES"} {:fieldname "DeviceState"} DeviceState__DEVICE_CAPABILITIES(x: int) : int
{
  x + 96
}

function {:inline true} {:fieldmap "Mem_T._MOXA_DEVICE_STATE"} {:fieldname "DeviceState"} DeviceState__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1784
}

function {:inline true} {:fieldmap "Mem_T.DeviceState__POWER_STATE"} {:fieldname "DeviceState"} DeviceState__POWER_STATE(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.DeviceWake__DEVICE_CAPABILITIES"} {:fieldname "DeviceWake"} DeviceWake__DEVICE_CAPABILITIES(x: int) : int
{
  x + 128
}

function {:inline true} {:fieldmap "Mem_T.DeviceWake__MOXA_DEVICE_EXTENSION"} {:fieldname "DeviceWake"} DeviceWake__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2240
}

function {:inline true} {:fieldmap "Mem_T.Directory__FILE_STANDARD_INFORMATION"} {:fieldname "Directory"} Directory__FILE_STANDARD_INFORMATION(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T._SERIAL_MULTIPORT_DISPATCH"} {:fieldname "Dispatch"} Dispatch__MOXA_CISR_SW(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.DpcCount__MOXA_DEVICE_EXTENSION"} {:fieldname "DpcCount"} DpcCount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2420
}

function {:inline true} {:fieldmap "Mem_T.Dpc__KTIMER"} {:fieldname "Dpc"} Dpc__KTIMER(x: int) : int
{
  x + 152
}

function {:inline true} {:fieldmap "Mem_T.DriverObject__DEVICE_OBJECT"} {:fieldname "DriverObject"} DriverObject__DEVICE_OBJECT(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.DriverObject__MOXA_GLOBAL_DATA"} {:fieldname "DriverObject"} DriverObject__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.DumpDataSize__IO_ERROR_LOG_PACKET"} {:fieldname "DumpDataSize"} DumpDataSize__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.DumpData__IO_ERROR_LOG_PACKET"} {:fieldname "DumpData"} DumpData__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.EndOfFile__FILE_STANDARD_INFORMATION"} {:fieldname "EndOfFile"} EndOfFile__FILE_STANDARD_INFORMATION(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.EofChar__SERIAL_CHARS"} {:fieldname "EofChar"} EofChar__SERIAL_CHARS(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.ErrorChar__SERIAL_CHARS"} {:fieldname "ErrorChar"} ErrorChar__SERIAL_CHARS(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.ErrorCode__IO_ERROR_LOG_PACKET"} {:fieldname "ErrorCode"} ErrorCode__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.ErrorWord__MOXA_DEVICE_EXTENSION"} {:fieldname "ErrorWord"} ErrorWord__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 184
}

function {:inline true} {:fieldmap "Mem_T.EscapeChar__MOXA_DEVICE_EXTENSION"} {:fieldname "EscapeChar"} EscapeChar__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 112
}

function {:inline true} {:fieldmap "Mem_T.EventChar__SERIAL_CHARS"} {:fieldname "EventChar"} EventChar__SERIAL_CHARS(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.ExecuteWmiMethod__WMILIB_CONTEXT"} {:fieldname "ExecuteWmiMethod"} ExecuteWmiMethod__WMILIB_CONTEXT(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.Extension__MOXA_GLOBAL_DATA"} {:fieldname "Extension"} Extension__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 432
}

function {:inline true} {:fieldmap "Mem_T.Extension__MOXA_IOCTL_SYNC"} {:fieldname "Extension"} Extension__MOXA_IOCTL_SYNC(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.FileInformationClass_unnamed_tag_14"} {:fieldname "FileInformationClass"} FileInformationClass_unnamed_tag_14(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.FinalStatus__IO_ERROR_LOG_PACKET"} {:fieldname "FinalStatus"} FinalStatus__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.INT4"} {:fieldname "Flags"} Flags__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1652
}

function {:inline true} {:fieldmap "Mem_T.Flink__LIST_ENTRY"} {:fieldname "Flink"} Flink__LIST_ENTRY(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.FlowControl__MOXA_IOCTL_PortStatus"} {:fieldname "FlowControl"} FlowControl__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.FlowCtl__MOXA_IOCTL_Statistic"} {:fieldname "FlowCtl"} FlowCtl__MOXA_IOCTL_Statistic(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.FlowReplace__SERIAL_HANDFLOW"} {:fieldname "FlowReplace"} FlowReplace__SERIAL_HANDFLOW(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.FrameErrorCount__SERIALPERF_STATS"} {:fieldname "FrameErrorCount"} FrameErrorCount__SERIALPERF_STATS(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.GlobalData__MOXA_DEVICE_EXTENSION"} {:fieldname "GlobalData"} GlobalData__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.GlobalData__SERIAL_MULTIPORT_DISPATCH"} {:fieldname "GlobalData"} GlobalData__SERIAL_MULTIPORT_DISPATCH(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.GuidCount__WMILIB_CONTEXT"} {:fieldname "GuidCount"} GuidCount__WMILIB_CONTEXT(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.GuidList__WMILIB_CONTEXT"} {:fieldname "GuidList"} GuidList__WMILIB_CONTEXT(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T._SERIAL_HANDFLOW"} {:fieldname "HandFlow"} HandFlow__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 116
}

function {:inline true} {:fieldmap "Mem_T.Header__KEVENT"} {:fieldname "Header"} Header__KEVENT(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.High1Time__KSYSTEM_TIME"} {:fieldname "High1Time"} High1Time__KSYSTEM_TIME(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.High2Time__KSYSTEM_TIME"} {:fieldname "High2Time"} High2Time__KSYSTEM_TIME(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.HighPart__LUID"} {:fieldname "HighPart"} HighPart__LUID(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.HistoryMask__MOXA_DEVICE_EXTENSION"} {:fieldname "HistoryMask"} HistoryMask__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 164
}

function {:inline true} {:fieldmap "Mem_T.HostState__MOXA_DEVICE_STATE"} {:fieldname "HostState"} HostState__MOXA_DEVICE_STATE(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Information__IO_STATUS_BLOCK"} {:fieldname "Information"} Information__IO_STATUS_BLOCK(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.InputBufferLength_unnamed_tag_21"} {:fieldname "InputBufferLength"} InputBufferLength_unnamed_tag_21(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.IntNdx__MOXA_GLOBAL_DATA"} {:fieldname "IntNdx"} IntNdx__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 384
}

function {:inline true} {:fieldmap "Mem_T.IntPend__MOXA_GLOBAL_DATA"} {:fieldname "IntPend"} IntPend__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 400
}

function {:inline true} {:fieldmap "Mem_T.IntTable__MOXA_GLOBAL_DATA"} {:fieldname "IntTable"} IntTable__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 416
}

function {:inline true} {:fieldmap "Mem_T.IntVector__MOXA_GLOBAL_DATA"} {:fieldname "IntVector"} IntVector__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 80
}

function {:inline true} {:fieldmap "Mem_T.InterfaceType__MOXA_GLOBAL_DATA"} {:fieldname "InterfaceType"} InterfaceType__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.InterruptShareList__MOXA_DEVICE_EXTENSION"} {:fieldname "InterruptShareList"} InterruptShareList__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 244
}

function {:inline true} {:fieldmap "Mem_T.InterruptShareList__MOXA_GLOBAL_DATA"} {:fieldname "InterruptShareList"} InterruptShareList__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.InterruptType__SERIAL_WMI_HW_DATA"} {:fieldname "InterruptType"} InterruptType__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.Interrupt__MOXA_DEVICE_EXTENSION"} {:fieldname "Interrupt"} Interrupt__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T.Interrupt__MOXA_GLOBAL_DATA"} {:fieldname "Interrupt"} Interrupt__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 272
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "IntervalReadTimeoutDpc"} IntervalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 900
}

function {:inline true} {:fieldmap "Mem_T.IntervalTimeToUse__MOXA_DEVICE_EXTENSION"} {:fieldname "IntervalTimeToUse"} IntervalTimeToUse__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1200
}

function {:inline true} {:fieldmap "Mem_T.IntervalTime__MOXA_DEVICE_EXTENSION"} {:fieldname "IntervalTime"} IntervalTime__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1180
}

function {:inline true} {:fieldmap "Mem_T.IoControlCode_unnamed_tag_21"} {:fieldname "IoControlCode"} IoControlCode_unnamed_tag_21(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.IoStatus__IRP"} {:fieldname "IoStatus"} IoStatus__IRP(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.IrpMaskLocation__MOXA_DEVICE_EXTENSION"} {:fieldname "IrpMaskLocation"} IrpMaskLocation__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 168
}

function {:inline true} {:fieldmap "Mem_T.IrqAffinityMask__SERIAL_WMI_HW_DATA"} {:fieldname "IrqAffinityMask"} IrqAffinityMask__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.IrqLevel__SERIAL_WMI_HW_DATA"} {:fieldname "IrqLevel"} IrqLevel__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.IrqNumber__SERIAL_WMI_HW_DATA"} {:fieldname "IrqNumber"} IrqNumber__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.IrqVector__SERIAL_WMI_HW_DATA"} {:fieldname "IrqVector"} IrqVector__SERIAL_WMI_HW_DATA(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Irql__MOXA_GLOBAL_DATA"} {:fieldname "Irql"} Irql__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 288
}

function {:inline true} {:fieldmap "Mem_T.IsBusy__SERIAL_WMI_COMM_DATA"} {:fieldname "IsBusy"} IsBusy__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 96
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "IsrInDpc"} IsrInDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1060
}

function {:inline true} {:fieldmap "Mem_T.IsrInFlag__MOXA_DEVICE_EXTENSION"} {:fieldname "IsrInFlag"} IsrInFlag__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1284
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "IsrOutDpc"} IsrOutDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1100
}

function {:inline true} {:fieldmap "Mem_T.IsrOutFlag__MOXA_DEVICE_EXTENSION"} {:fieldname "IsrOutFlag"} IsrOutFlag__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1288
}

function {:inline true} {:fieldmap "Mem_T.IsrWaitMask__MOXA_DEVICE_EXTENSION"} {:fieldname "IsrWaitMask"} IsrWaitMask__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 160
}

function {:inline true} {:fieldmap "Mem_T.LStatus__MOXA_IOCTL_Statistic"} {:fieldname "LStatus"} LStatus__MOXA_IOCTL_Statistic(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.LastReadTime__MOXA_DEVICE_EXTENSION"} {:fieldname "LastReadTime"} LastReadTime__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1264
}

function {:inline true} {:fieldmap "Mem_T.Length_unnamed_tag_17"} {:fieldname "Length"} Length_unnamed_tag_17(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "ListEntry"} ListEntry_unnamed_tag_7(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T._LARGE_INTEGER"} {:fieldname "LongIntervalAmount"} LongIntervalAmount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1224
}

function {:inline true} {:fieldmap "Mem_T.LowPart__KSYSTEM_TIME"} {:fieldname "LowPart"} LowPart__KSYSTEM_TIME(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.LowPart__LUID"} {:fieldname "LowPart"} LowPart__LUID(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.LowerDeviceObject__MOXA_DEVICE_EXTENSION"} {:fieldname "LowerDeviceObject"} LowerDeviceObject__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.MajorFunctionCode__IO_ERROR_LOG_PACKET"} {:fieldname "MajorFunctionCode"} MajorFunctionCode__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.MajorFunction__DRIVER_OBJECT"} {:fieldname "MajorFunction"} MajorFunction__DRIVER_OBJECT(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.MajorFunction__IO_STACK_LOCATION"} {:fieldname "MajorFunction"} MajorFunction__IO_STACK_LOCATION(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "MaskQueue"} MaskQueue__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 264
}

function {:inline true} {:fieldmap "Mem_T.MaxBaudRate__MOXA_IOCTL_PortStatus"} {:fieldname "MaxBaudRate"} MaxBaudRate__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.MaxBaud__MOXA_DEVICE_EXTENSION"} {:fieldname "MaxBaud"} MaxBaud__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 232
}

function {:inline true} {:fieldmap "Mem_T.MaxBaud__SERIAL_COMMPROP"} {:fieldname "MaxBaud"} MaxBaud__SERIAL_COMMPROP(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.MaxRxQueue__SERIAL_COMMPROP"} {:fieldname "MaxRxQueue"} MaxRxQueue__SERIAL_COMMPROP(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.MaxTxQueue__SERIAL_COMMPROP"} {:fieldname "MaxTxQueue"} MaxTxQueue__SERIAL_COMMPROP(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.MaximumBaudRate__SERIAL_WMI_COMM_DATA"} {:fieldname "MaximumBaudRate"} MaximumBaudRate__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.MaximumInputBufferSize__SERIAL_WMI_COMM_DATA"} {:fieldname "MaximumInputBufferSize"} MaximumInputBufferSize__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 44
}

function {:inline true} {:fieldmap "Mem_T.MaximumLength__UNICODE_STRING"} {:fieldname "MaximumLength"} MaximumLength__UNICODE_STRING(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.MaximumOutputBufferSize__SERIAL_WMI_COMM_DATA"} {:fieldname "MaximumOutputBufferSize"} MaximumOutputBufferSize__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T.MinorFunction__IO_STACK_LOCATION"} {:fieldname "MinorFunction"} MinorFunction__IO_STACK_LOCATION(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.INT4"} {:fieldname "ModemStatus"} ModemStatus__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 156
}

function {:inline true} {:fieldmap "Mem_T.NextDevice__DEVICE_OBJECT"} {:fieldname "NextDevice"} NextDevice__DEVICE_OBJECT(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.NumPorts__MOXA_GLOBAL_DATA"} {:fieldname "NumPorts"} NumPorts__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 336
}

function {:inline true} {:fieldmap "Mem_T.NumberNeededForRead__MOXA_DEVICE_EXTENSION"} {:fieldname "NumberNeededForRead"} NumberNeededForRead__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 212
}

function {:inline true} {:fieldmap "Mem_T.NumberOfLinks__FILE_STANDARD_INFORMATION"} {:fieldname "NumberOfLinks"} NumberOfLinks__FILE_STANDARD_INFORMATION(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T.NumberOfStrings__IO_ERROR_LOG_PACKET"} {:fieldname "NumberOfStrings"} NumberOfStrings__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T._UNICODE_STRING"} {:fieldname "ObjectDirectory"} ObjectDirectory__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1344
}

function {:inline true} {:fieldmap "Mem_T.OpenCount__MOXA_DEVICE_EXTENSION"} {:fieldname "OpenCount"} OpenCount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1656
}

function {:inline true} {:fieldmap "Mem_T.Open__MOXA_IOCTL_PortStatus"} {:fieldname "Open"} Open__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.Options_unnamed_tag_10"} {:fieldname "Options"} Options_unnamed_tag_10(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Others_unnamed_tag_9"} {:fieldname "Others"} Others_unnamed_tag_9(x: int) : int
{
  x + 456
}

function {:inline true} {:fieldmap "Mem_T.OutputBufferLength_unnamed_tag_21"} {:fieldname "OutputBufferLength"} OutputBufferLength_unnamed_tag_21(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.Overlay_unnamed_tag_6"} {:fieldname "Overlay"} Overlay_unnamed_tag_6(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.OwnsPowerPolicy__MOXA_DEVICE_EXTENSION"} {:fieldname "OwnsPowerPolicy"} OwnsPowerPolicy__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2232
}

function {:inline true} {:fieldmap "Mem_T.PNPState__MOXA_DEVICE_EXTENSION"} {:fieldname "PNPState"} PNPState__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1648
}

function {:inline true} {:fieldmap "Mem_T.PacketLength__SERIAL_COMMPROP"} {:fieldname "PacketLength"} PacketLength__SERIAL_COMMPROP(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.PacketVersion__SERIAL_COMMPROP"} {:fieldname "PacketVersion"} PacketVersion__SERIAL_COMMPROP(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Parameters__IO_STACK_LOCATION"} {:fieldname "Parameters"} Parameters__IO_STACK_LOCATION(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.ParityCheckEnable__SERIAL_WMI_COMM_DATA"} {:fieldname "ParityCheckEnable"} ParityCheckEnable__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.ParityErrorCount__SERIALPERF_STATS"} {:fieldname "ParityErrorCount"} ParityErrorCount__SERIALPERF_STATS(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.Parity__SERIAL_LINE_CONTROL"} {:fieldname "Parity"} Parity__SERIAL_LINE_CONTROL(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Parity__SERIAL_WMI_COMM_DATA"} {:fieldname "Parity"} Parity__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.PciBusNum__MOXA_GLOBAL_DATA"} {:fieldname "PciBusNum"} PciBusNum__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.PciIntAckBase__MOXA_GLOBAL_DATA"} {:fieldname "PciIntAckBase"} PciIntAckBase__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 176
}

function {:inline true} {:fieldmap "Mem_T.PciIntAckPort__MOXA_GLOBAL_DATA"} {:fieldname "PciIntAckPort"} PciIntAckPort__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 96
}

function {:inline true} {:fieldmap "Mem_T.Pdo__MOXA_DEVICE_EXTENSION"} {:fieldname "Pdo"} Pdo__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.VOID"} {:fieldname "PendingDpcEvent"} PendingDpcEvent__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2424
}

function {:inline true} {:fieldmap "Mem_T.PendingIRPCnt__MOXA_DEVICE_EXTENSION"} {:fieldname "PendingIRPCnt"} PendingIRPCnt__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1516
}

function {:inline true} {:fieldmap "Mem_T.VOID"} {:fieldname "PendingIRPEvent"} PendingIRPEvent__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1524
}

function {:inline true} {:fieldmap "Mem_T.PendingReturned__IRP"} {:fieldname "PendingReturned"} PendingReturned__IRP(x: int) : int
{
  x + 52
}

function {:inline true} {:fieldmap "Mem_T.PendingWakeIrp__MOXA_DEVICE_EXTENSION"} {:fieldname "PendingWakeIrp"} PendingWakeIrp__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2248
}

function {:inline true} {:fieldmap "Mem_T.PerfStats__MOXA_DEVICE_EXTENSION"} {:fieldname "PerfStats"} PerfStats__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 132
}

function {:inline true} {:fieldmap "Mem_T.PortBase__MOXA_DEVICE_EXTENSION"} {:fieldname "PortBase"} PortBase__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.PortExist__MOXA_DEVICE_EXTENSION"} {:fieldname "PortExist"} PortExist__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.PortFlag__MOXA_DEVICE_EXTENSION"} {:fieldname "PortFlag"} PortFlag__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1300
}

function {:inline true} {:fieldmap "Mem_T.PortIndex__MOXA_DEVICE_EXTENSION"} {:fieldname "PortIndex"} PortIndex__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.PortNo__MOXA_DEVICE_EXTENSION"} {:fieldname "PortNo"} PortNo__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T.PortOfs__MOXA_DEVICE_EXTENSION"} {:fieldname "PortOfs"} PortOfs__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.VOID"} {:fieldname "PowerD0Event"} PowerD0Event__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1820
}

function {:inline true} {:fieldmap "Mem_T.PowerState__MOXA_DEVICE_EXTENSION"} {:fieldname "PowerState"} PowerState__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1320
}

function {:inline true} {:fieldmap "Mem_T.Power_unnamed_tag_9"} {:fieldname "Power"} Power_unnamed_tag_9(x: int) : int
{
  x + 380
}

function {:inline true} {:fieldmap "Mem_T.ProcessorAffinity__MOXA_GLOBAL_DATA"} {:fieldname "ProcessorAffinity"} ProcessorAffinity__MOXA_GLOBAL_DATA(x: int) : int
{
  x + 304
}

function {:inline true} {:fieldmap "Mem_T.ProvCapabilities__SERIAL_COMMPROP"} {:fieldname "ProvCapabilities"} ProvCapabilities__SERIAL_COMMPROP(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.ProvSubType__SERIAL_COMMPROP"} {:fieldname "ProvSubType"} ProvSubType__SERIAL_COMMPROP(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "PurgeQueue"} PurgeQueue__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 272
}

function {:inline true} {:fieldmap "Mem_T.QuadPart__LARGE_INTEGER"} {:fieldname "QuadPart"} QuadPart__LARGE_INTEGER(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.QueryDeviceRelations_unnamed_tag_9"} {:fieldname "QueryDeviceRelations"} QueryDeviceRelations_unnamed_tag_9(x: int) : int
{
  x + 288
}

function {:inline true} {:fieldmap "Mem_T.QueryFile_unnamed_tag_9"} {:fieldname "QueryFile"} QueryFile_unnamed_tag_9(x: int) : int
{
  x + 100
}

function {:inline true} {:fieldmap "Mem_T.QueryWmiDataBlock__WMILIB_CONTEXT"} {:fieldname "QueryWmiDataBlock"} QueryWmiDataBlock__WMILIB_CONTEXT(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.QueryWmiRegInfo__WMILIB_CONTEXT"} {:fieldname "QueryWmiRegInfo"} QueryWmiRegInfo__WMILIB_CONTEXT(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.ReadByIsr__MOXA_DEVICE_EXTENSION"} {:fieldname "ReadByIsr"} ReadByIsr__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 220
}

function {:inline true} {:fieldmap "Mem_T.ReadCurrentChar__MOXA_DEVICE_EXTENSION"} {:fieldname "ReadCurrentChar"} ReadCurrentChar__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 208
}

function {:inline true} {:fieldmap "Mem_T.ReadIntervalTimeout__SERIAL_TIMEOUTS"} {:fieldname "ReadIntervalTimeout"} ReadIntervalTimeout__SERIAL_TIMEOUTS(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.ReadLength__MOXA_DEVICE_EXTENSION"} {:fieldname "ReadLength"} ReadLength__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 204
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "ReadQueue"} ReadQueue__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 248
}

function {:inline true} {:fieldmap "Mem_T._KTIMER"} {:fieldname "ReadRequestIntervalTimer"} ReadRequestIntervalTimer__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 460
}

function {:inline true} {:fieldmap "Mem_T._KTIMER"} {:fieldname "ReadRequestTotalTimer"} ReadRequestTotalTimer__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 300
}

function {:inline true} {:fieldmap "Mem_T.ReadTotalTimeoutConstant__SERIAL_TIMEOUTS"} {:fieldname "ReadTotalTimeoutConstant"} ReadTotalTimeoutConstant__SERIAL_TIMEOUTS(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.ReadTotalTimeoutMultiplier__SERIAL_TIMEOUTS"} {:fieldname "ReadTotalTimeoutMultiplier"} ReadTotalTimeoutMultiplier__SERIAL_TIMEOUTS(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.Read_unnamed_tag_9"} {:fieldname "Read"} Read_unnamed_tag_9(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.ReceivedCount__SERIALPERF_STATS"} {:fieldname "ReceivedCount"} ReceivedCount__SERIALPERF_STATS(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.Reopen__MOXA_DEVICE_STATE"} {:fieldname "Reopen"} Reopen__MOXA_DEVICE_STATE(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.RetryCount__IO_ERROR_LOG_PACKET"} {:fieldname "RetryCount"} RetryCount__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.RxBufferSize__MOXA_DEVICE_EXTENSION"} {:fieldname "RxBufferSize"} RxBufferSize__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 172
}

function {:inline true} {:fieldmap "Mem_T.RxBuffer__MOXA_IOCTL_PortStatus"} {:fieldname "RxBuffer"} RxBuffer__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.RxCount__MOXA_IOCTL_Statistic"} {:fieldname "RxCount"} RxCount__MOXA_IOCTL_Statistic(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.RxFifoTrigger__MOXA_DEVICE_EXTENSION"} {:fieldname "RxFifoTrigger"} RxFifoTrigger__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1308
}

function {:inline true} {:fieldmap "Mem_T.SendBreak__MOXA_DEVICE_EXTENSION"} {:fieldname "SendBreak"} SendBreak__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 236
}

function {:inline true} {:fieldmap "Mem_T.SendWaitWake__MOXA_DEVICE_EXTENSION"} {:fieldname "SendWaitWake"} SendWaitWake__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2244
}

function {:inline true} {:fieldmap "Mem_T.SequenceNumber__IO_ERROR_LOG_PACKET"} {:fieldname "SequenceNumber"} SequenceNumber__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.INT4"} {:fieldname "SerialCount"} SerialCount__CONFIGURATION_INFORMATION(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.SerialOverrunErrorCount__SERIALPERF_STATS"} {:fieldname "SerialOverrunErrorCount"} SerialOverrunErrorCount__SERIALPERF_STATS(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.ServiceMask__SERIAL_COMMPROP"} {:fieldname "ServiceMask"} ServiceMask__SERIAL_COMMPROP(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.SetFile_unnamed_tag_9"} {:fieldname "SetFile"} SetFile_unnamed_tag_9(x: int) : int
{
  x + 108
}

function {:inline true} {:fieldmap "Mem_T.SetWmiDataBlock__WMILIB_CONTEXT"} {:fieldname "SetWmiDataBlock"} SetWmiDataBlock__WMILIB_CONTEXT(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.SetWmiDataItem__WMILIB_CONTEXT"} {:fieldname "SetWmiDataItem"} SetWmiDataItem__WMILIB_CONTEXT(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.SettableBaudRate__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableBaudRate"} SettableBaudRate__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 72
}

function {:inline true} {:fieldmap "Mem_T.SettableBaud__SERIAL_COMMPROP"} {:fieldname "SettableBaud"} SettableBaud__SERIAL_COMMPROP(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T.SettableDataBits__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableDataBits"} SettableDataBits__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 76
}

function {:inline true} {:fieldmap "Mem_T.SettableData__SERIAL_COMMPROP"} {:fieldname "SettableData"} SettableData__SERIAL_COMMPROP(x: int) : int
{
  x + 44
}

function {:inline true} {:fieldmap "Mem_T.SettableFlowControl__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableFlowControl"} SettableFlowControl__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 80
}

function {:inline true} {:fieldmap "Mem_T.SettableParams__SERIAL_COMMPROP"} {:fieldname "SettableParams"} SettableParams__SERIAL_COMMPROP(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.SettableParityCheck__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableParityCheck"} SettableParityCheck__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 88
}

function {:inline true} {:fieldmap "Mem_T.SettableParity__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableParity"} SettableParity__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 84
}

function {:inline true} {:fieldmap "Mem_T.SettableStopBits__SERIAL_WMI_COMM_DATA"} {:fieldname "SettableStopBits"} SettableStopBits__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 92
}

function {:inline true} {:fieldmap "Mem_T.SettableStopParity__SERIAL_COMMPROP"} {:fieldname "SettableStopParity"} SettableStopParity__SERIAL_COMMPROP(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "SharerList"} SharerList__MOXA_CISR_SW(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T._LARGE_INTEGER"} {:fieldname "ShortIntervalAmount"} ShortIntervalAmount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1204
}

function {:inline true} {:fieldmap "Mem_T.SignalState__DISPATCHER_HEADER"} {:fieldname "SignalState"} SignalState__DISPATCHER_HEADER(x: int) : int
{
  x + 112
}

function {:inline true} {:fieldmap "Mem_T.Signalling__DISPATCHER_HEADER"} {:fieldname "Signalling"} Signalling__DISPATCHER_HEADER(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.Size__DISPATCHER_HEADER"} {:fieldname "Size"} Size__DISPATCHER_HEADER(x: int) : int
{
  x + 56
}

function {:inline true} {:fieldmap "Mem_T._SERIAL_CHARS"} {:fieldname "SpecialChars"} SpecialChars__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 88
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "StalledIrpQueue"} StalledIrpQueue__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1944
}

function {:inline true} {:fieldmap "Mem_T.State_unnamed_tag_38"} {:fieldname "State"} State_unnamed_tag_38(x: int) : int
{
  x + 40
}

function {:inline true} {:fieldmap "Mem_T.Status__IO_STATUS_BLOCK"} {:fieldname "Status"} Status__IO_STATUS_BLOCK(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.StopBits__SERIAL_LINE_CONTROL"} {:fieldname "StopBits"} StopBits__SERIAL_LINE_CONTROL(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.StopBits__SERIAL_WMI_COMM_DATA"} {:fieldname "StopBits"} StopBits__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.StringOffset__IO_ERROR_LOG_PACKET"} {:fieldname "StringOffset"} StringOffset__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.Support16BitMode__SERIAL_WMI_COMM_DATA"} {:fieldname "Support16BitMode"} Support16BitMode__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T.SupportDTRDSR__SERIAL_WMI_COMM_DATA"} {:fieldname "SupportDTRDSR"} SupportDTRDSR__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 52
}

function {:inline true} {:fieldmap "Mem_T.SupportIntervalTimeouts__SERIAL_WMI_COMM_DATA"} {:fieldname "SupportIntervalTimeouts"} SupportIntervalTimeouts__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 56
}

function {:inline true} {:fieldmap "Mem_T.SupportParityCheck__SERIAL_WMI_COMM_DATA"} {:fieldname "SupportParityCheck"} SupportParityCheck__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 60
}

function {:inline true} {:fieldmap "Mem_T.SupportRTSCTS__SERIAL_WMI_COMM_DATA"} {:fieldname "SupportRTSCTS"} SupportRTSCTS__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.SupportXonXoff__SERIAL_WMI_COMM_DATA"} {:fieldname "SupportXonXoff"} SupportXonXoff__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 68
}

function {:inline true} {:fieldmap "Mem_T.SupportedBauds__MOXA_DEVICE_EXTENSION"} {:fieldname "SupportedBauds"} SupportedBauds__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 228
}

function {:inline true} {:fieldmap "Mem_T._UNICODE_STRING"} {:fieldname "SymbolicLinkName"} SymbolicLinkName__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1364
}

function {:inline true} {:fieldmap "Mem_T.SystemBuffer_unnamed_tag_3"} {:fieldname "SystemBuffer"} SystemBuffer_unnamed_tag_3(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.SystemState__POWER_STATE"} {:fieldname "SystemState"} SystemState__POWER_STATE(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.SystemWake__DEVICE_CAPABILITIES"} {:fieldname "SystemWake"} SystemWake__DEVICE_CAPABILITIES(x: int) : int
{
  x + 124
}

function {:inline true} {:fieldmap "Mem_T.SystemWake__MOXA_DEVICE_EXTENSION"} {:fieldname "SystemWake"} SystemWake__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2236
}

function {:inline true} {:fieldmap "Mem_T.TXHolding__MOXA_DEVICE_EXTENSION"} {:fieldname "TXHolding"} TXHolding__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 188
}

function {:inline true} {:fieldmap "Mem_T.Tail__IRP"} {:fieldname "Tail"} Tail__IRP(x: int) : int
{
  x + 128
}

function {:inline true} {:fieldmap "Mem_T.Timeouts__MOXA_DEVICE_EXTENSION"} {:fieldname "Timeouts"} Timeouts__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 68
}

function {:inline true} {:fieldmap "Mem_T.TotalCharsQueued__MOXA_DEVICE_EXTENSION"} {:fieldname "TotalCharsQueued"} TotalCharsQueued__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 224
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "TotalReadTimeoutDpc"} TotalReadTimeoutDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 860
}

function {:inline true} {:fieldmap "Mem_T._KDPC"} {:fieldname "TotalWriteTimeoutDpc"} TotalWriteTimeoutDpc__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 940
}

function {:inline true} {:fieldmap "Mem_T.TransmittedCount__SERIALPERF_STATS"} {:fieldname "TransmittedCount"} TransmittedCount__SERIALPERF_STATS(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.TxBufferSize__MOXA_DEVICE_EXTENSION"} {:fieldname "TxBufferSize"} TxBufferSize__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 176
}

function {:inline true} {:fieldmap "Mem_T.TxBuffer__MOXA_IOCTL_PortStatus"} {:fieldname "TxBuffer"} TxBuffer__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.TxCount__MOXA_IOCTL_Statistic"} {:fieldname "TxCount"} TxCount__MOXA_IOCTL_Statistic(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.TxFifoAmount__MOXA_DEVICE_EXTENSION"} {:fieldname "TxFifoAmount"} TxFifoAmount__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 1312
}

function {:inline true} {:fieldmap "Mem_T.TxHold__MOXA_IOCTL_PortStatus"} {:fieldname "TxHold"} TxHold__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.TxXoffThreshold__MOXA_IOCTL_PortStatus"} {:fieldname "TxXoffThreshold"} TxXoffThreshold__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.TxXonThreshold__MOXA_IOCTL_PortStatus"} {:fieldname "TxXonThreshold"} TxXonThreshold__MOXA_IOCTL_PortStatus(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.Type_unnamed_tag_27"} {:fieldname "Type"} Type_unnamed_tag_27(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.Type_unnamed_tag_38"} {:fieldname "Type"} Type_unnamed_tag_38(x: int) : int
{
  x + 36
}

function {:inline true} {:fieldmap "Mem_T.UniqueErrorValue__IO_ERROR_LOG_PACKET"} {:fieldname "UniqueErrorValue"} UniqueErrorValue__IO_ERROR_LOG_PACKET(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.ValidDataMask__MOXA_DEVICE_EXTENSION"} {:fieldname "ValidDataMask"} ValidDataMask__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 64
}

function {:inline true} {:fieldmap "Mem_T.WmiCommData__MOXA_DEVICE_EXTENSION"} {:fieldname "WmiCommData"} WmiCommData__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2296
}

function {:inline true} {:fieldmap "Mem_T.WmiFunctionControl__WMILIB_CONTEXT"} {:fieldname "WmiFunctionControl"} WmiFunctionControl__WMILIB_CONTEXT(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.WmiHwData__MOXA_DEVICE_EXTENSION"} {:fieldname "WmiHwData"} WmiHwData__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2396
}

function {:inline true} {:fieldmap "Mem_T._UNICODE_STRING"} {:fieldname "WmiIdentifier"} WmiIdentifier__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2284
}

function {:inline true} {:fieldmap "Mem_T.WmiLibInfo__MOXA_DEVICE_EXTENSION"} {:fieldname "WmiLibInfo"} WmiLibInfo__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 2252
}

function {:inline true} {:fieldmap "Mem_T.WordLength__SERIAL_LINE_CONTROL"} {:fieldname "WordLength"} WordLength__SERIAL_LINE_CONTROL(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.WriteLength__MOXA_DEVICE_EXTENSION"} {:fieldname "WriteLength"} WriteLength__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 192
}

function {:inline true} {:fieldmap "Mem_T._LIST_ENTRY"} {:fieldname "WriteQueue"} WriteQueue__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 256
}

function {:inline true} {:fieldmap "Mem_T._KTIMER"} {:fieldname "WriteRequestTotalTimer"} WriteRequestTotalTimer__MOXA_DEVICE_EXTENSION(x: int) : int
{
  x + 620
}

function {:inline true} {:fieldmap "Mem_T.WriteTotalTimeoutConstant__SERIAL_TIMEOUTS"} {:fieldname "WriteTotalTimeoutConstant"} WriteTotalTimeoutConstant__SERIAL_TIMEOUTS(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.WriteTotalTimeoutMultiplier__SERIAL_TIMEOUTS"} {:fieldname "WriteTotalTimeoutMultiplier"} WriteTotalTimeoutMultiplier__SERIAL_TIMEOUTS(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.Write_unnamed_tag_9"} {:fieldname "Write"} Write_unnamed_tag_9(x: int) : int
{
  x + 48
}

function {:inline true} {:fieldmap "Mem_T.XoffChar__SERIAL_CHARS"} {:fieldname "XoffChar"} XoffChar__SERIAL_CHARS(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.XoffCharacter__SERIAL_WMI_COMM_DATA"} {:fieldname "XoffCharacter"} XoffCharacter__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.XoffLimit__SERIAL_HANDFLOW"} {:fieldname "XoffLimit"} XoffLimit__SERIAL_HANDFLOW(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.XoffXmitThreshold__SERIAL_WMI_COMM_DATA"} {:fieldname "XoffXmitThreshold"} XoffXmitThreshold__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 24
}

function {:inline true} {:fieldmap "Mem_T.XonChar__SERIAL_CHARS"} {:fieldname "XonChar"} XonChar__SERIAL_CHARS(x: int) : int
{
  x + 16
}

function {:inline true} {:fieldmap "Mem_T.XonCharacter__SERIAL_WMI_COMM_DATA"} {:fieldname "XonCharacter"} XonCharacter__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 28
}

function {:inline true} {:fieldmap "Mem_T.XonLimit__SERIAL_HANDFLOW"} {:fieldname "XonLimit"} XonLimit__SERIAL_HANDFLOW(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.XonXmitThreshold__SERIAL_WMI_COMM_DATA"} {:fieldname "XonXmitThreshold"} XonXmitThreshold__SERIAL_WMI_COMM_DATA(x: int) : int
{
  x + 32
}

function {:inline true} {:fieldmap "Mem_T.data_len_blkhead"} {:fieldname "data_len"} data_len_blkhead(x: int) : int
{
  x + 8
}

function {:inline true} {:fieldmap "Mem_T.data_ofs_blkhead"} {:fieldname "data_ofs"} data_ofs_blkhead(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.data_seg_blkhead"} {:fieldname "data_seg"} data_seg_blkhead(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.data_wrdata"} {:fieldname "data"} data_wrdata(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.datahead_fidata"} {:fieldname "datahead"} datahead_fidata(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.datahead_wrdata"} {:fieldname "datahead"} datahead_wrdata(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.extension__ObjLink"} {:fieldname "extension"} extension__ObjLink(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.fill_value_fidata"} {:fieldname "fill_value"} fill_value_fidata(x: int) : int
{
  x + 12
}

function {:inline true} {:fieldmap "Mem_T.sNext__ObjLink"} {:fieldname "sNext"} sNext__ObjLink(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.segment_mxset"} {:fieldname "segment"} segment_mxset(x: int) : int
{
  x + 20
}

function {:inline true} {:fieldmap "Mem_T.total_boards_mxset"} {:fieldname "total_boards"} total_boards_mxset(x: int) : int
{
  x + 0
}

function {:inline true} {:fieldmap "Mem_T.type_mxset"} {:fieldname "type"} type_mxset(x: int) : int
{
  x + 4
}

function {:inline true} {:fieldmap "Mem_T.u__LARGE_INTEGER"} {:fieldname "u"} u__LARGE_INTEGER(x: int) : int
{
  x + 8
}

const {:string ""} unique strConst__li2bpl18: int;

const {:string "DisableFiFo"} unique strConst__li2bpl19: int;

const {:string "DosDevices"} unique strConst__li2bpl23: int;

const {:string "KeCancelTimer should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl10: int;

const {:string "KeClearEvent should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl4: int;

const {:string "KeInitializeDeviceQueue should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl13: int;

const {:string "KeInitializeSemaphore should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl5: int;

const {:string "KeInitializeTimer should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl9: int;

const {:string "KeInitializeTimerEx should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl0: int;

const {:string "KePulseEvent should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl7: int;

const {:string "KeRaiseIrqlToDpcLevel should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl17: int;

const {:string "KeReadStateEvent should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl6: int;

const {:string "KeReadStateTimer should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl8: int;

const {:string "KeReleaseMutex should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl3: int;

const {:string "KeRemoveEntryDeviceQueue should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl16: int;

const {:string "KeResetEvent should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl15: int;

const {:string "KeSaveFloatingPointState should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl1: int;

const {:string "KeSetTimer should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl12: int;

const {:string "KeSetTimerEx should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl11: int;

const {:string "KfAcquireSpinLock should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl2: int;

const {:string "SERIALCOMM"} unique strConst__li2bpl21: int;

const {:string "TxMode"} unique strConst__li2bpl20: int;

const {:string "\\"} unique strConst__li2bpl22: int;

const {:string "\\DosDevices\\MXCTL"} unique strConst__li2bpl24: int;

const {:string "callee"} unique strConst__li2bpl25: int;

const {:string "sdv_KeAcquireSpinLock should only be called at IRQL <= DISPATCH_LEVEL."} unique strConst__li2bpl14: int;

const {:allocated} li2bplFunctionConstant140: int;

axiom li2bplFunctionConstant140 == 140;

const {:allocated} li2bplFunctionConstant141: int;

axiom li2bplFunctionConstant141 == 141;

const {:allocated} li2bplFunctionConstant142: int;

axiom li2bplFunctionConstant142 == 142;

const {:allocated} li2bplFunctionConstant143: int;

axiom li2bplFunctionConstant143 == 143;

const {:allocated} li2bplFunctionConstant145: int;

axiom li2bplFunctionConstant145 == 145;

const {:allocated} li2bplFunctionConstant147: int;

axiom li2bplFunctionConstant147 == 147;

const {:allocated} li2bplFunctionConstant148: int;

axiom li2bplFunctionConstant148 == 148;

const {:allocated} li2bplFunctionConstant149: int;

axiom li2bplFunctionConstant149 == 149;

const {:allocated} li2bplFunctionConstant150: int;

axiom li2bplFunctionConstant150 == 150;

const {:allocated} li2bplFunctionConstant151: int;

axiom li2bplFunctionConstant151 == 151;

const {:allocated} li2bplFunctionConstant152: int;

axiom li2bplFunctionConstant152 == 152;

const {:allocated} li2bplFunctionConstant164: int;

axiom li2bplFunctionConstant164 == 164;

const {:allocated} li2bplFunctionConstant188: int;

axiom li2bplFunctionConstant188 == 188;

const {:allocated} li2bplFunctionConstant196: int;

axiom li2bplFunctionConstant196 == 196;

const {:allocated} li2bplFunctionConstant202: int;

axiom li2bplFunctionConstant202 == 202;

const {:allocated} li2bplFunctionConstant232: int;

axiom li2bplFunctionConstant232 == 232;

const {:allocated} li2bplFunctionConstant235: int;

axiom li2bplFunctionConstant235 == 235;

const {:allocated} li2bplFunctionConstant236: int;

axiom li2bplFunctionConstant236 == 236;

const {:allocated} li2bplFunctionConstant237: int;

axiom li2bplFunctionConstant237 == 237;

const {:allocated} li2bplFunctionConstant238: int;

axiom li2bplFunctionConstant238 == 238;

const {:allocated} li2bplFunctionConstant239: int;

axiom li2bplFunctionConstant239 == 239;

const {:allocated} li2bplFunctionConstant253: int;

axiom li2bplFunctionConstant253 == 253;

const {:allocated} li2bplFunctionConstant302: int;

axiom li2bplFunctionConstant302 == 302;

const {:allocated} li2bplFunctionConstant306: int;

axiom li2bplFunctionConstant306 == 306;

const {:allocated} li2bplFunctionConstant318: int;

axiom li2bplFunctionConstant318 == 318;

const {:allocated} li2bplFunctionConstant319: int;

axiom li2bplFunctionConstant319 == 319;

const {:allocated} li2bplFunctionConstant320: int;

axiom li2bplFunctionConstant320 == 320;

const {:allocated} li2bplFunctionConstant321: int;

axiom li2bplFunctionConstant321 == 321;

const {:allocated} li2bplFunctionConstant323: int;

axiom li2bplFunctionConstant323 == 323;

const {:allocated} li2bplFunctionConstant324: int;

axiom li2bplFunctionConstant324 == 324;

const {:allocated} li2bplFunctionConstant325: int;

axiom li2bplFunctionConstant325 == 325;

const {:allocated} li2bplFunctionConstant326: int;

axiom li2bplFunctionConstant326 == 326;

const {:allocated} li2bplFunctionConstant338: int;

axiom li2bplFunctionConstant338 == 338;

const {:allocated} li2bplFunctionConstant339: int;

axiom li2bplFunctionConstant339 == 339;

const {:allocated} li2bplFunctionConstant340: int;

axiom li2bplFunctionConstant340 == 340;

const {:allocated} li2bplFunctionConstant354: int;

axiom li2bplFunctionConstant354 == 354;

const {:allocated} li2bplFunctionConstant367: int;

axiom li2bplFunctionConstant367 == 367;

const {:allocated} li2bplFunctionConstant368: int;

axiom li2bplFunctionConstant368 == 368;

const {:allocated} li2bplFunctionConstant369: int;

axiom li2bplFunctionConstant369 == 369;

const {:allocated} li2bplFunctionConstant370: int;

axiom li2bplFunctionConstant370 == 370;

const {:allocated} li2bplFunctionConstant373: int;

axiom li2bplFunctionConstant373 == 373;

const {:allocated} li2bplFunctionConstant406: int;

axiom li2bplFunctionConstant406 == 406;

const {:allocated} li2bplFunctionConstant417: int;

axiom li2bplFunctionConstant417 == 417;

const {:allocated} li2bplFunctionConstant418: int;

axiom li2bplFunctionConstant418 == 418;

const {:allocated} li2bplFunctionConstant419: int;

axiom li2bplFunctionConstant419 == 419;

const {:allocated} li2bplFunctionConstant420: int;

axiom li2bplFunctionConstant420 == 420;

const {:allocated} li2bplFunctionConstant470: int;

axiom li2bplFunctionConstant470 == 470;

const {:allocated} li2bplFunctionConstant472: int;

axiom li2bplFunctionConstant472 == 472;

const {:allocated} li2bplFunctionConstant475: int;

axiom li2bplFunctionConstant475 == 475;

implementation {:origName "sdv_RunKeDpcRoutines"} {:osmodel} sdv_RunKeDpcRoutines#0(actual_kdpc: int, actual_pDpcContext: int, actual_pv2: int, actual_pv3: int)
{
  var {:pointer} kdpc: int;
  var {:pointer} pDpcContext: int;
  var vslice_dummy_var_253: int;

  anon0:
    call {:si_unique_call 1595} vslice_dummy_var_253 := __HAVOC_malloc(4);
    kdpc := actual_kdpc;
    pDpcContext := actual_pDpcContext;
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon51_Then, anon51_Else;

  anon51_Else:
    goto anon53_Then, anon53_Else;

  anon53_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1596} MoxaCommError(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon69_Then, anon69_Else;

  anon69_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L4;

  L4:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon52_Then, anon52_Else;

  anon52_Else:
    goto anon55_Then, anon55_Else;

  anon55_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1597} MoxaCompleteRead(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L20;

  L20:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon54_Then, anon54_Else;

  anon54_Else:
    goto anon57_Then, anon57_Else;

  anon57_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1598} MoxaCompleteWait(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon71_Then, anon71_Else;

  anon71_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L36;

  L36:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon56_Then, anon56_Else;

  anon56_Else:
    goto anon59_Then, anon59_Else;

  anon59_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1599} MoxaCompleteWrite(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon72_Then, anon72_Else;

  anon72_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L52;

  L52:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon58_Then, anon58_Else;

  anon58_Else:
    goto anon61_Then, anon61_Else;

  anon61_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1600} MoxaIntervalReadTimeout(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon73_Then, anon73_Else;

  anon73_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L68;

  L68:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon60_Then, anon60_Else;

  anon60_Else:
    goto anon63_Then, anon63_Else;

  anon63_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1601} MoxaIsrIn(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L84;

  L84:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    goto anon65_Then, anon65_Else;

  anon65_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1602} MoxaIsrOut(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L100;

  L100:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    goto anon67_Then, anon67_Else;

  anon67_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1603} MoxaReadTimeout(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon74_Then, anon74_Else;

  anon74_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L116;

  L116:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    goto anon68_Then, anon68_Else;

  anon68_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1604} MoxaTimeOutProcIsr#0(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon75_Then, anon75_Else;

  anon75_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon75_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon68_Then:
    goto L1;

  anon66_Then:
    goto L1;

  anon74_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon67_Then:
    goto L116;

  anon64_Then:
    goto L116;

  anon65_Then:
    goto L100;

  anon62_Then:
    goto L100;

  anon63_Then:
    goto L84;

  anon60_Then:
    goto L84;

  anon73_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon61_Then:
    goto L68;

  anon58_Then:
    goto L68;

  anon72_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon59_Then:
    goto L52;

  anon56_Then:
    goto L52;

  anon71_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon57_Then:
    goto L36;

  anon54_Then:
    goto L36;

  anon70_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon55_Then:
    goto L20;

  anon52_Then:
    goto L20;

  anon69_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon53_Then:
    goto L4;

  anon51_Then:
    goto L4;
}



procedure {:origName "sdv_RunKeDpcRoutines"} {:osmodel} sdv_RunKeDpcRoutines#0(actual_kdpc: int, actual_pDpcContext: int, actual_pv2: int, actual_pv3: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "sdv_RunKeDpcRoutines"} {:osmodel} sdv_RunKeDpcRoutines#1(actual_kdpc: int, actual_pDpcContext: int, actual_pv2: int, actual_pv3: int)
{
  var {:pointer} kdpc: int;
  var {:pointer} pDpcContext: int;
  var vslice_dummy_var_254: int;

  anon0:
    call {:si_unique_call 1605} vslice_dummy_var_254 := __HAVOC_malloc(4);
    kdpc := actual_kdpc;
    pDpcContext := actual_pDpcContext;
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon51_Then, anon51_Else;

  anon51_Else:
    goto anon53_Then, anon53_Else;

  anon53_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1606} MoxaCommError(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon69_Then, anon69_Else;

  anon69_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L4;

  L4:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon52_Then, anon52_Else;

  anon52_Else:
    goto anon55_Then, anon55_Else;

  anon55_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1607} MoxaCompleteRead(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L20;

  L20:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon54_Then, anon54_Else;

  anon54_Else:
    goto anon57_Then, anon57_Else;

  anon57_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1608} MoxaCompleteWait(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon71_Then, anon71_Else;

  anon71_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L36;

  L36:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon56_Then, anon56_Else;

  anon56_Else:
    goto anon59_Then, anon59_Else;

  anon59_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1609} MoxaCompleteWrite(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon72_Then, anon72_Else;

  anon72_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L52;

  L52:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon58_Then, anon58_Else;

  anon58_Else:
    goto anon61_Then, anon61_Else;

  anon61_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1610} MoxaIntervalReadTimeout(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon73_Then, anon73_Else;

  anon73_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L68;

  L68:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon60_Then, anon60_Else;

  anon60_Else:
    goto anon63_Then, anon63_Else;

  anon63_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1611} MoxaIsrIn(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L84;

  L84:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    goto anon65_Then, anon65_Else;

  anon65_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1612} MoxaIsrOut(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L100;

  L100:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    goto anon67_Then, anon67_Else;

  anon67_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1613} MoxaReadTimeout(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon74_Then, anon74_Else;

  anon74_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L116;

  L116:
    assume {:nonnull} kdpc != 0;
    assume kdpc > 0;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    goto anon68_Then, anon68_Else;

  anon68_Else:
    sdv_irql_previous_5 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous;
    sdv_irql_previous := sdv_irql_current;
    sdv_irql_current := 2;
    call {:si_unique_call 1614} MoxaTimeOutProcIsr#1(kdpc, pDpcContext, sdv_pv2, sdv_pv3);
    goto anon75_Then, anon75_Else;

  anon75_Else:
    assume {:partition} yogi_error != 1;
    sdv_irql_current := 0;
    sdv_irql_previous := sdv_irql_previous_2;
    sdv_irql_previous_2 := sdv_irql_previous_3;
    sdv_irql_previous_3 := sdv_irql_previous_4;
    sdv_irql_previous_4 := sdv_irql_previous_5;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon75_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon68_Then:
    goto L1;

  anon66_Then:
    goto L1;

  anon74_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon67_Then:
    goto L116;

  anon64_Then:
    goto L116;

  anon65_Then:
    goto L100;

  anon62_Then:
    goto L100;

  anon63_Then:
    goto L84;

  anon60_Then:
    goto L84;

  anon73_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon61_Then:
    goto L68;

  anon58_Then:
    goto L68;

  anon72_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon59_Then:
    goto L52;

  anon56_Then:
    goto L52;

  anon71_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon57_Then:
    goto L36;

  anon54_Then:
    goto L36;

  anon70_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon55_Then:
    goto L20;

  anon52_Then:
    goto L20;

  anon69_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon53_Then:
    goto L4;

  anon51_Then:
    goto L4;
}



procedure {:origName "sdv_RunKeDpcRoutines"} {:osmodel} sdv_RunKeDpcRoutines#1(actual_kdpc: int, actual_pDpcContext: int, actual_pv2: int, actual_pv3: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaTimeOutProcIsr"} MoxaTimeOutProcIsr#0(actual_Dpc_3: int, actual_DeferredContext_3: int, actual_SystemContext1_3: int, actual_SystemContext2_3: int)
{
  var {:scalar} Tmp_302: int;
  var {:scalar} count_4: int;
  var {:pointer} Tmp_303: int;
  var {:pointer} next: int;
  var {:pointer} ofs_9: int;
  var {:scalar} lenMask: int;
  var {:pointer} Tmp_304: int;
  var {:pointer} Tmp_305: int;
  var {:pointer} rptr: int;
  var {:scalar} oldIrql_6: int;
  var {:pointer} Tmp_307: int;
  var {:pointer} extension_10: int;
  var {:pointer} wptr: int;
  var vslice_dummy_var_255: int;
  var vslice_dummy_var_256: int;
  var vslice_dummy_var_257: int;

  anon0:
    call {:si_unique_call 1615} vslice_dummy_var_255 := __HAVOC_malloc(4);
    havoc next;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} next != 0;
    goto L9;

  L9:
    call {:si_unique_call 1616} Tmp_302, count_4, Tmp_303, next, ofs_9, lenMask, Tmp_304, Tmp_305, rptr, oldIrql_6, Tmp_307, extension_10, wptr, vslice_dummy_var_256, vslice_dummy_var_257 := MoxaTimeOutProcIsr#0_loop_L9(Tmp_302, count_4, Tmp_303, next, ofs_9, lenMask, Tmp_304, Tmp_305, rptr, oldIrql_6, Tmp_307, extension_10, wptr, vslice_dummy_var_256, vslice_dummy_var_257);
    goto L9_last;

  L9_last:
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} next != 0;
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc extension_10;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} extension_10 != 0;
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    havoc Tmp_307;
    assume {:nonnull} Tmp_307 != 0;
    assume Tmp_307 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} BAND(Mem_T.INT4[Tmp_307], 256) != 0;
    call {:si_unique_call 1617} Tmp_305 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_305 != 0;
    assume Tmp_305 > 0;
    Mem_T.INT4[Tmp_305] := oldIrql_6;
    call {:si_unique_call 1618} IoAcquireCancelSpinLock(Tmp_305);
    assume {:nonnull} Tmp_305 != 0;
    assume Tmp_305 > 0;
    oldIrql_6 := Mem_T.INT4[Tmp_305];
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    havoc ofs_9;
    rptr := ofs_9;
    wptr := ofs_9;
    Tmp_303 := ofs_9;
    assume {:nonnull} Tmp_303 != 0;
    assume Tmp_303 > 0;
    lenMask := Mem_T.INT4[Tmp_303];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} Mem_T.INT4[wptr] >= Mem_T.INT4[rptr];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    Tmp_302 := Mem_T.INT4[wptr] - Mem_T.INT4[rptr];
    goto L34;

  L34:
    count_4 := Tmp_302;
    Tmp_304 := ofs_9;
    assume {:nonnull} Tmp_304 != 0;
    assume Tmp_304 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} count_4 >= Mem_T.INT4[Tmp_304];
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    call {:si_unique_call 1619} vslice_dummy_var_257 := KeSynchronizeExecution(0, li2bplFunctionConstant306, 0);
    goto L36;

  L36:
    call {:si_unique_call 1620} IoReleaseCancelSpinLock(oldIrql_6);
    goto L17;

  L17:
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc next;
    goto L17_dummy;

  L17_dummy:
    assume false;
    return;

  anon23_Then:
    call {:si_unique_call 1621} vslice_dummy_var_256 := MoxaIsrGetData#0(extension_10);
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    goto L36;

  anon29_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  LM2:
    return;

  anon28_Then:
    assume {:partition} Mem_T.INT4[Tmp_304] > count_4;
    goto L36;

  anon27_Then:
    assume {:partition} Mem_T.INT4[rptr] > Mem_T.INT4[wptr];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    Tmp_302 := Mem_T.INT4[wptr] - Mem_T.INT4[rptr] + lenMask + 1;
    goto L34;

  anon26_Then:
    assume {:partition} BAND(Mem_T.INT4[Tmp_307], 256) == 0;
    goto L17;

  anon22_Then:
    goto L17;

  anon25_Then:
    assume {:partition} extension_10 == 0;
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc next;
    goto anon25_Then_dummy;

  anon25_Then_dummy:
    assume false;
    return;

  anon21_Then:
    assume {:partition} next == 0;
    call {:si_unique_call 1622} MoxaResetTimeOutProc_sdv_static_function_9();
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  L1:
    goto LM2;

  anon30_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon24_Then:
    assume {:partition} next == 0;
    goto L1;
}



procedure {:origName "MoxaTimeOutProcIsr"} MoxaTimeOutProcIsr#0(actual_Dpc_3: int, actual_DeferredContext_3: int, actual_SystemContext1_3: int, actual_SystemContext2_3: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} old(sdv_irql_current) == 0 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 1 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == 2 ==> yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) <= 2 && old(sdv_irql_previous) <= 2 && old(sdv_irql_previous_2) <= 2 && old(sdv_irql_previous_3) <= 2 ==> yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_4) || sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous) || sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_2) || sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaTimeOutProcIsr"} MoxaTimeOutProcIsr#1(actual_Dpc_3: int, actual_DeferredContext_3: int, actual_SystemContext1_3: int, actual_SystemContext2_3: int)
{
  var {:scalar} Tmp_302: int;
  var {:scalar} count_4: int;
  var {:pointer} Tmp_303: int;
  var {:pointer} next: int;
  var {:pointer} ofs_9: int;
  var {:scalar} lenMask: int;
  var {:pointer} Tmp_304: int;
  var {:pointer} Tmp_305: int;
  var {:pointer} rptr: int;
  var {:scalar} oldIrql_6: int;
  var {:pointer} Tmp_307: int;
  var {:pointer} extension_10: int;
  var {:pointer} wptr: int;
  var vslice_dummy_var_258: int;
  var vslice_dummy_var_259: int;
  var vslice_dummy_var_260: int;

  anon0:
    call {:si_unique_call 1623} vslice_dummy_var_258 := __HAVOC_malloc(4);
    havoc next;
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} next != 0;
    goto L9;

  L9:
    call {:si_unique_call 1624} Tmp_302, count_4, Tmp_303, next, ofs_9, lenMask, Tmp_304, Tmp_305, rptr, oldIrql_6, Tmp_307, extension_10, wptr, vslice_dummy_var_259, vslice_dummy_var_260 := MoxaTimeOutProcIsr#1_loop_L9(Tmp_302, count_4, Tmp_303, next, ofs_9, lenMask, Tmp_304, Tmp_305, rptr, oldIrql_6, Tmp_307, extension_10, wptr, vslice_dummy_var_259, vslice_dummy_var_260);
    goto L9_last;

  L9_last:
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} next != 0;
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc extension_10;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} extension_10 != 0;
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    havoc Tmp_307;
    assume {:nonnull} Tmp_307 != 0;
    assume Tmp_307 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} BAND(Mem_T.INT4[Tmp_307], 256) != 0;
    call {:si_unique_call 1625} Tmp_305 := __HAVOC_malloc(4);
    assume {:nonnull} Tmp_305 != 0;
    assume Tmp_305 > 0;
    Mem_T.INT4[Tmp_305] := oldIrql_6;
    call {:si_unique_call 1626} IoAcquireCancelSpinLock(Tmp_305);
    assume {:nonnull} Tmp_305 != 0;
    assume Tmp_305 > 0;
    oldIrql_6 := Mem_T.INT4[Tmp_305];
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    havoc ofs_9;
    rptr := ofs_9;
    wptr := ofs_9;
    Tmp_303 := ofs_9;
    assume {:nonnull} Tmp_303 != 0;
    assume Tmp_303 > 0;
    lenMask := Mem_T.INT4[Tmp_303];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} Mem_T.INT4[wptr] >= Mem_T.INT4[rptr];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    Tmp_302 := Mem_T.INT4[wptr] - Mem_T.INT4[rptr];
    goto L34;

  L34:
    count_4 := Tmp_302;
    Tmp_304 := ofs_9;
    assume {:nonnull} Tmp_304 != 0;
    assume Tmp_304 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} count_4 >= Mem_T.INT4[Tmp_304];
    assume {:nonnull} extension_10 != 0;
    assume extension_10 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    call {:si_unique_call 1627} vslice_dummy_var_260 := KeSynchronizeExecution(0, li2bplFunctionConstant306, 0);
    goto L36;

  L36:
    call {:si_unique_call 1628} IoReleaseCancelSpinLock(oldIrql_6);
    goto L17;

  L17:
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc next;
    goto L17_dummy;

  L17_dummy:
    assume false;
    return;

  anon23_Then:
    call {:si_unique_call 1629} vslice_dummy_var_259 := MoxaIsrGetData#1(extension_10);
    goto anon29_Then, anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    goto L36;

  anon29_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  LM2:
    return;

  anon28_Then:
    assume {:partition} Mem_T.INT4[Tmp_304] > count_4;
    goto L36;

  anon27_Then:
    assume {:partition} Mem_T.INT4[rptr] > Mem_T.INT4[wptr];
    assume {:nonnull} rptr != 0;
    assume rptr > 0;
    assume {:nonnull} wptr != 0;
    assume wptr > 0;
    Tmp_302 := Mem_T.INT4[wptr] - Mem_T.INT4[rptr] + lenMask + 1;
    goto L34;

  anon26_Then:
    assume {:partition} BAND(Mem_T.INT4[Tmp_307], 256) == 0;
    goto L17;

  anon22_Then:
    goto L17;

  anon25_Then:
    assume {:partition} extension_10 == 0;
    assume {:nonnull} next != 0;
    assume next > 0;
    havoc next;
    goto anon25_Then_dummy;

  anon25_Then_dummy:
    assume false;
    return;

  anon21_Then:
    assume {:partition} next == 0;
    call {:si_unique_call 1630} MoxaResetTimeOutProc_sdv_static_function_9();
    goto anon30_Then, anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    goto L1;

  L1:
    goto LM2;

  anon30_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon24_Then:
    assume {:partition} next == 0;
    goto L1;
}



procedure {:origName "MoxaTimeOutProcIsr"} MoxaTimeOutProcIsr#1(actual_Dpc_3: int, actual_DeferredContext_3: int, actual_SystemContext1_3: int, actual_SystemContext2_3: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIsrGetData"} MoxaIsrGetData#0(actual_Context: int) returns (Tmp_314: int)
{
  var {:pointer} Tmp_315: int;
  var {:pointer} irpSp_2: int;
  var {:pointer} Tmp_316: int;
  var {:pointer} Tmp_317: int;
  var {:pointer} Tmp_318: int;
  var {:pointer} Tmp_319: int;
  var {:pointer} Tmp_320: int;
  var {:scalar} max: int;
  var {:pointer} Tmp_321: int;
  var {:pointer} Tmp_322: int;
  var {:pointer} extension_12: int;
  var {:pointer} Context: int;
  var vslice_dummy_var_1346: int;
  var vslice_dummy_var_1347: int;

  anon0:
    Context := actual_Context;
    extension_12 := Context;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    call {:si_unique_call 1631} MoxaGetData(extension_12);
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_316;
    assume {:nonnull} Tmp_316 != 0;
    assume Tmp_316 > 0;
    max := Mem_T.INT4[Tmp_316] - 256;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_315;
    assume {:nonnull} Tmp_315 != 0;
    assume Tmp_315 > 0;
    Mem_T.INT4[Tmp_315] := max;
    goto L20;

  L20:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_320;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_319;
    assume {:nonnull} Tmp_319 != 0;
    assume Tmp_319 > 0;
    assume {:nonnull} Tmp_320 != 0;
    assume Tmp_320 > 0;
    Mem_T.INT4[Tmp_320] := BOR(Mem_T.INT4[Tmp_319], 256);
    goto L8;

  L8:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    Tmp_314 := 0;
    goto LM2;

  LM2:
    return;

  anon11_Then:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_321;
    assume {:nonnull} Tmp_321 != 0;
    assume Tmp_321 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc vslice_dummy_var_1346;
    Mem_T.INT4[Tmp_321] := vslice_dummy_var_1346;
    goto L20;

  anon10_Then:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_317;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_322;
    assume {:nonnull} Tmp_317 != 0;
    assume Tmp_317 > 0;
    assume {:nonnull} Tmp_322 != 0;
    assume Tmp_322 > 0;
    Mem_T.INT4[Tmp_317] := BAND(Mem_T.INT4[Tmp_322], BNOT(256));
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc vslice_dummy_var_1347;
    call {:si_unique_call 1632} irpSp_2 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1347);
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_318;
    assume {:nonnull} Tmp_318 != 0;
    assume Tmp_318 > 0;
    assume {:nonnull} irpSp_2 != 0;
    assume irpSp_2 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    assume false;
    return;

  anon9_Then:
    goto L8;
}



procedure {:origName "MoxaIsrGetData"} MoxaIsrGetData#0(actual_Context: int) returns (Tmp_314: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} Tmp_314 == 0;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaIsrGetData"} MoxaIsrGetData#1(actual_Context: int) returns (Tmp_314: int)
{
  var {:pointer} Tmp_315: int;
  var {:pointer} irpSp_2: int;
  var {:pointer} Tmp_316: int;
  var {:pointer} Tmp_317: int;
  var {:pointer} Tmp_318: int;
  var {:pointer} Tmp_319: int;
  var {:pointer} Tmp_320: int;
  var {:scalar} max: int;
  var {:pointer} Tmp_321: int;
  var {:pointer} Tmp_322: int;
  var {:pointer} extension_12: int;
  var {:pointer} Context: int;
  var vslice_dummy_var_261: int;
  var vslice_dummy_var_1348: int;
  var vslice_dummy_var_1349: int;

  anon0:
    Context := actual_Context;
    extension_12 := Context;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    call {:si_unique_call 1633} MoxaGetData(extension_12);
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon10_Then, anon10_Else;

  anon10_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_316;
    assume {:nonnull} Tmp_316 != 0;
    assume Tmp_316 > 0;
    max := Mem_T.INT4[Tmp_316] - 256;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_315;
    assume {:nonnull} Tmp_315 != 0;
    assume Tmp_315 > 0;
    Mem_T.INT4[Tmp_315] := max;
    goto L20;

  L20:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_320;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_319;
    assume {:nonnull} Tmp_319 != 0;
    assume Tmp_319 > 0;
    assume {:nonnull} Tmp_320 != 0;
    assume Tmp_320 > 0;
    Mem_T.INT4[Tmp_320] := BOR(Mem_T.INT4[Tmp_319], 256);
    goto L8;

  L8:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    Tmp_314 := 0;
    goto LM2;

  LM2:
    return;

  anon11_Then:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_321;
    assume {:nonnull} Tmp_321 != 0;
    assume Tmp_321 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc vslice_dummy_var_1348;
    Mem_T.INT4[Tmp_321] := vslice_dummy_var_1348;
    goto L20;

  anon10_Then:
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_317;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_322;
    assume {:nonnull} Tmp_317 != 0;
    assume Tmp_317 > 0;
    assume {:nonnull} Tmp_322 != 0;
    assume Tmp_322 > 0;
    Mem_T.INT4[Tmp_317] := BAND(Mem_T.INT4[Tmp_322], BNOT(256));
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc vslice_dummy_var_1349;
    call {:si_unique_call 1634} irpSp_2 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1349);
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    havoc Tmp_318;
    assume {:nonnull} Tmp_318 != 0;
    assume Tmp_318 > 0;
    assume {:nonnull} irpSp_2 != 0;
    assume irpSp_2 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    assume {:nonnull} extension_12 != 0;
    assume extension_12 > 0;
    call {:si_unique_call 1635} vslice_dummy_var_261 := MoxaInsertQueueDpc#0(CompleteReadDpc__MOXA_DEVICE_EXTENSION(extension_12), 0, 0, extension_12);
    goto anon12_Then, anon12_Else;

  anon12_Else:
    assume {:partition} yogi_error != 1;
    goto L8;

  anon12_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;

  anon9_Then:
    goto L8;
}



procedure {:origName "MoxaIsrGetData"} MoxaIsrGetData#1(actual_Context: int) returns (Tmp_314: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaInsertQueueDpc"} MoxaInsertQueueDpc#0(actual_PDpc: int, actual_Sarg1: int, actual_Sarg2: int, actual_PDevExt_8: int) returns (Tmp_668: int)
{
  var {:pointer} Tmp_669: int;
  var {:scalar} sdv_240: int;
  var {:scalar} pendingCnt_1: int;
  var {:scalar} queued: int;
  var {:pointer} PDpc: int;
  var {:pointer} Sarg1: int;
  var {:pointer} Sarg2: int;
  var {:pointer} PDevExt_8: int;
  var vslice_dummy_var_262: int;
  var vslice_dummy_var_263: int;
  var vslice_dummy_var_1350: int;
  var vslice_dummy_var_1351: int;

  anon0:
    PDpc := actual_PDpc;
    Sarg1 := actual_Sarg1;
    Sarg2 := actual_Sarg2;
    PDevExt_8 := actual_PDevExt_8;
    call {:si_unique_call 1636} Tmp_669 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    havoc vslice_dummy_var_1350;
    Mem_T.INT4[Tmp_669] := vslice_dummy_var_1350;
    call {:si_unique_call 1637} vslice_dummy_var_263 := sdv_InterlockedIncrement(Tmp_669);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    call {:si_unique_call 1638} queued := KeInsertQueueDpc#0(PDpc, Sarg1, Sarg2);
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} yogi_error != 1;
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} queued == 0;
    call {:si_unique_call 1639} Tmp_669 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    havoc vslice_dummy_var_1351;
    Mem_T.INT4[Tmp_669] := vslice_dummy_var_1351;
    call {:si_unique_call 1640} sdv_240 := sdv_InterlockedDecrement(Tmp_669);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    pendingCnt_1 := sdv_240;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} pendingCnt_1 == 0;
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    call {:si_unique_call 1641} vslice_dummy_var_262 := KeSetEvent(PendingIRPEvent__MOXA_DEVICE_EXTENSION(PDevExt_8), 0, 0);
    goto L13;

  L13:
    Tmp_668 := queued;
    goto LM2;

  LM2:
    return;

  anon9_Then:
    assume {:partition} pendingCnt_1 != 0;
    goto L13;

  anon7_Then:
    assume {:partition} queued != 0;
    goto L13;

  anon8_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaInsertQueueDpc"} MoxaInsertQueueDpc#0(actual_PDpc: int, actual_Sarg1: int, actual_Sarg2: int, actual_PDevExt_8: int) returns (Tmp_668: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "MoxaInsertQueueDpc"} MoxaInsertQueueDpc#1(actual_PDpc: int, actual_Sarg1: int, actual_Sarg2: int, actual_PDevExt_8: int) returns (Tmp_668: int)
{
  var {:pointer} Tmp_669: int;
  var {:scalar} sdv_240: int;
  var {:scalar} pendingCnt_1: int;
  var {:scalar} queued: int;
  var {:pointer} PDpc: int;
  var {:pointer} Sarg1: int;
  var {:pointer} Sarg2: int;
  var {:pointer} PDevExt_8: int;
  var vslice_dummy_var_264: int;
  var vslice_dummy_var_265: int;
  var vslice_dummy_var_1352: int;
  var vslice_dummy_var_1353: int;

  anon0:
    PDpc := actual_PDpc;
    Sarg1 := actual_Sarg1;
    Sarg2 := actual_Sarg2;
    PDevExt_8 := actual_PDevExt_8;
    call {:si_unique_call 1642} Tmp_669 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    havoc vslice_dummy_var_1352;
    Mem_T.INT4[Tmp_669] := vslice_dummy_var_1352;
    call {:si_unique_call 1643} vslice_dummy_var_265 := sdv_InterlockedIncrement(Tmp_669);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    call {:si_unique_call 1644} queued := KeInsertQueueDpc#1(PDpc, Sarg1, Sarg2);
    goto anon8_Then, anon8_Else;

  anon8_Else:
    assume {:partition} yogi_error != 1;
    goto anon7_Then, anon7_Else;

  anon7_Else:
    assume {:partition} queued == 0;
    call {:si_unique_call 1645} Tmp_669 := __HAVOC_malloc(4);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    havoc vslice_dummy_var_1353;
    Mem_T.INT4[Tmp_669] := vslice_dummy_var_1353;
    call {:si_unique_call 1646} sdv_240 := sdv_InterlockedDecrement(Tmp_669);
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    assume {:nonnull} Tmp_669 != 0;
    assume Tmp_669 > 0;
    pendingCnt_1 := sdv_240;
    goto anon9_Then, anon9_Else;

  anon9_Else:
    assume {:partition} pendingCnt_1 == 0;
    assume {:nonnull} PDevExt_8 != 0;
    assume PDevExt_8 > 0;
    call {:si_unique_call 1647} vslice_dummy_var_264 := KeSetEvent(PendingIRPEvent__MOXA_DEVICE_EXTENSION(PDevExt_8), 0, 0);
    goto L13;

  L13:
    Tmp_668 := queued;
    goto LM2;

  LM2:
    return;

  anon9_Then:
    assume {:partition} pendingCnt_1 != 0;
    goto L13;

  anon7_Then:
    assume {:partition} queued != 0;
    goto L13;

  anon8_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "MoxaInsertQueueDpc"} MoxaInsertQueueDpc#1(actual_PDpc: int, actual_Sarg1: int, actual_Sarg2: int, actual_PDevExt_8: int) returns (Tmp_668: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeInsertQueueDpc"} {:osmodel} KeInsertQueueDpc#0(actual_Dpc_12: int, actual_SystemArgument1: int, actual_SystemArgument2: int) returns (Tmp_987: int)
{
  var {:pointer} Dpc_12: int;
  var vslice_dummy_var_1354: int;
  var vslice_dummy_var_1355: int;

  anon0:
    Dpc_12 := actual_Dpc_12;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    Tmp_987 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon5_Then:
    havoc vslice_dummy_var_1354;
    havoc vslice_dummy_var_1355;
    call {:si_unique_call 1648} sdv_RunKeDpcRoutines#0(vslice_dummy_var_1354, vslice_dummy_var_1355, 0, 0);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    Tmp_987 := 1;
    goto L1;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "KeInsertQueueDpc"} {:osmodel} KeInsertQueueDpc#0(actual_Dpc_12: int, actual_SystemArgument1: int, actual_SystemArgument2: int) returns (Tmp_987: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:origName "KeInsertQueueDpc"} {:osmodel} KeInsertQueueDpc#1(actual_Dpc_12: int, actual_SystemArgument1: int, actual_SystemArgument2: int) returns (Tmp_987: int)
{
  var {:pointer} Dpc_12: int;
  var vslice_dummy_var_1356: int;
  var vslice_dummy_var_1357: int;

  anon0:
    Dpc_12 := actual_Dpc_12;
    goto anon5_Then, anon5_Else;

  anon5_Else:
    Tmp_987 := 0;
    goto L1;

  L1:
    goto LM2;

  LM2:
    return;

  anon5_Then:
    havoc vslice_dummy_var_1356;
    havoc vslice_dummy_var_1357;
    call {:si_unique_call 1649} sdv_RunKeDpcRoutines#1(vslice_dummy_var_1356, vslice_dummy_var_1357, 0, 0);
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} yogi_error != 1;
    Tmp_987 := 1;
    goto L1;

  anon6_Then:
    assume {:partition} yogi_error == 1;
    goto LM2;
}



procedure {:origName "KeInsertQueueDpc"} {:osmodel} KeInsertQueueDpc#1(actual_Dpc_12: int, actual_SystemArgument1: int, actual_SystemArgument2: int) returns (Tmp_987: int);
  modifies alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.INT4, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



function POW2(a: int) : bool;

axiom (forall x: int :: { POW2(x) } x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768 || x == 65536 || x == 131072 || x == 262144 || x == 524288 || x == 1048576 || x == 2097152 || x == 4194304 || x == 8388608 || x == 16777216 || x == 33554432 || x == 67108864 || x == 134217728 || x == 268435456 || x == 536870912 || x == 1073741824 || x == 2147483648 || x == -2147483648 ==> POW2(x));

axiom (forall f: int :: { BAND(0, f) } BAND(0, f) == 0);

axiom (forall f: int :: { BAND(f, f) } BAND(f, f) == f);

axiom (forall f: int :: { BOR(0, f) } BOR(0, f) == f);

axiom (forall f: int :: { BOR(f, 0) } BOR(f, 0) == f);

axiom (forall x: int, f: int :: { BAND(x, f) } POW2(x) && POW2(f) && x != f ==> BAND(x, f) == 0);

axiom (forall a: int, b: int, c: int :: { BOR(a, BOR(b, c)) } BOR(a, BOR(b, c)) == BOR(BOR(a, b), c));

axiom (forall a: int, b: int, c: int :: { BAND(a, BOR(b, c)) } BAND(a, BOR(b, c)) == BAND(BOR(b, c), a));

axiom (forall x: int, f1: int, f2: int :: { BAND(BOR(x, f1), f2) } (f1 != f2 && POW2(f1) && POW2(f2) ==> BAND(BOR(x, f1), f2) == BAND(x, f2)) && (f1 == f2 ==> BAND(BOR(x, f1), f2) == f1));

axiom (forall x: int, f1: int, f2: int :: { BAND(BAND(x, BNOT(f1)), f2) } (f1 != f2 && POW2(f1) && POW2(f2) ==> BAND(BAND(x, BNOT(f1)), f2) == BAND(x, f2)) && (f1 == f2 && POW2(f1) && POW2(f2) ==> BAND(BAND(x, BNOT(f1)), f2) == 0));

axiom (forall x: int, f1: int, f2: int :: { BAND(BOR(f1, x), f2) } (f1 != f2 && POW2(f1) && POW2(f2) ==> BAND(BOR(f1, x), f2) == BAND(x, f2)) && (f1 == f2 ==> BAND(BOR(f1, x), f2) == f1));

axiom (forall x: int, y: int, f2: int :: { BAND(BAND(x, y), f2) } POW2(f2) ==> BAND(BAND(x, y), f2) == 0 || BAND(BAND(x, y), f2) == BAND(x, f2));

implementation MoxaGetData_loop_L34(in_Tmp_12: int, in_Tmp_19: int, in_Tmp_21: int, in_Tmp_34: int) returns (out_Tmp_12: int, out_Tmp_19: int, out_Tmp_21: int, out_Tmp_34: int)
{

  entry:
    out_Tmp_12, out_Tmp_19, out_Tmp_21, out_Tmp_34 := in_Tmp_12, in_Tmp_19, in_Tmp_21, in_Tmp_34;
    goto L34, exit;

  exit:
    return;

  L34:
    havoc out_Tmp_34;
    goto anon47_Else;

  anon47_Else:
    assume {:partition} out_Tmp_34 != 0;
    havoc out_Tmp_21;
    havoc out_Tmp_12;
    havoc out_Tmp_19;
    assume {:nonnull} out_Tmp_19 != 0;
    assume out_Tmp_19 > 0;
    assume {:nonnull} out_Tmp_21 != 0;
    assume out_Tmp_21 > 0;
    Mem_T.INT4[out_Tmp_21] := Mem_T.INT4[out_Tmp_19];
    goto anon47_Else_dummy;

  anon47_Else_dummy:
    call {:si_unique_call 1650} {:si_old_unique_call 1} out_Tmp_12, out_Tmp_19, out_Tmp_21, out_Tmp_34 := MoxaGetData_loop_L34(out_Tmp_12, out_Tmp_19, out_Tmp_21, out_Tmp_34);
    return;
}



procedure {:LoopProcedure} MoxaGetData_loop_L34(in_Tmp_12: int, in_Tmp_19: int, in_Tmp_21: int, in_Tmp_34: int) returns (out_Tmp_12: int, out_Tmp_19: int, out_Tmp_21: int, out_Tmp_34: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaGetData_loop_L71(in_Tmp_22: int, in_Tmp_25: int, in_Tmp_28: int, in_Tmp_32: int) returns (out_Tmp_22: int, out_Tmp_25: int, out_Tmp_28: int, out_Tmp_32: int)
{

  entry:
    out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_32 := in_Tmp_22, in_Tmp_25, in_Tmp_28, in_Tmp_32;
    goto L71, exit;

  exit:
    return;

  L71:
    havoc out_Tmp_25;
    goto anon53_Else;

  anon53_Else:
    assume {:partition} out_Tmp_25 != 0;
    havoc out_Tmp_28;
    havoc out_Tmp_32;
    havoc out_Tmp_22;
    assume {:nonnull} out_Tmp_22 != 0;
    assume out_Tmp_22 > 0;
    assume {:nonnull} out_Tmp_28 != 0;
    assume out_Tmp_28 > 0;
    Mem_T.INT4[out_Tmp_28] := Mem_T.INT4[out_Tmp_22];
    goto anon53_Else_dummy;

  anon53_Else_dummy:
    call {:si_unique_call 1651} {:si_old_unique_call 1} out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_32 := MoxaGetData_loop_L71(out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_32);
    return;
}



procedure {:LoopProcedure} MoxaGetData_loop_L71(in_Tmp_22: int, in_Tmp_25: int, in_Tmp_28: int, in_Tmp_32: int) returns (out_Tmp_22: int, out_Tmp_25: int, out_Tmp_28: int, out_Tmp_32: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaGetData_loop_L60(in_Tmp_11: int, in_Tmp_16: int, in_Tmp_18: int, in_Tmp_22: int, in_Tmp_25: int, in_Tmp_28: int, in_Tmp_31: int, in_Tmp_32: int) returns (out_Tmp_11: int, out_Tmp_16: int, out_Tmp_18: int, out_Tmp_22: int, out_Tmp_25: int, out_Tmp_28: int, out_Tmp_31: int, out_Tmp_32: int)
{
  var vslice_dummy_var_1358: int;

  entry:
    out_Tmp_11, out_Tmp_16, out_Tmp_18, out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_31, out_Tmp_32 := in_Tmp_11, in_Tmp_16, in_Tmp_18, in_Tmp_22, in_Tmp_25, in_Tmp_28, in_Tmp_31, in_Tmp_32;
    goto L60, exit;

  exit:
    return;

  L60:
    goto anon50_Then, anon50_Else;

  anon50_Else:
    goto L62;

  L62:
    goto anon51_Then, anon51_Else;

  anon51_Else:
    havoc Mem_T.INT4;
    goto anon52_Then, anon52_Else;

  anon52_Else:
    havoc out_Tmp_16;
    out_Tmp_31 := out_Tmp_16;
    havoc Mem_T.INT4;
    goto L68;

  L68:
    call {:si_unique_call 1653} vslice_dummy_var_1358 := corral_nondet();
    goto L71;

  L71:
    call {:si_unique_call 1652} out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_32 := MoxaGetData_loop_L71(out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_32);
    goto L71_last;

  L71_last:
    havoc out_Tmp_25;
    goto anon53_Then, anon53_Else;

  anon53_Else:
    assume {:partition} out_Tmp_25 != 0;
    havoc out_Tmp_28;
    havoc out_Tmp_32;
    havoc out_Tmp_22;
    assume {:nonnull} out_Tmp_22 != 0;
    assume out_Tmp_22 > 0;
    assume {:nonnull} out_Tmp_28 != 0;
    assume out_Tmp_28 > 0;
    Mem_T.INT4[out_Tmp_28] := Mem_T.INT4[out_Tmp_22];
    assume false;
    return;

  anon53_Then:
    assume {:partition} out_Tmp_25 == 0;
    goto anon42_Then, anon42_Else;

  anon42_Else:
    havoc out_Tmp_11;
    out_Tmp_18 := out_Tmp_11;
    havoc Mem_T.INT4;
    goto L65;

  L65:
    goto anon41_Then;

  anon41_Then:
    goto anon54_Then, anon54_Else;

  anon54_Else:
    goto L78;

  L78:
    goto L78_dummy;

  L78_dummy:
    call {:si_unique_call 1654} {:si_old_unique_call 1} out_Tmp_11, out_Tmp_16, out_Tmp_18, out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_31, out_Tmp_32 := MoxaGetData_loop_L60(out_Tmp_11, out_Tmp_16, out_Tmp_18, out_Tmp_22, out_Tmp_25, out_Tmp_28, out_Tmp_31, out_Tmp_32);
    return;

  anon54_Then:
    goto L78;

  anon42_Then:
    goto L65;

  anon52_Then:
    goto L68;

  anon51_Then:
    goto L65;

  anon50_Then:
    goto L62;
}



procedure {:LoopProcedure} MoxaGetData_loop_L60(in_Tmp_11: int, in_Tmp_16: int, in_Tmp_18: int, in_Tmp_22: int, in_Tmp_25: int, in_Tmp_28: int, in_Tmp_31: int, in_Tmp_32: int) returns (out_Tmp_11: int, out_Tmp_16: int, out_Tmp_18: int, out_Tmp_22: int, out_Tmp_25: int, out_Tmp_28: int, out_Tmp_31: int, out_Tmp_32: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaStartRead_loop_L20(in_Tmp_49: int, in_Tmp_50: int, in_Tmp_51: int, in_Tmp_52: int, in_irpSp: int, in_totalTime_1: int, in_os2ssreturn: int, in_timeoutsForIrp: int, in_Tmp_53: int, in_Tmp_54: int, in_setFirstStatus: int, in_newIrp: int, in_useTotalTimer: int, in_multiplierVal: int, in_crunchDownToOne: int, in_sdv_16: int, in_sdv_17: int, in_oldIrql_2: int, in_Tmp_59: int, in_sdv_21: int, in_constantVal: int, in_Tmp_60: int, in_ioControlCode: int, in_Tmp_61: int, in_controlIrql: int, in_Tmp_62: int, in_returnWithWhatsPresent: int, in_useIntervalTimer: int, in_firstStatus: int, in_Extension_1: int, in_vslice_dummy_var_8: int, in_vslice_dummy_var_9: int, in_vslice_dummy_var_10: int, in_vslice_dummy_var_11: int) returns (out_Tmp_49: int, out_Tmp_50: int, out_Tmp_51: int, out_Tmp_52: int, out_irpSp: int, out_os2ssreturn: int, out_Tmp_53: int, out_Tmp_54: int, out_setFirstStatus: int, out_useTotalTimer: int, out_multiplierVal: int, out_crunchDownToOne: int, out_sdv_16: int, out_sdv_17: int, out_oldIrql_2: int, out_Tmp_59: int, out_sdv_21: int, out_constantVal: int, out_Tmp_60: int, out_ioControlCode: int, out_Tmp_61: int, out_controlIrql: int, out_Tmp_62: int, out_returnWithWhatsPresent: int, out_useIntervalTimer: int, out_firstStatus: int, out_vslice_dummy_var_8: int, out_vslice_dummy_var_9: int, out_vslice_dummy_var_10: int, out_vslice_dummy_var_11: int)
{
  var vslice_dummy_var_1359: int;
  var vslice_dummy_var_1360: int;
  var vslice_dummy_var_1361: int;
  var vslice_dummy_var_1362: int;

  entry:
    out_Tmp_49, out_Tmp_50, out_Tmp_51, out_Tmp_52, out_irpSp, out_os2ssreturn, out_Tmp_53, out_Tmp_54, out_setFirstStatus, out_useTotalTimer, out_multiplierVal, out_crunchDownToOne, out_sdv_16, out_sdv_17, out_oldIrql_2, out_Tmp_59, out_sdv_21, out_constantVal, out_Tmp_60, out_ioControlCode, out_Tmp_61, out_controlIrql, out_Tmp_62, out_returnWithWhatsPresent, out_useIntervalTimer, out_firstStatus, out_vslice_dummy_var_8, out_vslice_dummy_var_9, out_vslice_dummy_var_10, out_vslice_dummy_var_11 := in_Tmp_49, in_Tmp_50, in_Tmp_51, in_Tmp_52, in_irpSp, in_os2ssreturn, in_Tmp_53, in_Tmp_54, in_setFirstStatus, in_useTotalTimer, in_multiplierVal, in_crunchDownToOne, in_sdv_16, in_sdv_17, in_oldIrql_2, in_Tmp_59, in_sdv_21, in_constantVal, in_Tmp_60, in_ioControlCode, in_Tmp_61, in_controlIrql, in_Tmp_62, in_returnWithWhatsPresent, in_useIntervalTimer, in_firstStatus, in_vslice_dummy_var_8, in_vslice_dummy_var_9, in_vslice_dummy_var_10, in_vslice_dummy_var_11;
    goto L20, exit;

  exit:
    return;

  L20:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc vslice_dummy_var_1359;
    call {:si_unique_call 1655} out_irpSp := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1359);
    assume {:nonnull} out_irpSp != 0;
    assume out_irpSp > 0;
    goto anon75_Then, anon75_Else;

  anon75_Else:
    call {:si_unique_call 1681} out_Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    Mem_T.INT4[out_Tmp_50] := out_controlIrql;
    call {:si_unique_call 1682} sdv_KeAcquireSpinLock(0, out_Tmp_50);
    goto anon102_Else;

  anon102_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    out_controlIrql := Mem_T.INT4[out_Tmp_50];
    call {:si_unique_call 1679} out_Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    Mem_T.INT4[out_Tmp_50] := out_oldIrql_2;
    call {:si_unique_call 1680} IoAcquireCancelSpinLock(out_Tmp_50);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    out_oldIrql_2 := Mem_T.INT4[out_Tmp_50];
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_52;
    assume {:nonnull} out_Tmp_52 != 0;
    assume out_Tmp_52 > 0;
    goto anon103_Then, anon103_Else;

  anon103_Else:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_54;
    assume {:nonnull} out_Tmp_54 != 0;
    assume out_Tmp_54 > 0;
    call {:si_unique_call 1683} IoReleaseCancelSpinLock(out_oldIrql_2);
    call {:si_unique_call 1684} sdv_KeReleaseSpinLock(0, out_controlIrql);
    goto anon76_Then, anon76_Else;

  anon76_Else:
    assume {:partition} out_setFirstStatus != 0;
    goto L45;

  L45:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    call {:si_unique_call 1656} MoxaGetNextIrp(CurrentReadIrp__MOXA_DEVICE_EXTENSION(in_Extension_1), ReadQueue__MOXA_DEVICE_EXTENSION(in_Extension_1), in_newIrp, 1, in_Extension_1);
    assume {:nonnull} in_newIrp != 0;
    assume in_newIrp > 0;
    goto anon77_Then;

  anon77_Then:
    goto anon77_Then_dummy;

  anon77_Then_dummy:
    call {:si_unique_call 1685} {:si_old_unique_call 1} out_Tmp_49, out_Tmp_50, out_Tmp_51, out_Tmp_52, out_irpSp, out_os2ssreturn, out_Tmp_53, out_Tmp_54, out_setFirstStatus, out_useTotalTimer, out_multiplierVal, out_crunchDownToOne, out_sdv_16, out_sdv_17, out_oldIrql_2, out_Tmp_59, out_sdv_21, out_constantVal, out_Tmp_60, out_ioControlCode, out_Tmp_61, out_controlIrql, out_Tmp_62, out_returnWithWhatsPresent, out_useIntervalTimer, out_firstStatus, out_vslice_dummy_var_8, out_vslice_dummy_var_9, out_vslice_dummy_var_10, out_vslice_dummy_var_11 := MoxaStartRead_loop_L20(out_Tmp_49, out_Tmp_50, out_Tmp_51, out_Tmp_52, out_irpSp, in_totalTime_1, out_os2ssreturn, in_timeoutsForIrp, out_Tmp_53, out_Tmp_54, out_setFirstStatus, in_newIrp, out_useTotalTimer, out_multiplierVal, out_crunchDownToOne, out_sdv_16, out_sdv_17, out_oldIrql_2, out_Tmp_59, out_sdv_21, out_constantVal, out_Tmp_60, out_ioControlCode, out_Tmp_61, out_controlIrql, out_Tmp_62, out_returnWithWhatsPresent, out_useIntervalTimer, out_firstStatus, in_Extension_1, out_vslice_dummy_var_8, out_vslice_dummy_var_9, out_vslice_dummy_var_10, out_vslice_dummy_var_11);
    return;

  anon76_Then:
    assume {:partition} out_setFirstStatus == 0;
    out_firstStatus := -1073741536;
    out_setFirstStatus := 1;
    goto L45;

  anon103_Then:
    assume {:nonnull} out_irpSp != 0;
    assume out_irpSp > 0;
    havoc out_ioControlCode;
    goto anon104_Then, anon104_Else;

  anon104_Else:
    assume {:partition} out_ioControlCode == 1777688;
    call {:si_unique_call 1677} out_vslice_dummy_var_9 := KeSynchronizeExecution(0, li2bplFunctionConstant141, 0);
    goto L58;

  L58:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_61;
    assume {:nonnull} out_Tmp_61 != 0;
    assume out_Tmp_61 > 0;
    call {:si_unique_call 1675} IoReleaseCancelSpinLock(out_oldIrql_2);
    call {:si_unique_call 1676} sdv_KeReleaseSpinLock(0, out_controlIrql);
    goto anon78_Then, anon78_Else;

  anon78_Else:
    assume {:partition} out_setFirstStatus == 0;
    out_firstStatus := 0;
    out_setFirstStatus := 1;
    goto L45;

  anon78_Then:
    assume {:partition} out_setFirstStatus != 0;
    goto L45;

  anon104_Then:
    assume {:partition} out_ioControlCode != 1777688;
    call {:si_unique_call 1678} out_vslice_dummy_var_8 := KeSynchronizeExecution(0, li2bplFunctionConstant142, 0);
    goto L58;

  anon75_Then:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc vslice_dummy_var_1362;
    call {:si_unique_call 1668} out_sdv_17 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1362);
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} out_sdv_17 != 0;
    assume out_sdv_17 > 0;
    out_useTotalTimer := 0;
    out_returnWithWhatsPresent := 0;
    out_os2ssreturn := 0;
    out_crunchDownToOne := 0;
    out_useIntervalTimer := 0;
    call {:si_unique_call 1669} out_Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    Mem_T.INT4[out_Tmp_50] := out_controlIrql;
    call {:si_unique_call 1670} sdv_KeAcquireSpinLock(0, out_Tmp_50);
    goto anon105_Else;

  anon105_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    out_controlIrql := Mem_T.INT4[out_Tmp_50];
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    call {:si_unique_call 1667} sdv_KeReleaseSpinLock(0, out_controlIrql);
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    out_useIntervalTimer := 1;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    goto anon106_Then, anon106_Else;

  anon106_Else:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    goto L82;

  L82:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    goto L92;

  L92:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon87_Then, anon87_Else;

  anon87_Else:
    out_useTotalTimer := 1;
    out_os2ssreturn := 1;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    havoc out_multiplierVal;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    havoc out_constantVal;
    goto L99;

  L99:
    goto anon88_Then, anon88_Else;

  anon88_Else:
    assume {:partition} out_useTotalTimer != 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_totalTime_1 != 0;
    assume in_totalTime_1 > 0;
    goto L100;

  L100:
    call {:si_unique_call 1665} out_Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    Mem_T.INT4[out_Tmp_50] := out_controlIrql;
    call {:si_unique_call 1666} sdv_KeAcquireSpinLock(0, out_Tmp_50);
    goto anon107_Else;

  anon107_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    out_controlIrql := Mem_T.INT4[out_Tmp_50];
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc vslice_dummy_var_1361;
    call {:si_unique_call 1662} out_sdv_21 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1361);
    assume {:nonnull} out_sdv_21 != 0;
    assume out_sdv_21 > 0;
    call {:si_unique_call 1663} out_Tmp_50 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    Mem_T.INT4[out_Tmp_50] := out_oldIrql_2;
    call {:si_unique_call 1664} IoAcquireCancelSpinLock(out_Tmp_50);
    assume {:nonnull} out_Tmp_50 != 0;
    assume out_Tmp_50 > 0;
    out_oldIrql_2 := Mem_T.INT4[out_Tmp_50];
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_53;
    assume {:nonnull} out_Tmp_53 != 0;
    assume out_Tmp_53 > 0;
    goto anon108_Then, anon108_Else;

  anon108_Else:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_59;
    assume {:nonnull} out_Tmp_59 != 0;
    assume out_Tmp_59 > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_51;
    assume {:nonnull} out_Tmp_51 != 0;
    assume out_Tmp_51 > 0;
    call {:si_unique_call 1673} IoReleaseCancelSpinLock(out_oldIrql_2);
    call {:si_unique_call 1674} sdv_KeReleaseSpinLock(0, out_controlIrql);
    goto anon89_Then, anon89_Else;

  anon89_Else:
    assume {:partition} out_setFirstStatus == 0;
    out_firstStatus := -1073741536;
    out_setFirstStatus := 1;
    goto L45;

  anon89_Then:
    assume {:partition} out_setFirstStatus != 0;
    goto L45;

  anon108_Then:
    call {:si_unique_call 1661} out_vslice_dummy_var_10 := KeSynchronizeExecution(0, li2bplFunctionConstant143, 0);
    goto anon90_Then, anon90_Else;

  anon90_Else:
    assume {:partition} out_returnWithWhatsPresent != 0;
    goto L128;

  L128:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_49;
    assume {:nonnull} out_Tmp_49 != 0;
    assume out_Tmp_49 > 0;
    call {:si_unique_call 1671} IoReleaseCancelSpinLock(out_oldIrql_2);
    call {:si_unique_call 1672} sdv_KeReleaseSpinLock(0, out_controlIrql);
    goto anon92_Then, anon92_Else;

  anon92_Else:
    assume {:partition} out_setFirstStatus == 0;
    out_firstStatus := 0;
    out_setFirstStatus := 1;
    goto L45;

  anon92_Then:
    assume {:partition} out_setFirstStatus != 0;
    goto L45;

  anon90_Then:
    assume {:partition} out_returnWithWhatsPresent == 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    goto anon91_Then, anon91_Else;

  anon91_Else:
    goto anon93_Then, anon93_Else;

  anon93_Else:
    assume {:partition} out_os2ssreturn != 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_62;
    assume {:nonnull} out_Tmp_62 != 0;
    assume out_Tmp_62 > 0;
    goto anon109_Then, anon109_Else;

  anon109_Else:
    goto L139;

  L139:
    goto anon94_Then, anon94_Else;

  anon94_Else:
    assume {:partition} out_crunchDownToOne != 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc vslice_dummy_var_1360;
    call {:si_unique_call 1660} out_sdv_16 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1360);
    assume {:nonnull} out_sdv_16 != 0;
    assume out_sdv_16 > 0;
    goto L141;

  L141:
    call {:si_unique_call 1659} out_vslice_dummy_var_11 := KeSynchronizeExecution(0, li2bplFunctionConstant145, 0);
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    goto anon95_Then;

  anon95_Then:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    havoc out_Tmp_60;
    assume {:nonnull} out_Tmp_60 != 0;
    assume out_Tmp_60 > 0;
    call {:si_unique_call 1657} IoReleaseCancelSpinLock(out_oldIrql_2);
    call {:si_unique_call 1658} sdv_KeReleaseSpinLock(0, out_controlIrql);
    goto anon99_Then, anon99_Else;

  anon99_Else:
    assume {:partition} out_setFirstStatus == 0;
    out_firstStatus := 0;
    out_setFirstStatus := 1;
    goto L45;

  anon99_Then:
    assume {:partition} out_setFirstStatus != 0;
    goto L45;

  anon94_Then:
    assume {:partition} out_crunchDownToOne == 0;
    goto L141;

  anon109_Then:
    goto L128;

  anon93_Then:
    assume {:partition} out_os2ssreturn == 0;
    goto L139;

  anon91_Then:
    goto L128;

  anon88_Then:
    assume {:partition} out_useTotalTimer == 0;
    goto L100;

  anon87_Then:
    goto L93;

  L93:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon100_Then, anon100_Else;

  anon100_Else:
    out_useTotalTimer := 1;
    out_os2ssreturn := 1;
    out_crunchDownToOne := 1;
    out_multiplierVal := 0;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    havoc out_constantVal;
    goto L99;

  anon100_Then:
    goto L99;

  anon86_Then:
    goto L99;

  anon85_Then:
    goto L93;

  anon83_Then:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon84_Then, anon84_Else;

  anon84_Else:
    out_returnWithWhatsPresent := 1;
    goto L99;

  anon84_Then:
    goto L92;

  anon80_Then:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    goto L199;

  L199:
    out_useTotalTimer := 1;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    havoc out_multiplierVal;
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    havoc out_constantVal;
    goto L99;

  anon82_Then:
    assume {:nonnull} in_timeoutsForIrp != 0;
    assume in_timeoutsForIrp > 0;
    goto anon101_Then, anon101_Else;

  anon101_Else:
    goto L199;

  anon101_Then:
    goto L99;

  anon106_Then:
    assume {:nonnull} in_Extension_1 != 0;
    assume in_Extension_1 > 0;
    goto L82;

  anon81_Then:
    goto L82;

  anon79_Then:
    goto L82;
}



procedure {:LoopProcedure} MoxaStartRead_loop_L20(in_Tmp_49: int, in_Tmp_50: int, in_Tmp_51: int, in_Tmp_52: int, in_irpSp: int, in_totalTime_1: int, in_os2ssreturn: int, in_timeoutsForIrp: int, in_Tmp_53: int, in_Tmp_54: int, in_setFirstStatus: int, in_newIrp: int, in_useTotalTimer: int, in_multiplierVal: int, in_crunchDownToOne: int, in_sdv_16: int, in_sdv_17: int, in_oldIrql_2: int, in_Tmp_59: int, in_sdv_21: int, in_constantVal: int, in_Tmp_60: int, in_ioControlCode: int, in_Tmp_61: int, in_controlIrql: int, in_Tmp_62: int, in_returnWithWhatsPresent: int, in_useIntervalTimer: int, in_firstStatus: int, in_Extension_1: int, in_vslice_dummy_var_8: int, in_vslice_dummy_var_9: int, in_vslice_dummy_var_10: int, in_vslice_dummy_var_11: int) returns (out_Tmp_49: int, out_Tmp_50: int, out_Tmp_51: int, out_Tmp_52: int, out_irpSp: int, out_os2ssreturn: int, out_Tmp_53: int, out_Tmp_54: int, out_setFirstStatus: int, out_useTotalTimer: int, out_multiplierVal: int, out_crunchDownToOne: int, out_sdv_16: int, out_sdv_17: int, out_oldIrql_2: int, out_Tmp_59: int, out_sdv_21: int, out_constantVal: int, out_Tmp_60: int, out_ioControlCode: int, out_Tmp_61: int, out_controlIrql: int, out_Tmp_62: int, out_returnWithWhatsPresent: int, out_useIntervalTimer: int, out_firstStatus: int, out_vslice_dummy_var_8: int, out_vslice_dummy_var_9: int, out_vslice_dummy_var_10: int, out_vslice_dummy_var_11: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous_4) || sdv_irql_previous_2 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_previous_3) || sdv_irql_previous == old(sdv_irql_previous_4) || sdv_irql_previous == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_3) || sdv_irql_previous_4 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4) || sdv_irql_previous_3 == old(sdv_irql_previous_5);
  free ensures {:va_keep} out_os2ssreturn == 0 || out_os2ssreturn == 1 || out_os2ssreturn == in_os2ssreturn;
  free ensures {:va_keep} out_setFirstStatus == 1 || out_setFirstStatus == in_setFirstStatus;
  free ensures {:va_keep} out_useTotalTimer == 0 || out_useTotalTimer == 1 || out_useTotalTimer == in_useTotalTimer;
  free ensures {:va_keep} out_crunchDownToOne == 0 || out_crunchDownToOne == 1 || out_crunchDownToOne == in_crunchDownToOne;
  free ensures {:va_keep} out_returnWithWhatsPresent == 1 || out_returnWithWhatsPresent == 0 || out_returnWithWhatsPresent == in_returnWithWhatsPresent;
  free ensures {:va_keep} out_useIntervalTimer == 1 || out_useIntervalTimer == 0 || out_useIntervalTimer == in_useIntervalTimer;
  free ensures {:va_keep} out_firstStatus == -1073741536 || out_firstStatus == 0 || out_firstStatus == in_firstStatus;
  free ensures {:va_keep} out_vslice_dummy_var_8 == 1 || out_vslice_dummy_var_8 == 0 || out_vslice_dummy_var_8 == in_vslice_dummy_var_8;
  free ensures {:va_keep} out_vslice_dummy_var_9 == 1 || out_vslice_dummy_var_9 == 0 || out_vslice_dummy_var_9 == in_vslice_dummy_var_9;
  free ensures {:va_keep} out_vslice_dummy_var_10 == 1 || out_vslice_dummy_var_10 == 0 || out_vslice_dummy_var_10 == in_vslice_dummy_var_10;
  free ensures {:va_keep} out_vslice_dummy_var_11 == 1 || out_vslice_dummy_var_11 == 0 || out_vslice_dummy_var_11 == in_vslice_dummy_var_11;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L136(in_len: int, in_ndx: int, in_ofs_3: int, in_base: int, in_Fi: int, in_Tmp_238: int) returns (out_ndx: int, out_Tmp_238: int)
{
  var vslice_dummy_var_1363: int;

  entry:
    out_ndx, out_Tmp_238 := in_ndx, in_Tmp_238;
    goto L136, exit;

  exit:
    return;

  L136:
    goto anon537_Else;

  anon537_Else:
    assume {:partition} in_len > out_ndx;
    goto anon538_Else;

  anon538_Else:
    assume {:partition} out_ndx + in_ofs_3 < 16384;
    out_Tmp_238 := in_ofs_3 + out_ndx;
    assume {:nonnull} in_Fi != 0;
    assume in_Fi > 0;
    assume {:nonnull} in_base != 0;
    assume in_base > 0;
    havoc vslice_dummy_var_1363;
    Mem_T.INT4[in_base + out_Tmp_238 * 4] := vslice_dummy_var_1363;
    out_ndx := out_ndx + 1;
    goto anon538_Else_dummy;

  anon538_Else_dummy:
    call {:si_unique_call 1686} {:si_old_unique_call 1} out_ndx, out_Tmp_238 := MoxaIoControl_loop_L136(in_len, out_ndx, in_ofs_3, in_base, in_Fi, out_Tmp_238);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L136(in_len: int, in_ndx: int, in_ofs_3: int, in_base: int, in_Fi: int, in_Tmp_238: int) returns (out_ndx: int, out_Tmp_238: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L125(in_card_1: int, in_Gd_1: int, in_Tmp_144: int, in_Tmp_174: int, in_Fi: int) returns (out_card_1: int, out_Tmp_144: int, out_Tmp_174: int)
{

  entry:
    out_card_1, out_Tmp_144, out_Tmp_174 := in_card_1, in_Tmp_144, in_Tmp_174;
    goto L125, exit;

  exit:
    return;

  L125:
    assume {:CounterLoop 4} {:Counter "card_1"} true;
    goto anon535_Else;

  anon535_Else:
    assume {:partition} 4 > out_card_1;
    out_Tmp_144 := out_card_1;
    assume {:nonnull} in_Gd_1 != 0;
    assume in_Gd_1 > 0;
    havoc out_Tmp_174;
    assume {:nonnull} in_Fi != 0;
    assume in_Fi > 0;
    assume {:nonnull} out_Tmp_174 != 0;
    assume out_Tmp_174 > 0;
    goto anon764_Else;

  anon764_Else:
    out_card_1 := out_card_1 + 1;
    goto anon764_Else_dummy;

  anon764_Else_dummy:
    havoc out_card_1;
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L125(in_card_1: int, in_Gd_1: int, in_Tmp_144: int, in_Tmp_174: int, in_Fi: int) returns (out_card_1: int, out_Tmp_144: int, out_Tmp_174: int);
  free ensures {:va_keep} out_Tmp_144 == in_card_1 || out_Tmp_144 == in_Tmp_144;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L173(in_ofs_4: int, in_Tmp_187: int, in_Tmp_203: int, in_Wd: int, in_ndx_2: int, in_base_3: int, in_len_2: int, in_Tmp_257: int) returns (out_Tmp_187: int, out_Tmp_203: int, out_ndx_2: int, out_Tmp_257: int)
{

  entry:
    out_Tmp_187, out_Tmp_203, out_ndx_2, out_Tmp_257 := in_Tmp_187, in_Tmp_203, in_ndx_2, in_Tmp_257;
    goto L173, exit;

  exit:
    return;

  L173:
    goto anon542_Else;

  anon542_Else:
    assume {:partition} in_len_2 > out_ndx_2;
    goto anon543_Else;

  anon543_Else:
    assume {:partition} out_ndx_2 + in_ofs_4 < 16384;
    out_Tmp_187 := in_ofs_4 + out_ndx_2;
    out_Tmp_257 := out_ndx_2;
    assume {:nonnull} in_Wd != 0;
    assume in_Wd > 0;
    havoc out_Tmp_203;
    assume {:nonnull} out_Tmp_203 != 0;
    assume out_Tmp_203 > 0;
    assume {:nonnull} in_base_3 != 0;
    assume in_base_3 > 0;
    Mem_T.INT4[in_base_3 + out_Tmp_187 * 4] := Mem_T.INT4[out_Tmp_203 + out_Tmp_257 * 4];
    out_ndx_2 := out_ndx_2 + 1;
    goto anon543_Else_dummy;

  anon543_Else_dummy:
    call {:si_unique_call 1687} {:si_old_unique_call 1} out_Tmp_187, out_Tmp_203, out_ndx_2, out_Tmp_257 := MoxaIoControl_loop_L173(in_ofs_4, out_Tmp_187, out_Tmp_203, in_Wd, out_ndx_2, in_base_3, in_len_2, out_Tmp_257);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L173(in_ofs_4: int, in_Tmp_187: int, in_Tmp_203: int, in_Wd: int, in_ndx_2: int, in_base_3: int, in_len_2: int, in_Tmp_257: int) returns (out_Tmp_187: int, out_Tmp_203: int, out_ndx_2: int, out_Tmp_257: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L159(in_card: int, in_Gd_2: int, in_Tmp_179: int, in_Wd: int, in_Tmp_220: int) returns (out_card: int, out_Tmp_179: int, out_Tmp_220: int)
{

  entry:
    out_card, out_Tmp_179, out_Tmp_220 := in_card, in_Tmp_179, in_Tmp_220;
    goto L159, exit;

  exit:
    return;

  L159:
    assume {:CounterLoop 4} {:Counter "card"} true;
    goto anon540_Else;

  anon540_Else:
    assume {:partition} 4 > out_card;
    out_Tmp_179 := out_card;
    assume {:nonnull} in_Gd_2 != 0;
    assume in_Gd_2 > 0;
    havoc out_Tmp_220;
    assume {:nonnull} out_Tmp_220 != 0;
    assume out_Tmp_220 > 0;
    assume {:nonnull} in_Wd != 0;
    assume in_Wd > 0;
    goto anon761_Else;

  anon761_Else:
    out_card := out_card + 1;
    goto anon761_Else_dummy;

  anon761_Else_dummy:
    havoc out_card;
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L159(in_card: int, in_Gd_2: int, in_Tmp_179: int, in_Wd: int, in_Tmp_220: int) returns (out_card: int, out_Tmp_179: int, out_Tmp_220: int);
  free ensures {:va_keep} out_Tmp_179 == in_card || out_Tmp_179 == in_Tmp_179;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L212(in_Tmp_93: int, in_buff: int, in_len_1: int, in_Tmp_138: int, in_ofs_6: int, in_base_2: int, in_ndx_3: int) returns (out_Tmp_93: int, out_Tmp_138: int, out_ndx_3: int)
{

  entry:
    out_Tmp_93, out_Tmp_138, out_ndx_3 := in_Tmp_93, in_Tmp_138, in_ndx_3;
    goto L212, exit;

  exit:
    return;

  L212:
    goto anon547_Else;

  anon547_Else:
    assume {:partition} in_len_1 > out_ndx_3;
    goto anon548_Else;

  anon548_Else:
    assume {:partition} out_ndx_3 + in_ofs_6 < 16384;
    out_Tmp_93 := out_ndx_3;
    out_Tmp_138 := in_ofs_6 + out_ndx_3;
    assume {:nonnull} in_base_2 != 0;
    assume in_base_2 > 0;
    assume {:nonnull} in_buff != 0;
    assume in_buff > 0;
    Mem_T.INT4[in_buff + out_Tmp_93 * 4] := Mem_T.INT4[in_base_2 + out_Tmp_138 * 4];
    out_ndx_3 := out_ndx_3 + 1;
    goto anon548_Else_dummy;

  anon548_Else_dummy:
    call {:si_unique_call 1688} {:si_old_unique_call 1} out_Tmp_93, out_Tmp_138, out_ndx_3 := MoxaIoControl_loop_L212(out_Tmp_93, in_buff, in_len_1, out_Tmp_138, in_ofs_6, in_base_2, out_ndx_3);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L212(in_Tmp_93: int, in_buff: int, in_len_1: int, in_Tmp_138: int, in_ofs_6: int, in_base_2: int, in_ndx_3: int) returns (out_Tmp_93: int, out_Tmp_138: int, out_ndx_3: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L197(in_Bh: int, in_Tmp_100: int, in_card_3: int, in_Gd_5: int, in_Tmp_247: int) returns (out_Tmp_100: int, out_card_3: int, out_Tmp_247: int)
{

  entry:
    out_Tmp_100, out_card_3, out_Tmp_247 := in_Tmp_100, in_card_3, in_Tmp_247;
    goto L197, exit;

  exit:
    return;

  L197:
    assume {:CounterLoop 4} {:Counter "card_3"} true;
    goto anon545_Else;

  anon545_Else:
    assume {:partition} 4 > out_card_3;
    out_Tmp_247 := out_card_3;
    assume {:nonnull} in_Gd_5 != 0;
    assume in_Gd_5 > 0;
    havoc out_Tmp_100;
    assume {:nonnull} in_Bh != 0;
    assume in_Bh > 0;
    assume {:nonnull} out_Tmp_100 != 0;
    assume out_Tmp_100 > 0;
    goto anon758_Else;

  anon758_Else:
    out_card_3 := out_card_3 + 1;
    goto anon758_Else_dummy;

  anon758_Else_dummy:
    havoc out_card_3;
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L197(in_Bh: int, in_Tmp_100: int, in_card_3: int, in_Gd_5: int, in_Tmp_247: int) returns (out_Tmp_100: int, out_card_3: int, out_Tmp_247: int);
  free ensures {:va_keep} out_Tmp_247 == in_card_3 || out_Tmp_247 == in_Tmp_247;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 4} MoxaIoControl_loop_L230(in_Tmp_96: int, in_Tmp_106: int, in_Tmp_108: int, in_Tmp_131: int, in_Tmp_163: int, in_Gd_3: int, in_card_2: int, in_Ms: int, in_Tmp_193: int, in_Tmp_207: int, in_Tmp_231: int, in_Tmp_234: int, in_Tmp_240: int) returns (out_Tmp_96: int, out_Tmp_106: int, out_Tmp_108: int, out_Tmp_131: int, out_Tmp_163: int, out_card_2: int, out_Tmp_193: int, out_Tmp_207: int, out_Tmp_231: int, out_Tmp_234: int, out_Tmp_240: int)
{
  var vslice_dummy_var_1364: int;

  entry:
    out_Tmp_96, out_Tmp_106, out_Tmp_108, out_Tmp_131, out_Tmp_163, out_card_2, out_Tmp_193, out_Tmp_207, out_Tmp_231, out_Tmp_234, out_Tmp_240 := in_Tmp_96, in_Tmp_106, in_Tmp_108, in_Tmp_131, in_Tmp_163, in_card_2, in_Tmp_193, in_Tmp_207, in_Tmp_231, in_Tmp_234, in_Tmp_240;
    goto L230, exit;

  exit:
    return;

  L230:
    assume {:CounterLoop 4} {:Counter "card_2"} true;
    goto anon550_Else;

  anon550_Else:
    assume {:partition} 4 > out_card_2;
    out_Tmp_106 := out_card_2;
    assume {:nonnull} in_Gd_3 != 0;
    assume in_Gd_3 > 0;
    havoc out_Tmp_163;
    assume {:nonnull} out_Tmp_163 != 0;
    assume out_Tmp_163 > 0;
    goto anon756_Else;

  anon756_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_163 + out_Tmp_106 * 4] != 0;
    out_Tmp_108 := out_card_2;
    assume {:nonnull} in_Ms != 0;
    assume in_Ms > 0;
    havoc out_Tmp_131;
    out_Tmp_231 := out_card_2;
    assume {:nonnull} in_Gd_3 != 0;
    assume in_Gd_3 > 0;
    havoc out_Tmp_240;
    assume {:nonnull} out_Tmp_131 != 0;
    assume out_Tmp_131 > 0;
    assume {:nonnull} out_Tmp_240 != 0;
    assume out_Tmp_240 > 0;
    Mem_T.INT4[out_Tmp_131 + out_Tmp_108 * 4] := Mem_T.INT4[out_Tmp_240 + out_Tmp_231 * 4];
    out_Tmp_193 := out_card_2;
    assume {:nonnull} in_Ms != 0;
    assume in_Ms > 0;
    havoc out_Tmp_96;
    out_Tmp_207 := out_card_2;
    assume {:nonnull} in_Gd_3 != 0;
    assume in_Gd_3 > 0;
    havoc out_Tmp_234;
    assume {:nonnull} out_Tmp_234 != 0;
    assume out_Tmp_234 > 0;
    assume {:nonnull} out_Tmp_96 != 0;
    assume out_Tmp_96 > 0;
    havoc vslice_dummy_var_1364;
    Mem_T.INT4[out_Tmp_96 + out_Tmp_193 * 4] := vslice_dummy_var_1364;
    out_card_2 := out_card_2 + 1;
    goto anon756_Else_dummy;

  anon756_Else_dummy:
    call {:si_unique_call 1689} {:si_old_unique_call 1} out_Tmp_96, out_Tmp_106, out_Tmp_108, out_Tmp_131, out_Tmp_163, out_card_2, out_Tmp_193, out_Tmp_207, out_Tmp_231, out_Tmp_234, out_Tmp_240 := MoxaIoControl_loop_L230(out_Tmp_96, out_Tmp_106, out_Tmp_108, out_Tmp_131, out_Tmp_163, in_Gd_3, out_card_2, in_Ms, out_Tmp_193, out_Tmp_207, out_Tmp_231, out_Tmp_234, out_Tmp_240);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L230(in_Tmp_96: int, in_Tmp_106: int, in_Tmp_108: int, in_Tmp_131: int, in_Tmp_163: int, in_Gd_3: int, in_card_2: int, in_Ms: int, in_Tmp_193: int, in_Tmp_207: int, in_Tmp_231: int, in_Tmp_234: int, in_Tmp_240: int) returns (out_Tmp_96: int, out_Tmp_106: int, out_Tmp_108: int, out_Tmp_131: int, out_Tmp_163: int, out_card_2: int, out_Tmp_193: int, out_Tmp_207: int, out_Tmp_231: int, out_Tmp_234: int, out_Tmp_240: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L436(in_Tmp_84: int, in_Tmp_89: int, in_Tmp_94: int, in_Tmp_103: int, in_Tmp_104: int, in_Tmp_107: int, in_Tmp_114: int, in_nn: int, in_St: int, in_Tmp_128: int, in_Tmp_130: int, in_Tmp_136: int, in_Tmp_139: int, in_ndx_1: int, in_Tmp_140: int, in_Tmp_142: int, in_Tmp_147: int, in_Tmp_151: int, in_Tmp_154: int, in_Tmp_157: int, in_Tmp_159: int, in_Tmp_160: int, in_Tmp_162: int, in_Tmp_166: int, in_Tmp_167: int, in_Tmp_172: int, in_Tmp_182: int, in_Tmp_195: int, in_Tmp_199: int, in_Tmp_204: int, in_Tmp_210: int, in_Tmp_211: int, in_Tmp_219: int, in_Tmp_226: int, in_Tmp_241: int, in_comNo_1: int, in_Tmp_243: int, in_portNo_1: int, in_boogieTmp: int) returns (out_Tmp_84: int, out_Tmp_89: int, out_Tmp_94: int, out_Tmp_103: int, out_Tmp_104: int, out_Tmp_107: int, out_Tmp_114: int, out_nn: int, out_Tmp_128: int, out_Tmp_130: int, out_Tmp_136: int, out_Tmp_139: int, out_ndx_1: int, out_Tmp_140: int, out_Tmp_142: int, out_Tmp_147: int, out_Tmp_151: int, out_Tmp_154: int, out_Tmp_157: int, out_Tmp_159: int, out_Tmp_160: int, out_Tmp_162: int, out_Tmp_166: int, out_Tmp_167: int, out_Tmp_172: int, out_Tmp_182: int, out_Tmp_195: int, out_Tmp_199: int, out_Tmp_204: int, out_Tmp_210: int, out_Tmp_211: int, out_Tmp_219: int, out_Tmp_226: int, out_Tmp_241: int, out_Tmp_243: int, out_portNo_1: int, out_boogieTmp: int)
{

  entry:
    out_Tmp_84, out_Tmp_89, out_Tmp_94, out_Tmp_103, out_Tmp_104, out_Tmp_107, out_Tmp_114, out_nn, out_Tmp_128, out_Tmp_130, out_Tmp_136, out_Tmp_139, out_ndx_1, out_Tmp_140, out_Tmp_142, out_Tmp_147, out_Tmp_151, out_Tmp_154, out_Tmp_157, out_Tmp_159, out_Tmp_160, out_Tmp_162, out_Tmp_166, out_Tmp_167, out_Tmp_172, out_Tmp_182, out_Tmp_195, out_Tmp_199, out_Tmp_204, out_Tmp_210, out_Tmp_211, out_Tmp_219, out_Tmp_226, out_Tmp_241, out_Tmp_243, out_portNo_1, out_boogieTmp := in_Tmp_84, in_Tmp_89, in_Tmp_94, in_Tmp_103, in_Tmp_104, in_Tmp_107, in_Tmp_114, in_nn, in_Tmp_128, in_Tmp_130, in_Tmp_136, in_Tmp_139, in_ndx_1, in_Tmp_140, in_Tmp_142, in_Tmp_147, in_Tmp_151, in_Tmp_154, in_Tmp_157, in_Tmp_159, in_Tmp_160, in_Tmp_162, in_Tmp_166, in_Tmp_167, in_Tmp_172, in_Tmp_182, in_Tmp_195, in_Tmp_199, in_Tmp_204, in_Tmp_210, in_Tmp_211, in_Tmp_219, in_Tmp_226, in_Tmp_241, in_Tmp_243, in_portNo_1, in_boogieTmp;
    goto L436, exit;

  exit:
    return;

  L436:
    assume {:nonnull} in_comNo_1 != 0;
    assume in_comNo_1 > 0;
    goto anon567_Else;

  anon567_Else:
    assume {:partition} Mem_T.INT4[in_comNo_1 + 1 * 4] >= out_ndx_1;
    goto anon568_Else;

  anon568_Else:
    assume {:partition} out_ndx_1 <= 256;
    goto anon569_Then, anon569_Else;

  anon569_Else:
    assume {:partition} 0 >= out_ndx_1;
    goto L443;

  L443:
    out_ndx_1 := out_ndx_1 + 1;
    out_nn := out_nn + 1;
    goto L443_dummy;

  L443_dummy:
    call {:si_unique_call 1692} {:si_old_unique_call 1} out_Tmp_84, out_Tmp_89, out_Tmp_94, out_Tmp_103, out_Tmp_104, out_Tmp_107, out_Tmp_114, out_nn, out_Tmp_128, out_Tmp_130, out_Tmp_136, out_Tmp_139, out_ndx_1, out_Tmp_140, out_Tmp_142, out_Tmp_147, out_Tmp_151, out_Tmp_154, out_Tmp_157, out_Tmp_159, out_Tmp_160, out_Tmp_162, out_Tmp_166, out_Tmp_167, out_Tmp_172, out_Tmp_182, out_Tmp_195, out_Tmp_199, out_Tmp_204, out_Tmp_210, out_Tmp_211, out_Tmp_219, out_Tmp_226, out_Tmp_241, out_Tmp_243, out_portNo_1, out_boogieTmp := MoxaIoControl_loop_L436(out_Tmp_84, out_Tmp_89, out_Tmp_94, out_Tmp_103, out_Tmp_104, out_Tmp_107, out_Tmp_114, out_nn, in_St, out_Tmp_128, out_Tmp_130, out_Tmp_136, out_Tmp_139, out_ndx_1, out_Tmp_140, out_Tmp_142, out_Tmp_147, out_Tmp_151, out_Tmp_154, out_Tmp_157, out_Tmp_159, out_Tmp_160, out_Tmp_162, out_Tmp_166, out_Tmp_167, out_Tmp_172, out_Tmp_182, out_Tmp_195, out_Tmp_199, out_Tmp_204, out_Tmp_210, out_Tmp_211, out_Tmp_219, out_Tmp_226, out_Tmp_241, in_comNo_1, out_Tmp_243, out_portNo_1, out_boogieTmp);
    return;

  anon569_Then:
    assume {:partition} out_ndx_1 > 0;
    out_Tmp_157 := out_ndx_1;
    goto anon735_Then, anon735_Else;

  anon735_Else:
    out_Tmp_114 := out_ndx_1;
    havoc out_Tmp_104;
    assume {:nonnull} out_Tmp_104 != 0;
    assume out_Tmp_104 > 0;
    havoc out_portNo_1;
    out_Tmp_241 := out_nn;
    out_Tmp_103 := out_ndx_1;
    havoc out_Tmp_84;
    out_Tmp_107 := out_portNo_1;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    assume {:nonnull} out_Tmp_84 != 0;
    assume out_Tmp_84 > 0;
    out_Tmp_166 := out_nn;
    out_Tmp_154 := out_ndx_1;
    havoc out_Tmp_140;
    out_Tmp_160 := out_portNo_1;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    assume {:nonnull} out_Tmp_140 != 0;
    assume out_Tmp_140 > 0;
    out_Tmp_243 := out_ndx_1;
    havoc out_Tmp_94;
    assume {:nonnull} out_Tmp_94 != 0;
    assume out_Tmp_94 > 0;
    out_Tmp_142 := ModemStatus__MOXA_DEVICE_EXTENSION(out_Tmp_94);
    out_Tmp_211 := out_ndx_1;
    havoc out_Tmp_210;
    assume {:nonnull} out_Tmp_210 != 0;
    assume out_Tmp_210 > 0;
    havoc out_Tmp_89;
    call {:si_unique_call 1690} MoxaFuncGetLineStatus(out_Tmp_89, out_Tmp_142);
    out_Tmp_199 := out_nn;
    out_Tmp_195 := out_ndx_1;
    havoc out_Tmp_130;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    assume {:nonnull} out_Tmp_130 != 0;
    assume out_Tmp_130 > 0;
    out_Tmp_151 := out_portNo_1;
    out_Tmp_204 := out_nn;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    call {:si_unique_call 1691} out_boogieTmp := corral_nondet();
    out_Tmp_182 := out_ndx_1;
    havoc out_Tmp_219;
    assume {:nonnull} out_Tmp_219 != 0;
    assume out_Tmp_219 > 0;
    goto anon736_Then, anon736_Else;

  anon736_Else:
    out_Tmp_159 := out_nn;
    out_Tmp_172 := out_nn;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    goto L457;

  L457:
    out_Tmp_226 := out_ndx_1;
    havoc out_Tmp_139;
    assume {:nonnull} out_Tmp_139 != 0;
    assume out_Tmp_139 > 0;
    havoc out_Tmp_167;
    out_Tmp_162 := out_ndx_1;
    havoc out_Tmp_128;
    assume {:nonnull} out_Tmp_128 != 0;
    assume out_Tmp_128 > 0;
    havoc out_Tmp_147;
    out_Tmp_136 := out_nn;
    assume {:nonnull} in_St != 0;
    assume in_St > 0;
    goto L443;

  anon736_Then:
    goto L457;

  anon735_Then:
    goto L443;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L436(in_Tmp_84: int, in_Tmp_89: int, in_Tmp_94: int, in_Tmp_103: int, in_Tmp_104: int, in_Tmp_107: int, in_Tmp_114: int, in_nn: int, in_St: int, in_Tmp_128: int, in_Tmp_130: int, in_Tmp_136: int, in_Tmp_139: int, in_ndx_1: int, in_Tmp_140: int, in_Tmp_142: int, in_Tmp_147: int, in_Tmp_151: int, in_Tmp_154: int, in_Tmp_157: int, in_Tmp_159: int, in_Tmp_160: int, in_Tmp_162: int, in_Tmp_166: int, in_Tmp_167: int, in_Tmp_172: int, in_Tmp_182: int, in_Tmp_195: int, in_Tmp_199: int, in_Tmp_204: int, in_Tmp_210: int, in_Tmp_211: int, in_Tmp_219: int, in_Tmp_226: int, in_Tmp_241: int, in_comNo_1: int, in_Tmp_243: int, in_portNo_1: int, in_boogieTmp: int) returns (out_Tmp_84: int, out_Tmp_89: int, out_Tmp_94: int, out_Tmp_103: int, out_Tmp_104: int, out_Tmp_107: int, out_Tmp_114: int, out_nn: int, out_Tmp_128: int, out_Tmp_130: int, out_Tmp_136: int, out_Tmp_139: int, out_ndx_1: int, out_Tmp_140: int, out_Tmp_142: int, out_Tmp_147: int, out_Tmp_151: int, out_Tmp_154: int, out_Tmp_157: int, out_Tmp_159: int, out_Tmp_160: int, out_Tmp_162: int, out_Tmp_166: int, out_Tmp_167: int, out_Tmp_172: int, out_Tmp_182: int, out_Tmp_195: int, out_Tmp_199: int, out_Tmp_204: int, out_Tmp_210: int, out_Tmp_211: int, out_Tmp_219: int, out_Tmp_226: int, out_Tmp_241: int, out_Tmp_243: int, out_portNo_1: int, out_boogieTmp: int);
  modifies alloc, Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaIoControl_loop_L486(in_Tmp_85: int, in_port: int, in_cardNo: int, in_ext: int, in_portNo: int, in_ofs_2: int, in_Tmp_137: int, in_Tmp_152: int, in_Tmp_155: int, in_Tmp_205: int) returns (out_Tmp_85: int, out_port: int, out_ext: int, out_portNo: int, out_ofs_2: int, out_Tmp_137: int, out_Tmp_152: int, out_Tmp_155: int, out_Tmp_205: int)
{
  var vslice_dummy_var_1365: int;

  entry:
    out_Tmp_85, out_port, out_ext, out_portNo, out_ofs_2, out_Tmp_137, out_Tmp_152, out_Tmp_155, out_Tmp_205 := in_Tmp_85, in_port, in_ext, in_portNo, in_ofs_2, in_Tmp_137, in_Tmp_152, in_Tmp_155, in_Tmp_205;
    goto L486, exit;

  exit:
    return;

  L486:
    out_Tmp_85 := in_cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_152;
    assume {:nonnull} out_Tmp_152 != 0;
    assume out_Tmp_152 > 0;
    goto anon732_Else;

  anon732_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_152 + out_Tmp_85 * 4] > out_port;
    out_portNo := in_cardNo * 32 + out_port;
    out_Tmp_205 := out_portNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_137;
    assume {:nonnull} out_Tmp_137 != 0;
    assume out_Tmp_137 > 0;
    havoc out_ext;
    assume {:nonnull} out_ext != 0;
    assume out_ext > 0;
    havoc out_ofs_2;
    out_Tmp_155 := out_ofs_2;
    assume {:nonnull} out_Tmp_155 != 0;
    assume out_Tmp_155 > 0;
    havoc vslice_dummy_var_1365;
    Mem_T.INT4[out_Tmp_155] := vslice_dummy_var_1365;
    out_port := out_port + 1;
    goto anon732_Else_dummy;

  anon732_Else_dummy:
    call {:si_unique_call 1693} {:si_old_unique_call 1} out_Tmp_85, out_port, out_ext, out_portNo, out_ofs_2, out_Tmp_137, out_Tmp_152, out_Tmp_155, out_Tmp_205 := MoxaIoControl_loop_L486(out_Tmp_85, out_port, in_cardNo, out_ext, out_portNo, out_ofs_2, out_Tmp_137, out_Tmp_152, out_Tmp_155, out_Tmp_205);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L486(in_Tmp_85: int, in_port: int, in_cardNo: int, in_ext: int, in_portNo: int, in_ofs_2: int, in_Tmp_137: int, in_Tmp_152: int, in_Tmp_155: int, in_Tmp_205: int) returns (out_Tmp_85: int, out_port: int, out_ext: int, out_portNo: int, out_ofs_2: int, out_Tmp_137: int, out_Tmp_152: int, out_Tmp_155: int, out_Tmp_205: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} out_Tmp_85 == in_Tmp_85 || out_Tmp_85 == in_cardNo;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 5} MoxaIoControl_loop_L481(in_Tmp_85: int, in_port: int, in_cardNo: int, in_ext: int, in_portNo: int, in_Tmp_125: int, in_ofs_2: int, in_Tmp_137: int, in_Tmp_141: int, in_Tmp_152: int, in_Tmp_155: int, in_Tmp_183: int, in_Tmp_184: int, in_Tmp_205: int) returns (out_Tmp_85: int, out_port: int, out_cardNo: int, out_ext: int, out_portNo: int, out_Tmp_125: int, out_ofs_2: int, out_Tmp_137: int, out_Tmp_141: int, out_Tmp_152: int, out_Tmp_155: int, out_Tmp_183: int, out_Tmp_184: int, out_Tmp_205: int)
{
  var vslice_dummy_var_1366: int;

  entry:
    out_Tmp_85, out_port, out_cardNo, out_ext, out_portNo, out_Tmp_125, out_ofs_2, out_Tmp_137, out_Tmp_141, out_Tmp_152, out_Tmp_155, out_Tmp_183, out_Tmp_184, out_Tmp_205 := in_Tmp_85, in_port, in_cardNo, in_ext, in_portNo, in_Tmp_125, in_ofs_2, in_Tmp_137, in_Tmp_141, in_Tmp_152, in_Tmp_155, in_Tmp_183, in_Tmp_184, in_Tmp_205;
    goto L481, exit;

  exit:
    return;

  L481:
    assume {:CounterLoop 4} {:Counter "cardNo"} true;
    goto anon573_Else;

  anon573_Else:
    assume {:partition} 4 > out_cardNo;
    out_Tmp_125 := out_cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_184;
    assume {:nonnull} out_Tmp_184 != 0;
    assume out_Tmp_184 > 0;
    goto anon730_Then, anon730_Else;

  anon730_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_184 + out_Tmp_125 * 4] == 0;
    goto L487;

  L487:
    out_cardNo := out_cardNo + 1;
    goto L487_dummy;

  L487_dummy:
    call {:si_unique_call 1695} {:si_old_unique_call 1} out_Tmp_85, out_port, out_cardNo, out_ext, out_portNo, out_Tmp_125, out_ofs_2, out_Tmp_137, out_Tmp_141, out_Tmp_152, out_Tmp_155, out_Tmp_183, out_Tmp_184, out_Tmp_205 := MoxaIoControl_loop_L481(out_Tmp_85, out_port, out_cardNo, out_ext, out_portNo, out_Tmp_125, out_ofs_2, out_Tmp_137, out_Tmp_141, out_Tmp_152, out_Tmp_155, out_Tmp_183, out_Tmp_184, out_Tmp_205);
    return;

  anon730_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_184 + out_Tmp_125 * 4] != 0;
    out_Tmp_183 := out_cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_141;
    assume {:nonnull} out_Tmp_141 != 0;
    assume out_Tmp_141 > 0;
    goto anon731_Then, anon731_Else;

  anon731_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_141 + out_Tmp_183 * 4] == 0;
    goto L487;

  anon731_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_141 + out_Tmp_183 * 4] != 0;
    out_port := 0;
    goto L486;

  L486:
    call {:si_unique_call 1694} out_Tmp_85, out_port, out_ext, out_portNo, out_ofs_2, out_Tmp_137, out_Tmp_152, out_Tmp_155, out_Tmp_205 := MoxaIoControl_loop_L486(out_Tmp_85, out_port, out_cardNo, out_ext, out_portNo, out_ofs_2, out_Tmp_137, out_Tmp_152, out_Tmp_155, out_Tmp_205);
    goto L486_last;

  L486_last:
    out_Tmp_85 := out_cardNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_152;
    assume {:nonnull} out_Tmp_152 != 0;
    assume out_Tmp_152 > 0;
    goto anon732_Then, anon732_Else;

  anon732_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_152 + out_Tmp_85 * 4] > out_port;
    out_portNo := out_cardNo * 32 + out_port;
    out_Tmp_205 := out_portNo;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_137;
    assume {:nonnull} out_Tmp_137 != 0;
    assume out_Tmp_137 > 0;
    havoc out_ext;
    assume {:nonnull} out_ext != 0;
    assume out_ext > 0;
    havoc out_ofs_2;
    out_Tmp_155 := out_ofs_2;
    assume {:nonnull} out_Tmp_155 != 0;
    assume out_Tmp_155 > 0;
    havoc vslice_dummy_var_1366;
    Mem_T.INT4[out_Tmp_155] := vslice_dummy_var_1366;
    out_port := out_port + 1;
    assume false;
    return;

  anon732_Then:
    assume {:partition} out_port >= Mem_T.INT4[out_Tmp_152 + out_Tmp_85 * 4];
    goto L487;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L481(in_Tmp_85: int, in_port: int, in_cardNo: int, in_ext: int, in_portNo: int, in_Tmp_125: int, in_ofs_2: int, in_Tmp_137: int, in_Tmp_141: int, in_Tmp_152: int, in_Tmp_155: int, in_Tmp_183: int, in_Tmp_184: int, in_Tmp_205: int) returns (out_Tmp_85: int, out_port: int, out_cardNo: int, out_ext: int, out_portNo: int, out_Tmp_125: int, out_ofs_2: int, out_Tmp_137: int, out_Tmp_141: int, out_Tmp_152: int, out_Tmp_155: int, out_Tmp_183: int, out_Tmp_184: int, out_Tmp_205: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 6} MoxaIoControl_loop_L673(in_i: int, in_Tmp_148: int, in_ofs_5: int, in_Tmp_191: int, in_newChars: int, in_Tmp_251: int) returns (out_i: int, out_Tmp_148: int, out_Tmp_191: int, out_Tmp_251: int)
{

  entry:
    out_i, out_Tmp_148, out_Tmp_191, out_Tmp_251 := in_i, in_Tmp_148, in_Tmp_191, in_Tmp_251;
    goto L673, exit;

  exit:
    return;

  L673:
    assume {:CounterLoop 6} {:Counter "i"} true;
    goto anon591_Else;

  anon591_Else:
    assume {:partition} 6 > out_i;
    out_Tmp_251 := out_i;
    out_Tmp_191 := out_i;
    out_Tmp_148 := in_newChars;
    assume {:nonnull} out_Tmp_148 != 0;
    assume out_Tmp_148 > 0;
    assume {:nonnull} in_ofs_5 != 0;
    assume in_ofs_5 > 0;
    Mem_T.INT4[in_ofs_5 + out_Tmp_251 * 4] := Mem_T.INT4[out_Tmp_148 + out_Tmp_191 * 4];
    out_i := out_i + 1;
    goto anon591_Else_dummy;

  anon591_Else_dummy:
    call {:si_unique_call 1696} {:si_old_unique_call 1} out_i, out_Tmp_148, out_Tmp_191, out_Tmp_251 := MoxaIoControl_loop_L673(out_i, out_Tmp_148, in_ofs_5, out_Tmp_191, in_newChars, out_Tmp_251);
    return;
}



procedure {:LoopProcedure} MoxaIoControl_loop_L673(in_i: int, in_Tmp_148: int, in_ofs_5: int, in_Tmp_191: int, in_newChars: int, in_Tmp_251: int) returns (out_i: int, out_Tmp_148: int, out_Tmp_191: int, out_Tmp_251: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} out_Tmp_148 == in_Tmp_148 || out_Tmp_148 == in_newChars;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaClose_loop_L85(in_count_3: int, in_count1: int, in_allSentDelay: int, in_sdv_69: int, in_extension_7: int, in_boogieTmp: int, in_vslice_dummy_var_38: int) returns (out_count_3: int, out_count1: int, out_sdv_69: int, out_boogieTmp: int, out_vslice_dummy_var_38: int)
{

  entry:
    out_count_3, out_count1, out_sdv_69, out_boogieTmp, out_vslice_dummy_var_38 := in_count_3, in_count1, in_sdv_69, in_boogieTmp, in_vslice_dummy_var_38;
    goto L85, exit;

  exit:
    return;

  L85:
    call {:si_unique_call 1697} out_sdv_69 := GetDeviceTxQueueWithLock(in_extension_7);
    goto anon46_Else;

  anon46_Else:
    assume {:partition} yogi_error != 1;
    out_count_3 := out_sdv_69;
    assume {:nonnull} in_extension_7 != 0;
    assume in_extension_7 > 0;
    havoc out_count_3;
    goto anon47_Else;

  anon47_Else:
    assume {:partition} out_count_3 != out_count1;
    out_count1 := out_count_3;
    assume {:nonnull} in_allSentDelay != 0;
    assume in_allSentDelay > 0;
    call {:si_unique_call 1698} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_allSentDelay != 0;
    assume in_allSentDelay > 0;
    call {:si_unique_call 1699} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_allSentDelay != 0;
    assume in_allSentDelay > 0;
    call {:si_unique_call 1700} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_allSentDelay != 0;
    assume in_allSentDelay > 0;
    call {:si_unique_call 1701} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_allSentDelay != 0;
    assume in_allSentDelay > 0;
    call {:si_unique_call 1702} out_boogieTmp := corral_nondet();
    call {:si_unique_call 1703} out_vslice_dummy_var_38 := KeDelayExecutionThread(0, 1, 0);
    goto anon47_Else_dummy;

  anon47_Else_dummy:
    call {:si_unique_call 1704} {:si_old_unique_call 1} out_count_3, out_count1, out_sdv_69, out_boogieTmp, out_vslice_dummy_var_38 := MoxaClose_loop_L85(out_count_3, out_count1, in_allSentDelay, out_sdv_69, in_extension_7, out_boogieTmp, out_vslice_dummy_var_38);
    return;
}



procedure {:LoopProcedure} MoxaClose_loop_L85(in_count_3: int, in_count1: int, in_allSentDelay: int, in_sdv_69: int, in_extension_7: int, in_boogieTmp: int, in_vslice_dummy_var_38: int) returns (out_count_3: int, out_count1: int, out_sdv_69: int, out_boogieTmp: int, out_vslice_dummy_var_38: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} out_vslice_dummy_var_38 == 0 || out_vslice_dummy_var_38 == -1073741823 || out_vslice_dummy_var_38 == in_vslice_dummy_var_38;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaDelTimeOutProc_loop_L7(in_prev: int, in_next_1: int, in_extension_11: int) returns (out_prev: int, out_next_1: int)
{

  entry:
    out_prev, out_next_1 := in_prev, in_next_1;
    goto L7, exit;

  exit:
    return;

  L7:
    goto anon11_Else;

  anon11_Else:
    assume {:partition} out_next_1 != 0;
    assume {:nonnull} out_next_1 != 0;
    assume out_next_1 > 0;
    goto anon13_Else;

  anon13_Else:
    out_prev := out_next_1;
    assume {:nonnull} out_prev != 0;
    assume out_prev > 0;
    havoc out_next_1;
    goto anon13_Else_dummy;

  anon13_Else_dummy:
    call {:si_unique_call 1705} {:si_old_unique_call 1} out_prev, out_next_1 := MoxaDelTimeOutProc_loop_L7(out_prev, out_next_1, in_extension_11);
    return;
}



procedure {:LoopProcedure} MoxaDelTimeOutProc_loop_L7(in_prev: int, in_next_1: int, in_extension_11: int) returns (out_prev: int, out_next_1: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaISR_loop_L62(in_modemStatus: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_irpSp_3: int, in_Tmp_338: int, in_Tmp_341: int, in_globalData: int, in_change: int, in_port_1: int, in_Tmp_344: int, in_ip: int, in_Tmp_347: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_extension_15: int, in_dataError: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_332: int, out_Tmp_333: int, out_Tmp_336: int, out_Tmp_337: int, out_irpSp_3: int, out_Tmp_338: int, out_Tmp_341: int, out_change: int, out_port_1: int, out_Tmp_344: int, out_Tmp_347: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_extension_15: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int)
{
  var vslice_dummy_var_1367: int;
  var vslice_dummy_var_1368: int;
  var vslice_dummy_var_1369: int;
  var vslice_dummy_var_1370: int;

  entry:
    out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_change, out_port_1, out_Tmp_344, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := in_Tmp_332, in_Tmp_333, in_Tmp_336, in_Tmp_337, in_irpSp_3, in_Tmp_338, in_Tmp_341, in_change, in_port_1, in_Tmp_344, in_Tmp_347, in_Tmp_351, in_Tmp_352, in_temp, in_Tmp_361, in_Tmp_362, in_portNo_2, in_extension_15, in_vslice_dummy_var_56, in_vslice_dummy_var_57, in_vslice_dummy_var_58, in_vslice_dummy_var_59, in_vslice_dummy_var_60, in_vslice_dummy_var_61;
    goto L62, exit;

  exit:
    return;

  L62:
    out_Tmp_352 := in_boardNo;
    assume {:nonnull} in_globalData != 0;
    assume in_globalData > 0;
    havoc out_Tmp_362;
    assume {:nonnull} out_Tmp_362 != 0;
    assume out_Tmp_362 > 0;
    goto anon157_Else;

  anon157_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_362 + out_Tmp_352 * 4] > out_port_1;
    out_portNo_2 := in_boardNo * 32 + out_port_1;
    out_Tmp_333 := out_portNo_2;
    assume {:nonnull} in_globalData != 0;
    assume in_globalData > 0;
    havoc out_Tmp_344;
    assume {:nonnull} out_Tmp_344 != 0;
    assume out_Tmp_344 > 0;
    havoc out_extension_15;
    goto anon158_Then, anon158_Else;

  anon158_Else:
    assume {:partition} out_extension_15 == 0;
    goto L70;

  L70:
    out_port_1 := out_port_1 + 1;
    goto L70_dummy;

  L70_dummy:
    call {:si_unique_call 1716} {:si_old_unique_call 1} out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_change, out_port_1, out_Tmp_344, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L62(in_modemStatus, out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, in_boardNo, out_irpSp_3, out_Tmp_338, out_Tmp_341, in_globalData, out_change, out_port_1, out_Tmp_344, in_ip, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, in_dataError, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    return;

  anon158_Then:
    assume {:partition} out_extension_15 != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_337;
    assume {:nonnull} in_ip != 0;
    assume in_ip > 0;
    out_temp := Mem_T.INT4[in_ip + out_Tmp_337 * 4];
    goto anon159_Then, anon159_Else;

  anon159_Else:
    assume {:partition} out_temp != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_347;
    assume {:nonnull} in_ip != 0;
    assume in_ip > 0;
    Mem_T.INT4[in_ip + out_Tmp_347 * 4] := 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon160_Then, anon160_Else;

  anon160_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon117_Then, anon117_Else;

  anon117_Else:
    goto anon118_Then, anon118_Else;

  anon118_Else:
    assume {:partition} BAND(out_temp, 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon120_Then, anon120_Else;

  anon120_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon121_Then, anon121_Else;

  anon121_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1708} out_vslice_dummy_var_60 := MoxaInsertQueueDpc#1(IsrOutDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon168_Else;

  anon168_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  L76:
    goto anon119_Then, anon119_Else;

  anon119_Else:
    assume {:partition} BAND(out_temp, 256) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon123_Then, anon123_Else;

  anon123_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon124_Then, anon124_Else;

  anon124_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1709} out_vslice_dummy_var_59 := MoxaInsertQueueDpc#1(IsrInDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon167_Else;

  anon167_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  L93:
    goto anon122_Then, anon122_Else;

  anon122_Else:
    assume {:partition} BAND(out_temp, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon126_Then, anon126_Else;

  anon126_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L100;

  L100:
    goto anon125_Then, anon125_Else;

  anon125_Else:
    assume {:partition} BAND(out_temp, 32) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon128_Then, anon128_Else;

  anon128_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L103;

  L103:
    goto anon127_Then, anon127_Else;

  anon127_Else:
    assume {:partition} BAND(out_temp, 64) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon130_Then, anon130_Else;

  anon130_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L106;

  L106:
    goto anon129_Then, anon129_Else;

  anon129_Else:
    assume {:partition} BAND(out_temp, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon161_Then, anon161_Else;

  anon161_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L112;

  L112:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon132_Then, anon132_Else;

  anon132_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1710} out_vslice_dummy_var_56 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon162_Else;

  anon162_Else:
    assume {:partition} yogi_error != 1;
    goto L109;

  L109:
    goto anon131_Then, anon131_Else;

  anon131_Else:
    assume {:partition} BAND(out_temp, 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1368;
    call {:si_unique_call 1711} MoxaFuncGetLineStatus(vslice_dummy_var_1368, in_modemStatus);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon134_Then, anon134_Else;

  anon134_Else:
    call {:si_unique_call 1712} out_change := corral_nondet();
    goto anon163_Then, anon163_Else;

  anon163_Else:
    assume {:partition} BAND(out_change, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon136_Then, anon136_Else;

  anon136_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L127;

  L127:
    goto anon135_Then, anon135_Else;

  anon135_Else:
    assume {:partition} BAND(out_change, 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon138_Then, anon138_Else;

  anon138_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L130;

  L130:
    goto anon137_Then, anon137_Else;

  anon137_Else:
    assume {:partition} BAND(out_change, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon139_Then, anon139_Else;

  anon139_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L123;

  L123:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} in_modemStatus != 0;
    assume in_modemStatus > 0;
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(out_extension_15)] := Mem_T.INT4[in_modemStatus];
    goto L117;

  L117:
    goto anon133_Then, anon133_Else;

  anon133_Else:
    assume {:partition} BAND(out_temp, 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1369;
    call {:si_unique_call 1713} MoxaFuncGetDataError(vslice_dummy_var_1369, in_dataError);
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon141_Then, anon141_Else;

  anon141_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L141;

  L141:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon142_Then, anon142_Else;

  anon142_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L143;

  L143:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon143_Then, anon143_Else;

  anon143_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L145;

  L145:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon144_Then, anon144_Else;

  anon144_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L147;

  L147:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon164_Then, anon164_Else;

  anon164_Else:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon146_Then, anon146_Else;

  anon146_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L150;

  L150:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon145_Then, anon145_Else;

  anon145_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1714} out_vslice_dummy_var_57 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon165_Else;

  anon165_Else:
    assume {:partition} yogi_error != 1;
    goto L135;

  L135:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon140_Then, anon140_Else;

  anon140_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon147_Then, anon147_Else;

  anon147_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_336;
    assume {:nonnull} out_Tmp_336 != 0;
    assume out_Tmp_336 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1370;
    Mem_T.INT4[out_Tmp_336] := vslice_dummy_var_1370;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_332;
    assume {:nonnull} out_Tmp_332 != 0;
    assume out_Tmp_332 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1715} out_vslice_dummy_var_58 := MoxaInsertQueueDpc#1(CommWaitDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon166_Else;

  anon166_Else:
    assume {:partition} yogi_error != 1;
    goto L70;

  anon147_Then:
    goto L70;

  anon140_Then:
    goto L70;

  anon145_Then:
    goto L135;

  anon146_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) == 0;
    goto L150;

  anon164_Then:
    goto L150;

  anon144_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) == 0;
    goto L147;

  anon143_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) == 0;
    goto L145;

  anon142_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) == 0;
    goto L143;

  anon141_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) == 0;
    goto L141;

  anon133_Then:
    assume {:partition} BAND(out_temp, 4) == 0;
    goto L135;

  anon139_Then:
    goto L123;

  anon137_Then:
    assume {:partition} BAND(out_change, 8) == 0;
    goto L123;

  anon138_Then:
    goto L130;

  anon135_Then:
    assume {:partition} BAND(out_change, 2) == 0;
    goto L130;

  anon136_Then:
    goto L127;

  anon163_Then:
    assume {:partition} BAND(out_change, 1) == 0;
    goto L127;

  anon134_Then:
    goto L123;

  anon131_Then:
    assume {:partition} BAND(out_temp, 16) == 0;
    goto L117;

  anon132_Then:
    goto L109;

  anon161_Then:
    goto L112;

  anon129_Then:
    assume {:partition} BAND(out_temp, 8) == 0;
    goto L109;

  anon130_Then:
    goto L106;

  anon127_Then:
    assume {:partition} BAND(out_temp, 64) == 0;
    goto L106;

  anon128_Then:
    goto L103;

  anon125_Then:
    assume {:partition} BAND(out_temp, 32) == 0;
    goto L103;

  anon126_Then:
    goto L100;

  anon122_Then:
    assume {:partition} BAND(out_temp, 1) == 0;
    goto L100;

  anon124_Then:
    goto L93;

  anon123_Then:
    goto L93;

  anon119_Then:
    assume {:partition} BAND(out_temp, 256) == 0;
    goto L93;

  anon121_Then:
    goto L76;

  anon120_Then:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_341;
    assume {:nonnull} out_Tmp_341 != 0;
    assume out_Tmp_341 > 0;
    goto anon169_Then, anon169_Else;

  anon169_Else:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_338;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_351;
    assume {:nonnull} out_Tmp_338 != 0;
    assume out_Tmp_338 > 0;
    assume {:nonnull} out_Tmp_351 != 0;
    assume out_Tmp_351 > 0;
    Mem_T.INT4[out_Tmp_338] := BAND(Mem_T.INT4[out_Tmp_351], BNOT(BOR(2, 512)));
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1367;
    call {:si_unique_call 1706} out_irpSp_3 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1367);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_361;
    assume {:nonnull} out_Tmp_361 != 0;
    assume out_Tmp_361 > 0;
    assume {:nonnull} out_irpSp_3 != 0;
    assume out_irpSp_3 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1707} out_vslice_dummy_var_61 := MoxaInsertQueueDpc#1(CompleteWriteDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon170_Else;

  anon170_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  anon169_Then:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) == 0;
    goto L76;

  anon118_Then:
    assume {:partition} BAND(out_temp, 514) == 0;
    goto L76;

  anon117_Then:
    goto L70;

  anon160_Then:
    goto L70;

  anon159_Then:
    assume {:partition} out_temp == 0;
    goto L70;
}



procedure {:LoopProcedure} MoxaISR_loop_L62(in_modemStatus: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_irpSp_3: int, in_Tmp_338: int, in_Tmp_341: int, in_globalData: int, in_change: int, in_port_1: int, in_Tmp_344: int, in_ip: int, in_Tmp_347: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_extension_15: int, in_dataError: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_332: int, out_Tmp_333: int, out_Tmp_336: int, out_Tmp_337: int, out_irpSp_3: int, out_Tmp_338: int, out_Tmp_341: int, out_change: int, out_port_1: int, out_Tmp_344: int, out_Tmp_347: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_extension_15: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int);
  modifies Mem_T.INT4, alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} out_Tmp_352 == in_Tmp_352 || out_Tmp_352 == in_boardNo;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaISR_loop_L30(in_modemStatus: int, in_Tmp_331: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_335: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_ack: int, in_irpSp_3: int, in_Tmp_338: int, in_interruptEntry: int, in_dispatch: int, in_Tmp_339: int, in_Tmp_340: int, in_Tmp_341: int, in_globalData: int, in_cisrsw: int, in_change: int, in_Tmp_342: int, in_Tmp_343: int, in_port_1: int, in_Tmp_344: int, in_Tmp_345: int, in_ip: int, in_Tmp_346: int, in_Tmp_347: int, in_Tmp_348: int, in_sdv_96: int, in_Tmp_349: int, in_Tmp_350: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_353: int, in_Tmp_355: int, in_Tmp_356: int, in_Tmp_357: int, in_Tmp_358: int, in_Tmp_359: int, in_Tmp_360: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_Tmp_364: int, in_Tmp_365: int, in_thisPassServiced: int, in_extension_15: int, in_Tmp_366: int, in_servicedAnInterrupt: int, in_dataError: int, in_Tmp_367: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_331: int, out_Tmp_332: int, out_Tmp_333: int, out_Tmp_335: int, out_Tmp_336: int, out_Tmp_337: int, out_boardNo: int, out_ack: int, out_irpSp_3: int, out_Tmp_338: int, out_interruptEntry: int, out_dispatch: int, out_Tmp_339: int, out_Tmp_340: int, out_Tmp_341: int, out_globalData: int, out_cisrsw: int, out_change: int, out_Tmp_342: int, out_Tmp_343: int, out_port_1: int, out_Tmp_344: int, out_Tmp_345: int, out_ip: int, out_Tmp_346: int, out_Tmp_347: int, out_Tmp_348: int, out_sdv_96: int, out_Tmp_349: int, out_Tmp_350: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_353: int, out_Tmp_355: int, out_Tmp_356: int, out_Tmp_357: int, out_Tmp_358: int, out_Tmp_359: int, out_Tmp_360: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_Tmp_364: int, out_Tmp_365: int, out_thisPassServiced: int, out_extension_15: int, out_Tmp_366: int, out_servicedAnInterrupt: int, out_Tmp_367: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int)
{
  var vslice_dummy_var_1371: int;
  var vslice_dummy_var_1372: int;
  var vslice_dummy_var_1373: int;
  var vslice_dummy_var_1374: int;

  entry:
    out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := in_Tmp_331, in_Tmp_332, in_Tmp_333, in_Tmp_335, in_Tmp_336, in_Tmp_337, in_boardNo, in_ack, in_irpSp_3, in_Tmp_338, in_interruptEntry, in_dispatch, in_Tmp_339, in_Tmp_340, in_Tmp_341, in_globalData, in_cisrsw, in_change, in_Tmp_342, in_Tmp_343, in_port_1, in_Tmp_344, in_Tmp_345, in_ip, in_Tmp_346, in_Tmp_347, in_Tmp_348, in_sdv_96, in_Tmp_349, in_Tmp_350, in_Tmp_351, in_Tmp_352, in_temp, in_Tmp_353, in_Tmp_355, in_Tmp_356, in_Tmp_357, in_Tmp_358, in_Tmp_359, in_Tmp_360, in_Tmp_361, in_Tmp_362, in_portNo_2, in_Tmp_364, in_Tmp_365, in_thisPassServiced, in_extension_15, in_Tmp_366, in_servicedAnInterrupt, in_Tmp_367, in_vslice_dummy_var_56, in_vslice_dummy_var_57, in_vslice_dummy_var_58, in_vslice_dummy_var_59, in_vslice_dummy_var_60, in_vslice_dummy_var_61;
    goto L30, exit;

  exit:
    return;

  L30:
    call {:si_unique_call 1717} out_sdv_96 := sdv_containing_record(out_interruptEntry, 8);
    out_cisrsw := out_sdv_96;
    goto anon150_Else;

  anon150_Else:
    assume {:partition} out_cisrsw != 0;
    assume {:nonnull} out_cisrsw != 0;
    assume out_cisrsw > 0;
    out_dispatch := Dispatch__MOXA_CISR_SW(out_cisrsw);
    assume {:nonnull} out_dispatch != 0;
    assume out_dispatch > 0;
    havoc out_globalData;
    assume {:nonnull} out_dispatch != 0;
    assume out_dispatch > 0;
    havoc out_boardNo;
    goto anon151_Else;

  anon151_Else:
    assume {:partition} out_globalData != 0;
    goto anon116_Else;

  anon116_Else:
    assume {:partition} 0 <= out_boardNo;
    out_Tmp_355 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_366;
    assume {:nonnull} out_Tmp_366 != 0;
    assume out_Tmp_366 > 0;
    goto anon152_Then, anon152_Else;

  anon152_Else:
    out_Tmp_331 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_346;
    assume {:nonnull} out_Tmp_346 != 0;
    assume out_Tmp_346 > 0;
    call {:si_unique_call 1718} out_ack := corral_nondet();
    out_ack := BOR(out_ack, 4);
    out_Tmp_343 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_356;
    assume {:nonnull} out_Tmp_356 != 0;
    assume out_Tmp_356 > 0;
    goto L43;

  L43:
    out_Tmp_345 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_365;
    assume {:nonnull} out_Tmp_365 != 0;
    assume out_Tmp_365 > 0;
    goto anon153_Then, anon153_Else;

  anon153_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_365 + out_Tmp_345 * 4] == 1;
    out_Tmp_367 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_360;
    assume {:nonnull} out_Tmp_360 != 0;
    assume out_Tmp_360 > 0;
    havoc out_Tmp_353;
    assume {:nonnull} out_Tmp_353 != 0;
    assume out_Tmp_353 > 0;
    goto anon154_Then, anon154_Else;

  anon154_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_353] == 255;
    out_Tmp_342 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_358;
    assume {:nonnull} out_Tmp_358 != 0;
    assume out_Tmp_358 > 0;
    havoc out_Tmp_339;
    assume {:nonnull} out_Tmp_339 != 0;
    assume out_Tmp_339 > 0;
    goto anon155_Then, anon155_Else;

  anon155_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_339] != 0;
    out_Tmp_349 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_359;
    assume {:nonnull} out_Tmp_359 != 0;
    assume out_Tmp_359 > 0;
    havoc out_Tmp_348;
    assume {:nonnull} out_Tmp_348 != 0;
    assume out_Tmp_348 > 0;
    goto anon156_Then, anon156_Else;

  anon156_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_348] == 128;
    goto L57;

  L57:
    out_servicedAnInterrupt := 1;
    out_thisPassServiced := 1;
    out_Tmp_357 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_364;
    assume {:nonnull} out_Tmp_364 != 0;
    assume out_Tmp_364 > 0;
    havoc out_ip;
    out_port_1 := 0;
    goto L62;

  L62:
    call {:si_unique_call 1719} out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_change, out_port_1, out_Tmp_344, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L62(in_modemStatus, out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_boardNo, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_globalData, out_change, out_port_1, out_Tmp_344, out_ip, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, in_dataError, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    goto L62_last;

  L62_last:
    out_Tmp_352 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_362;
    assume {:nonnull} out_Tmp_362 != 0;
    assume out_Tmp_362 > 0;
    goto anon157_Then, anon157_Else;

  anon157_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_362 + out_Tmp_352 * 4] > out_port_1;
    out_portNo_2 := out_boardNo * 32 + out_port_1;
    out_Tmp_333 := out_portNo_2;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_344;
    assume {:nonnull} out_Tmp_344 != 0;
    assume out_Tmp_344 > 0;
    havoc out_extension_15;
    goto anon158_Then, anon158_Else;

  anon158_Else:
    assume {:partition} out_extension_15 == 0;
    goto L70;

  L70:
    out_port_1 := out_port_1 + 1;
    assume false;
    return;

  anon158_Then:
    assume {:partition} out_extension_15 != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_337;
    assume {:nonnull} out_ip != 0;
    assume out_ip > 0;
    out_temp := Mem_T.INT4[out_ip + out_Tmp_337 * 4];
    goto anon159_Then, anon159_Else;

  anon159_Else:
    assume {:partition} out_temp != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_347;
    assume {:nonnull} out_ip != 0;
    assume out_ip > 0;
    Mem_T.INT4[out_ip + out_Tmp_347 * 4] := 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon160_Then, anon160_Else;

  anon160_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon117_Then, anon117_Else;

  anon117_Else:
    goto anon118_Then, anon118_Else;

  anon118_Else:
    assume {:partition} BAND(out_temp, 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon120_Then, anon120_Else;

  anon120_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon121_Then, anon121_Else;

  anon121_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1722} out_vslice_dummy_var_60 := MoxaInsertQueueDpc#1(IsrOutDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon168_Else;

  anon168_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  L76:
    goto anon119_Then, anon119_Else;

  anon119_Else:
    assume {:partition} BAND(out_temp, 256) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon123_Then, anon123_Else;

  anon123_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon124_Then, anon124_Else;

  anon124_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1723} out_vslice_dummy_var_59 := MoxaInsertQueueDpc#1(IsrInDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon167_Else;

  anon167_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  L93:
    goto anon122_Then, anon122_Else;

  anon122_Else:
    assume {:partition} BAND(out_temp, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon126_Then, anon126_Else;

  anon126_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L100;

  L100:
    goto anon125_Then, anon125_Else;

  anon125_Else:
    assume {:partition} BAND(out_temp, 32) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon128_Then, anon128_Else;

  anon128_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L103;

  L103:
    goto anon127_Then, anon127_Else;

  anon127_Else:
    assume {:partition} BAND(out_temp, 64) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon130_Then, anon130_Else;

  anon130_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L106;

  L106:
    goto anon129_Then, anon129_Else;

  anon129_Else:
    assume {:partition} BAND(out_temp, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon161_Then, anon161_Else;

  anon161_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L112;

  L112:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon132_Then, anon132_Else;

  anon132_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1724} out_vslice_dummy_var_56 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon162_Else;

  anon162_Else:
    assume {:partition} yogi_error != 1;
    goto L109;

  L109:
    goto anon131_Then, anon131_Else;

  anon131_Else:
    assume {:partition} BAND(out_temp, 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1372;
    call {:si_unique_call 1725} MoxaFuncGetLineStatus(vslice_dummy_var_1372, in_modemStatus);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon134_Then, anon134_Else;

  anon134_Else:
    call {:si_unique_call 1726} out_change := corral_nondet();
    goto anon163_Then, anon163_Else;

  anon163_Else:
    assume {:partition} BAND(out_change, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon136_Then, anon136_Else;

  anon136_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L127;

  L127:
    goto anon135_Then, anon135_Else;

  anon135_Else:
    assume {:partition} BAND(out_change, 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon138_Then, anon138_Else;

  anon138_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L130;

  L130:
    goto anon137_Then, anon137_Else;

  anon137_Else:
    assume {:partition} BAND(out_change, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon139_Then, anon139_Else;

  anon139_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L123;

  L123:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} in_modemStatus != 0;
    assume in_modemStatus > 0;
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(out_extension_15)] := Mem_T.INT4[in_modemStatus];
    goto L117;

  L117:
    goto anon133_Then, anon133_Else;

  anon133_Else:
    assume {:partition} BAND(out_temp, 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1373;
    call {:si_unique_call 1727} MoxaFuncGetDataError(vslice_dummy_var_1373, in_dataError);
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon141_Then, anon141_Else;

  anon141_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L141;

  L141:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon142_Then, anon142_Else;

  anon142_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L143;

  L143:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon143_Then, anon143_Else;

  anon143_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L145;

  L145:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon144_Then, anon144_Else;

  anon144_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L147;

  L147:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon164_Then, anon164_Else;

  anon164_Else:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon146_Then, anon146_Else;

  anon146_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L150;

  L150:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon145_Then, anon145_Else;

  anon145_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1728} out_vslice_dummy_var_57 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon165_Else;

  anon165_Else:
    assume {:partition} yogi_error != 1;
    goto L135;

  L135:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon140_Then, anon140_Else;

  anon140_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon147_Then, anon147_Else;

  anon147_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_336;
    assume {:nonnull} out_Tmp_336 != 0;
    assume out_Tmp_336 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1374;
    Mem_T.INT4[out_Tmp_336] := vslice_dummy_var_1374;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_332;
    assume {:nonnull} out_Tmp_332 != 0;
    assume out_Tmp_332 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1729} out_vslice_dummy_var_58 := MoxaInsertQueueDpc#1(CommWaitDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon166_Else;

  anon166_Else:
    assume {:partition} yogi_error != 1;
    goto L70;

  anon147_Then:
    goto L70;

  anon140_Then:
    goto L70;

  anon145_Then:
    goto L135;

  anon146_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) == 0;
    goto L150;

  anon164_Then:
    goto L150;

  anon144_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) == 0;
    goto L147;

  anon143_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) == 0;
    goto L145;

  anon142_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) == 0;
    goto L143;

  anon141_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) == 0;
    goto L141;

  anon133_Then:
    assume {:partition} BAND(out_temp, 4) == 0;
    goto L135;

  anon139_Then:
    goto L123;

  anon137_Then:
    assume {:partition} BAND(out_change, 8) == 0;
    goto L123;

  anon138_Then:
    goto L130;

  anon135_Then:
    assume {:partition} BAND(out_change, 2) == 0;
    goto L130;

  anon136_Then:
    goto L127;

  anon163_Then:
    assume {:partition} BAND(out_change, 1) == 0;
    goto L127;

  anon134_Then:
    goto L123;

  anon131_Then:
    assume {:partition} BAND(out_temp, 16) == 0;
    goto L117;

  anon132_Then:
    goto L109;

  anon161_Then:
    goto L112;

  anon129_Then:
    assume {:partition} BAND(out_temp, 8) == 0;
    goto L109;

  anon130_Then:
    goto L106;

  anon127_Then:
    assume {:partition} BAND(out_temp, 64) == 0;
    goto L106;

  anon128_Then:
    goto L103;

  anon125_Then:
    assume {:partition} BAND(out_temp, 32) == 0;
    goto L103;

  anon126_Then:
    goto L100;

  anon122_Then:
    assume {:partition} BAND(out_temp, 1) == 0;
    goto L100;

  anon124_Then:
    goto L93;

  anon123_Then:
    goto L93;

  anon119_Then:
    assume {:partition} BAND(out_temp, 256) == 0;
    goto L93;

  anon121_Then:
    goto L76;

  anon120_Then:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_341;
    assume {:nonnull} out_Tmp_341 != 0;
    assume out_Tmp_341 > 0;
    goto anon169_Then, anon169_Else;

  anon169_Else:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_338;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_351;
    assume {:nonnull} out_Tmp_338 != 0;
    assume out_Tmp_338 > 0;
    assume {:nonnull} out_Tmp_351 != 0;
    assume out_Tmp_351 > 0;
    Mem_T.INT4[out_Tmp_338] := BAND(Mem_T.INT4[out_Tmp_351], BNOT(BOR(2, 512)));
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1371;
    call {:si_unique_call 1720} out_irpSp_3 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1371);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_361;
    assume {:nonnull} out_Tmp_361 != 0;
    assume out_Tmp_361 > 0;
    assume {:nonnull} out_irpSp_3 != 0;
    assume out_irpSp_3 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1721} out_vslice_dummy_var_61 := MoxaInsertQueueDpc#1(CompleteWriteDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon170_Else;

  anon170_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  anon169_Then:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) == 0;
    goto L76;

  anon118_Then:
    assume {:partition} BAND(out_temp, 514) == 0;
    goto L76;

  anon117_Then:
    goto L70;

  anon160_Then:
    goto L70;

  anon159_Then:
    assume {:partition} out_temp == 0;
    goto L70;

  anon157_Then:
    assume {:partition} out_port_1 >= Mem_T.INT4[out_Tmp_362 + out_Tmp_352 * 4];
    out_Tmp_340 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_350;
    assume {:nonnull} out_Tmp_350 != 0;
    assume out_Tmp_350 > 0;
    havoc out_Tmp_335;
    assume {:nonnull} out_Tmp_335 != 0;
    assume out_Tmp_335 > 0;
    Mem_T.INT4[out_Tmp_335] := 0;
    goto L54;

  L54:
    assume {:nonnull} out_interruptEntry != 0;
    assume out_interruptEntry > 0;
    havoc out_interruptEntry;
    out_servicedAnInterrupt := BOR(out_servicedAnInterrupt, out_thisPassServiced);
    goto anon171_Then;

  anon171_Then:
    goto anon171_Then_dummy;

  anon171_Then_dummy:
    call {:si_unique_call 1730} {:si_old_unique_call 1} out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L30(in_modemStatus, out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, in_dataError, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    return;

  anon156_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_348] != 128;
    goto L54;

  anon155_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_339] == 0;
    goto L57;

  anon154_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_353] != 255;
    goto L54;

  anon153_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_365 + out_Tmp_345 * 4] != 1;
    goto L54;

  anon152_Then:
    goto L43;
}



procedure {:LoopProcedure} MoxaISR_loop_L30(in_modemStatus: int, in_Tmp_331: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_335: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_ack: int, in_irpSp_3: int, in_Tmp_338: int, in_interruptEntry: int, in_dispatch: int, in_Tmp_339: int, in_Tmp_340: int, in_Tmp_341: int, in_globalData: int, in_cisrsw: int, in_change: int, in_Tmp_342: int, in_Tmp_343: int, in_port_1: int, in_Tmp_344: int, in_Tmp_345: int, in_ip: int, in_Tmp_346: int, in_Tmp_347: int, in_Tmp_348: int, in_sdv_96: int, in_Tmp_349: int, in_Tmp_350: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_353: int, in_Tmp_355: int, in_Tmp_356: int, in_Tmp_357: int, in_Tmp_358: int, in_Tmp_359: int, in_Tmp_360: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_Tmp_364: int, in_Tmp_365: int, in_thisPassServiced: int, in_extension_15: int, in_Tmp_366: int, in_servicedAnInterrupt: int, in_dataError: int, in_Tmp_367: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_331: int, out_Tmp_332: int, out_Tmp_333: int, out_Tmp_335: int, out_Tmp_336: int, out_Tmp_337: int, out_boardNo: int, out_ack: int, out_irpSp_3: int, out_Tmp_338: int, out_interruptEntry: int, out_dispatch: int, out_Tmp_339: int, out_Tmp_340: int, out_Tmp_341: int, out_globalData: int, out_cisrsw: int, out_change: int, out_Tmp_342: int, out_Tmp_343: int, out_port_1: int, out_Tmp_344: int, out_Tmp_345: int, out_ip: int, out_Tmp_346: int, out_Tmp_347: int, out_Tmp_348: int, out_sdv_96: int, out_Tmp_349: int, out_Tmp_350: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_353: int, out_Tmp_355: int, out_Tmp_356: int, out_Tmp_357: int, out_Tmp_358: int, out_Tmp_359: int, out_Tmp_360: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_Tmp_364: int, out_Tmp_365: int, out_thisPassServiced: int, out_extension_15: int, out_Tmp_366: int, out_servicedAnInterrupt: int, out_Tmp_367: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int);
  modifies Mem_T.INT4, alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} out_thisPassServiced == 1 || out_thisPassServiced == in_thisPassServiced;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaISR_loop_L26(in_modemStatus: int, in_Tmp_331: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_335: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_ack: int, in_irpSp_3: int, in_Tmp_338: int, in_firstInterruptEntry: int, in_interruptEntry: int, in_dispatch: int, in_Tmp_339: int, in_Tmp_340: int, in_Tmp_341: int, in_globalData: int, in_cisrsw: int, in_change: int, in_Tmp_342: int, in_Tmp_343: int, in_port_1: int, in_Tmp_344: int, in_Tmp_345: int, in_ip: int, in_Tmp_346: int, in_Tmp_347: int, in_Tmp_348: int, in_sdv_96: int, in_Tmp_349: int, in_Tmp_350: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_353: int, in_Tmp_355: int, in_Tmp_356: int, in_Tmp_357: int, in_Tmp_358: int, in_Tmp_359: int, in_Tmp_360: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_Tmp_364: int, in_Tmp_365: int, in_thisPassServiced: int, in_extension_15: int, in_Tmp_366: int, in_servicedAnInterrupt: int, in_dataError: int, in_Tmp_367: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_331: int, out_Tmp_332: int, out_Tmp_333: int, out_Tmp_335: int, out_Tmp_336: int, out_Tmp_337: int, out_boardNo: int, out_ack: int, out_irpSp_3: int, out_Tmp_338: int, out_interruptEntry: int, out_dispatch: int, out_Tmp_339: int, out_Tmp_340: int, out_Tmp_341: int, out_globalData: int, out_cisrsw: int, out_change: int, out_Tmp_342: int, out_Tmp_343: int, out_port_1: int, out_Tmp_344: int, out_Tmp_345: int, out_ip: int, out_Tmp_346: int, out_Tmp_347: int, out_Tmp_348: int, out_sdv_96: int, out_Tmp_349: int, out_Tmp_350: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_353: int, out_Tmp_355: int, out_Tmp_356: int, out_Tmp_357: int, out_Tmp_358: int, out_Tmp_359: int, out_Tmp_360: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_Tmp_364: int, out_Tmp_365: int, out_thisPassServiced: int, out_extension_15: int, out_Tmp_366: int, out_servicedAnInterrupt: int, out_Tmp_367: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int)
{
  var vslice_dummy_var_1375: int;
  var vslice_dummy_var_1376: int;
  var vslice_dummy_var_1377: int;
  var vslice_dummy_var_1378: int;

  entry:
    out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := in_Tmp_331, in_Tmp_332, in_Tmp_333, in_Tmp_335, in_Tmp_336, in_Tmp_337, in_boardNo, in_ack, in_irpSp_3, in_Tmp_338, in_interruptEntry, in_dispatch, in_Tmp_339, in_Tmp_340, in_Tmp_341, in_globalData, in_cisrsw, in_change, in_Tmp_342, in_Tmp_343, in_port_1, in_Tmp_344, in_Tmp_345, in_ip, in_Tmp_346, in_Tmp_347, in_Tmp_348, in_sdv_96, in_Tmp_349, in_Tmp_350, in_Tmp_351, in_Tmp_352, in_temp, in_Tmp_353, in_Tmp_355, in_Tmp_356, in_Tmp_357, in_Tmp_358, in_Tmp_359, in_Tmp_360, in_Tmp_361, in_Tmp_362, in_portNo_2, in_Tmp_364, in_Tmp_365, in_thisPassServiced, in_extension_15, in_Tmp_366, in_servicedAnInterrupt, in_Tmp_367, in_vslice_dummy_var_56, in_vslice_dummy_var_57, in_vslice_dummy_var_58, in_vslice_dummy_var_59, in_vslice_dummy_var_60, in_vslice_dummy_var_61;
    goto L26, exit;

  exit:
    return;

  L26:
    out_thisPassServiced := 0;
    assume {:nonnull} in_firstInterruptEntry != 0;
    assume in_firstInterruptEntry > 0;
    havoc out_interruptEntry;
    goto L30;

  L30:
    call {:si_unique_call 1732} out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L30(in_modemStatus, out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, in_dataError, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    goto L30_last;

  L30_last:
    call {:si_unique_call 1733} out_sdv_96 := sdv_containing_record(out_interruptEntry, 8);
    out_cisrsw := out_sdv_96;
    goto anon150_Else;

  anon150_Else:
    assume {:partition} out_cisrsw != 0;
    assume {:nonnull} out_cisrsw != 0;
    assume out_cisrsw > 0;
    out_dispatch := Dispatch__MOXA_CISR_SW(out_cisrsw);
    assume {:nonnull} out_dispatch != 0;
    assume out_dispatch > 0;
    havoc out_globalData;
    assume {:nonnull} out_dispatch != 0;
    assume out_dispatch > 0;
    havoc out_boardNo;
    goto anon151_Else;

  anon151_Else:
    assume {:partition} out_globalData != 0;
    goto anon116_Else;

  anon116_Else:
    assume {:partition} 0 <= out_boardNo;
    out_Tmp_355 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_366;
    assume {:nonnull} out_Tmp_366 != 0;
    assume out_Tmp_366 > 0;
    goto anon152_Then, anon152_Else;

  anon152_Else:
    out_Tmp_331 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_346;
    assume {:nonnull} out_Tmp_346 != 0;
    assume out_Tmp_346 > 0;
    call {:si_unique_call 1731} out_ack := corral_nondet();
    out_ack := BOR(out_ack, 4);
    out_Tmp_343 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_356;
    assume {:nonnull} out_Tmp_356 != 0;
    assume out_Tmp_356 > 0;
    goto L43;

  L43:
    out_Tmp_345 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_365;
    assume {:nonnull} out_Tmp_365 != 0;
    assume out_Tmp_365 > 0;
    goto anon153_Then, anon153_Else;

  anon153_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_365 + out_Tmp_345 * 4] == 1;
    out_Tmp_367 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_360;
    assume {:nonnull} out_Tmp_360 != 0;
    assume out_Tmp_360 > 0;
    havoc out_Tmp_353;
    assume {:nonnull} out_Tmp_353 != 0;
    assume out_Tmp_353 > 0;
    goto anon154_Then, anon154_Else;

  anon154_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_353] == 255;
    out_Tmp_342 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_358;
    assume {:nonnull} out_Tmp_358 != 0;
    assume out_Tmp_358 > 0;
    havoc out_Tmp_339;
    assume {:nonnull} out_Tmp_339 != 0;
    assume out_Tmp_339 > 0;
    goto anon155_Then, anon155_Else;

  anon155_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_339] != 0;
    out_Tmp_349 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_359;
    assume {:nonnull} out_Tmp_359 != 0;
    assume out_Tmp_359 > 0;
    havoc out_Tmp_348;
    assume {:nonnull} out_Tmp_348 != 0;
    assume out_Tmp_348 > 0;
    goto anon156_Then, anon156_Else;

  anon156_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_348] == 128;
    goto L57;

  L57:
    out_servicedAnInterrupt := 1;
    out_thisPassServiced := 1;
    out_Tmp_357 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_364;
    assume {:nonnull} out_Tmp_364 != 0;
    assume out_Tmp_364 > 0;
    havoc out_ip;
    out_port_1 := 0;
    goto L62;

  L62:
    call {:si_unique_call 1734} out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_change, out_port_1, out_Tmp_344, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L62(in_modemStatus, out_Tmp_332, out_Tmp_333, out_Tmp_336, out_Tmp_337, out_boardNo, out_irpSp_3, out_Tmp_338, out_Tmp_341, out_globalData, out_change, out_port_1, out_Tmp_344, out_ip, out_Tmp_347, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_361, out_Tmp_362, out_portNo_2, out_extension_15, in_dataError, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    goto L62_last;

  L62_last:
    out_Tmp_352 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_362;
    assume {:nonnull} out_Tmp_362 != 0;
    assume out_Tmp_362 > 0;
    goto anon157_Then, anon157_Else;

  anon157_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_362 + out_Tmp_352 * 4] > out_port_1;
    out_portNo_2 := out_boardNo * 32 + out_port_1;
    out_Tmp_333 := out_portNo_2;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_344;
    assume {:nonnull} out_Tmp_344 != 0;
    assume out_Tmp_344 > 0;
    havoc out_extension_15;
    goto anon158_Then, anon158_Else;

  anon158_Else:
    assume {:partition} out_extension_15 == 0;
    goto L70;

  L70:
    out_port_1 := out_port_1 + 1;
    assume false;
    return;

  anon158_Then:
    assume {:partition} out_extension_15 != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_337;
    assume {:nonnull} out_ip != 0;
    assume out_ip > 0;
    out_temp := Mem_T.INT4[out_ip + out_Tmp_337 * 4];
    goto anon159_Then, anon159_Else;

  anon159_Else:
    assume {:partition} out_temp != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_347;
    assume {:nonnull} out_ip != 0;
    assume out_ip > 0;
    Mem_T.INT4[out_ip + out_Tmp_347 * 4] := 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon160_Then, anon160_Else;

  anon160_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon117_Then, anon117_Else;

  anon117_Else:
    goto anon118_Then, anon118_Else;

  anon118_Else:
    assume {:partition} BAND(out_temp, 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon120_Then, anon120_Else;

  anon120_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon121_Then, anon121_Else;

  anon121_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1737} out_vslice_dummy_var_60 := MoxaInsertQueueDpc#1(IsrOutDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon168_Else;

  anon168_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  L76:
    goto anon119_Then, anon119_Else;

  anon119_Else:
    assume {:partition} BAND(out_temp, 256) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon123_Then, anon123_Else;

  anon123_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon124_Then, anon124_Else;

  anon124_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1738} out_vslice_dummy_var_59 := MoxaInsertQueueDpc#1(IsrInDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon167_Else;

  anon167_Else:
    assume {:partition} yogi_error != 1;
    goto L93;

  L93:
    goto anon122_Then, anon122_Else;

  anon122_Else:
    assume {:partition} BAND(out_temp, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon126_Then, anon126_Else;

  anon126_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L100;

  L100:
    goto anon125_Then, anon125_Else;

  anon125_Else:
    assume {:partition} BAND(out_temp, 32) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon128_Then, anon128_Else;

  anon128_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L103;

  L103:
    goto anon127_Then, anon127_Else;

  anon127_Else:
    assume {:partition} BAND(out_temp, 64) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon130_Then, anon130_Else;

  anon130_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L106;

  L106:
    goto anon129_Then, anon129_Else;

  anon129_Else:
    assume {:partition} BAND(out_temp, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon161_Then, anon161_Else;

  anon161_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L112;

  L112:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon132_Then, anon132_Else;

  anon132_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1739} out_vslice_dummy_var_56 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon162_Else;

  anon162_Else:
    assume {:partition} yogi_error != 1;
    goto L109;

  L109:
    goto anon131_Then, anon131_Else;

  anon131_Else:
    assume {:partition} BAND(out_temp, 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1376;
    call {:si_unique_call 1740} MoxaFuncGetLineStatus(vslice_dummy_var_1376, in_modemStatus);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon134_Then, anon134_Else;

  anon134_Else:
    call {:si_unique_call 1741} out_change := corral_nondet();
    goto anon163_Then, anon163_Else;

  anon163_Else:
    assume {:partition} BAND(out_change, 1) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon136_Then, anon136_Else;

  anon136_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L127;

  L127:
    goto anon135_Then, anon135_Else;

  anon135_Else:
    assume {:partition} BAND(out_change, 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon138_Then, anon138_Else;

  anon138_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L130;

  L130:
    goto anon137_Then, anon137_Else;

  anon137_Else:
    assume {:partition} BAND(out_change, 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon139_Then, anon139_Else;

  anon139_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L123;

  L123:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} in_modemStatus != 0;
    assume in_modemStatus > 0;
    Mem_T.INT4[ModemStatus__MOXA_DEVICE_EXTENSION(out_extension_15)] := Mem_T.INT4[in_modemStatus];
    goto L117;

  L117:
    goto anon133_Then, anon133_Else;

  anon133_Else:
    assume {:partition} BAND(out_temp, 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1377;
    call {:si_unique_call 1742} MoxaFuncGetDataError(vslice_dummy_var_1377, in_dataError);
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon141_Then, anon141_Else;

  anon141_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L141;

  L141:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon142_Then, anon142_Else;

  anon142_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L143;

  L143:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon143_Then, anon143_Else;

  anon143_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L145;

  L145:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon144_Then, anon144_Else;

  anon144_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L147;

  L147:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon164_Then, anon164_Else;

  anon164_Else:
    assume {:nonnull} in_dataError != 0;
    assume in_dataError > 0;
    goto anon146_Then, anon146_Else;

  anon146_Else:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto L150;

  L150:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon145_Then, anon145_Else;

  anon145_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1743} out_vslice_dummy_var_57 := MoxaInsertQueueDpc#1(CommErrorDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon165_Else;

  anon165_Else:
    assume {:partition} yogi_error != 1;
    goto L135;

  L135:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon140_Then, anon140_Else;

  anon140_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    goto anon147_Then, anon147_Else;

  anon147_Else:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_336;
    assume {:nonnull} out_Tmp_336 != 0;
    assume out_Tmp_336 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1378;
    Mem_T.INT4[out_Tmp_336] := vslice_dummy_var_1378;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_332;
    assume {:nonnull} out_Tmp_332 != 0;
    assume out_Tmp_332 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1744} out_vslice_dummy_var_58 := MoxaInsertQueueDpc#1(CommWaitDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon166_Else;

  anon166_Else:
    assume {:partition} yogi_error != 1;
    goto L70;

  anon147_Then:
    goto L70;

  anon140_Then:
    goto L70;

  anon145_Then:
    goto L135;

  anon146_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 22) == 0;
    goto L150;

  anon164_Then:
    goto L150;

  anon144_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 2) == 0;
    goto L147;

  anon143_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 16) == 0;
    goto L145;

  anon142_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 4) == 0;
    goto L143;

  anon141_Then:
    assume {:partition} BAND(Mem_T.INT4[in_dataError], 8) == 0;
    goto L141;

  anon133_Then:
    assume {:partition} BAND(out_temp, 4) == 0;
    goto L135;

  anon139_Then:
    goto L123;

  anon137_Then:
    assume {:partition} BAND(out_change, 8) == 0;
    goto L123;

  anon138_Then:
    goto L130;

  anon135_Then:
    assume {:partition} BAND(out_change, 2) == 0;
    goto L130;

  anon136_Then:
    goto L127;

  anon163_Then:
    assume {:partition} BAND(out_change, 1) == 0;
    goto L127;

  anon134_Then:
    goto L123;

  anon131_Then:
    assume {:partition} BAND(out_temp, 16) == 0;
    goto L117;

  anon132_Then:
    goto L109;

  anon161_Then:
    goto L112;

  anon129_Then:
    assume {:partition} BAND(out_temp, 8) == 0;
    goto L109;

  anon130_Then:
    goto L106;

  anon127_Then:
    assume {:partition} BAND(out_temp, 64) == 0;
    goto L106;

  anon128_Then:
    goto L103;

  anon125_Then:
    assume {:partition} BAND(out_temp, 32) == 0;
    goto L103;

  anon126_Then:
    goto L100;

  anon122_Then:
    assume {:partition} BAND(out_temp, 1) == 0;
    goto L100;

  anon124_Then:
    goto L93;

  anon123_Then:
    goto L93;

  anon119_Then:
    assume {:partition} BAND(out_temp, 256) == 0;
    goto L93;

  anon121_Then:
    goto L76;

  anon120_Then:
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_341;
    assume {:nonnull} out_Tmp_341 != 0;
    assume out_Tmp_341 > 0;
    goto anon169_Then, anon169_Else;

  anon169_Else:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) != 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_338;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_351;
    assume {:nonnull} out_Tmp_338 != 0;
    assume out_Tmp_338 > 0;
    assume {:nonnull} out_Tmp_351 != 0;
    assume out_Tmp_351 > 0;
    Mem_T.INT4[out_Tmp_338] := BAND(Mem_T.INT4[out_Tmp_351], BNOT(BOR(2, 512)));
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc vslice_dummy_var_1375;
    call {:si_unique_call 1735} out_irpSp_3 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1375);
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    havoc out_Tmp_361;
    assume {:nonnull} out_Tmp_361 != 0;
    assume out_Tmp_361 > 0;
    assume {:nonnull} out_irpSp_3 != 0;
    assume out_irpSp_3 > 0;
    assume {:nonnull} out_extension_15 != 0;
    assume out_extension_15 > 0;
    call {:si_unique_call 1736} out_vslice_dummy_var_61 := MoxaInsertQueueDpc#1(CompleteWriteDpc__MOXA_DEVICE_EXTENSION(out_extension_15), 0, 0, out_extension_15);
    goto anon170_Else;

  anon170_Else:
    assume {:partition} yogi_error != 1;
    goto L76;

  anon169_Then:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_341], 514) == 0;
    goto L76;

  anon118_Then:
    assume {:partition} BAND(out_temp, 514) == 0;
    goto L76;

  anon117_Then:
    goto L70;

  anon160_Then:
    goto L70;

  anon159_Then:
    assume {:partition} out_temp == 0;
    goto L70;

  anon157_Then:
    assume {:partition} out_port_1 >= Mem_T.INT4[out_Tmp_362 + out_Tmp_352 * 4];
    out_Tmp_340 := out_boardNo;
    assume {:nonnull} out_globalData != 0;
    assume out_globalData > 0;
    havoc out_Tmp_350;
    assume {:nonnull} out_Tmp_350 != 0;
    assume out_Tmp_350 > 0;
    havoc out_Tmp_335;
    assume {:nonnull} out_Tmp_335 != 0;
    assume out_Tmp_335 > 0;
    Mem_T.INT4[out_Tmp_335] := 0;
    goto L54;

  L54:
    assume {:nonnull} out_interruptEntry != 0;
    assume out_interruptEntry > 0;
    havoc out_interruptEntry;
    out_servicedAnInterrupt := BOR(out_servicedAnInterrupt, out_thisPassServiced);
    goto anon171_Then, anon171_Else;

  anon171_Else:
    goto anon148_Then;

  anon148_Then:
    assume {:partition} out_thisPassServiced == 1;
    goto anon148_Then_dummy;

  anon148_Then_dummy:
    call {:si_unique_call 1745} {:si_old_unique_call 1} out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61 := MoxaISR_loop_L26(in_modemStatus, out_Tmp_331, out_Tmp_332, out_Tmp_333, out_Tmp_335, out_Tmp_336, out_Tmp_337, out_boardNo, out_ack, out_irpSp_3, out_Tmp_338, in_firstInterruptEntry, out_interruptEntry, out_dispatch, out_Tmp_339, out_Tmp_340, out_Tmp_341, out_globalData, out_cisrsw, out_change, out_Tmp_342, out_Tmp_343, out_port_1, out_Tmp_344, out_Tmp_345, out_ip, out_Tmp_346, out_Tmp_347, out_Tmp_348, out_sdv_96, out_Tmp_349, out_Tmp_350, out_Tmp_351, out_Tmp_352, out_temp, out_Tmp_353, out_Tmp_355, out_Tmp_356, out_Tmp_357, out_Tmp_358, out_Tmp_359, out_Tmp_360, out_Tmp_361, out_Tmp_362, out_portNo_2, out_Tmp_364, out_Tmp_365, out_thisPassServiced, out_extension_15, out_Tmp_366, out_servicedAnInterrupt, in_dataError, out_Tmp_367, out_vslice_dummy_var_56, out_vslice_dummy_var_57, out_vslice_dummy_var_58, out_vslice_dummy_var_59, out_vslice_dummy_var_60, out_vslice_dummy_var_61);
    return;

  anon171_Then:
    assume false;
    return;

  anon156_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_348] != 128;
    goto L54;

  anon155_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_339] == 0;
    goto L57;

  anon154_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_353] != 255;
    goto L54;

  anon153_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_365 + out_Tmp_345 * 4] != 1;
    goto L54;

  anon152_Then:
    goto L43;
}



procedure {:LoopProcedure} MoxaISR_loop_L26(in_modemStatus: int, in_Tmp_331: int, in_Tmp_332: int, in_Tmp_333: int, in_Tmp_335: int, in_Tmp_336: int, in_Tmp_337: int, in_boardNo: int, in_ack: int, in_irpSp_3: int, in_Tmp_338: int, in_firstInterruptEntry: int, in_interruptEntry: int, in_dispatch: int, in_Tmp_339: int, in_Tmp_340: int, in_Tmp_341: int, in_globalData: int, in_cisrsw: int, in_change: int, in_Tmp_342: int, in_Tmp_343: int, in_port_1: int, in_Tmp_344: int, in_Tmp_345: int, in_ip: int, in_Tmp_346: int, in_Tmp_347: int, in_Tmp_348: int, in_sdv_96: int, in_Tmp_349: int, in_Tmp_350: int, in_Tmp_351: int, in_Tmp_352: int, in_temp: int, in_Tmp_353: int, in_Tmp_355: int, in_Tmp_356: int, in_Tmp_357: int, in_Tmp_358: int, in_Tmp_359: int, in_Tmp_360: int, in_Tmp_361: int, in_Tmp_362: int, in_portNo_2: int, in_Tmp_364: int, in_Tmp_365: int, in_thisPassServiced: int, in_extension_15: int, in_Tmp_366: int, in_servicedAnInterrupt: int, in_dataError: int, in_Tmp_367: int, in_vslice_dummy_var_56: int, in_vslice_dummy_var_57: int, in_vslice_dummy_var_58: int, in_vslice_dummy_var_59: int, in_vslice_dummy_var_60: int, in_vslice_dummy_var_61: int) returns (out_Tmp_331: int, out_Tmp_332: int, out_Tmp_333: int, out_Tmp_335: int, out_Tmp_336: int, out_Tmp_337: int, out_boardNo: int, out_ack: int, out_irpSp_3: int, out_Tmp_338: int, out_interruptEntry: int, out_dispatch: int, out_Tmp_339: int, out_Tmp_340: int, out_Tmp_341: int, out_globalData: int, out_cisrsw: int, out_change: int, out_Tmp_342: int, out_Tmp_343: int, out_port_1: int, out_Tmp_344: int, out_Tmp_345: int, out_ip: int, out_Tmp_346: int, out_Tmp_347: int, out_Tmp_348: int, out_sdv_96: int, out_Tmp_349: int, out_Tmp_350: int, out_Tmp_351: int, out_Tmp_352: int, out_temp: int, out_Tmp_353: int, out_Tmp_355: int, out_Tmp_356: int, out_Tmp_357: int, out_Tmp_358: int, out_Tmp_359: int, out_Tmp_360: int, out_Tmp_361: int, out_Tmp_362: int, out_portNo_2: int, out_Tmp_364: int, out_Tmp_365: int, out_thisPassServiced: int, out_extension_15: int, out_Tmp_366: int, out_servicedAnInterrupt: int, out_Tmp_367: int, out_vslice_dummy_var_56: int, out_vslice_dummy_var_57: int, out_vslice_dummy_var_58: int, out_vslice_dummy_var_59: int, out_vslice_dummy_var_60: int, out_vslice_dummy_var_61: int);
  modifies Mem_T.INT4, alloc, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} out_thisPassServiced == 1 || out_thisPassServiced == 0 || out_thisPassServiced == in_thisPassServiced;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaGetNextWrite_loop_L8(in_Tmp_380: int, in_sdv_109: int, in_extension_20: int, in_CurrentOpIrp: int, in_QueueToProcess: int, in_NewIrp: int, in_CompleteCurrent: int) returns (out_Tmp_380: int, out_sdv_109: int)
{
  var vslice_dummy_var_1379: int;

  entry:
    out_Tmp_380, out_sdv_109 := in_Tmp_380, in_sdv_109;
    goto L8, exit;

  exit:
    return;

  L8:
    call {:si_unique_call 1746} MoxaGetNextIrp(in_CurrentOpIrp, in_QueueToProcess, in_NewIrp, in_CompleteCurrent, in_extension_20);
    assume {:nonnull} in_NewIrp != 0;
    assume in_NewIrp > 0;
    goto anon5_Then;

  anon5_Then:
    assume {:nonnull} in_NewIrp != 0;
    assume in_NewIrp > 0;
    havoc vslice_dummy_var_1379;
    call {:si_unique_call 1747} out_sdv_109 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1379);
    assume {:nonnull} out_sdv_109 != 0;
    assume out_sdv_109 > 0;
    goto anon6_Else;

  anon6_Else:
    assume {:nonnull} in_NewIrp != 0;
    assume in_NewIrp > 0;
    havoc out_Tmp_380;
    assume {:nonnull} out_Tmp_380 != 0;
    assume out_Tmp_380 > 0;
    goto anon6_Else_dummy;

  anon6_Else_dummy:
    call {:si_unique_call 1748} {:si_old_unique_call 1} out_Tmp_380, out_sdv_109 := MoxaGetNextWrite_loop_L8(out_Tmp_380, out_sdv_109, in_extension_20, in_CurrentOpIrp, in_QueueToProcess, in_NewIrp, in_CompleteCurrent);
    return;
}



procedure {:LoopProcedure} MoxaGetNextWrite_loop_L8(in_Tmp_380: int, in_sdv_109: int, in_extension_20: int, in_CurrentOpIrp: int, in_QueueToProcess: int, in_NewIrp: int, in_CompleteCurrent: int) returns (out_Tmp_380: int, out_sdv_109: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaStartWrite_loop_L13(in_structPtr888totalTime: int, in_SD4: int, in_irpSp_4: int, in_totalTime: int, in_setFirstStatus_1: int, in_Tmp_385: int, in_newIrp_1: int, in_Tmp_386: int, in_timeouts: int, in_Tmp_387: int, in_Tmp_388: int, in_sdv_116: int, in_Tmp_389: int, in_oldIrql_11: int, in_sdv_119: int, in_sdv_4: int, in_useATimer: int, in_controlIrql_1: int, in_Tmp_391: int, in_Tmp_392: int, in_Tmp_393: int, in_Tmp_396: int, in_firstStatus_1: int, in_Extension_7: int, in_boogieTmp: int, in_vslice_dummy_var_71: int, in_vslice_dummy_var_72: int) returns (out_structPtr888totalTime: int, out_SD4: int, out_irpSp_4: int, out_setFirstStatus_1: int, out_Tmp_385: int, out_Tmp_386: int, out_Tmp_387: int, out_Tmp_388: int, out_sdv_116: int, out_Tmp_389: int, out_oldIrql_11: int, out_sdv_119: int, out_useATimer: int, out_controlIrql_1: int, out_Tmp_391: int, out_Tmp_392: int, out_Tmp_393: int, out_Tmp_396: int, out_firstStatus_1: int, out_boogieTmp: int, out_vslice_dummy_var_71: int, out_vslice_dummy_var_72: int)
{
  var vslice_dummy_var_1380: int;
  var vslice_dummy_var_1381: int;
  var vslice_dummy_var_1382: int;
  var vslice_dummy_var_1383: int;
  var vslice_dummy_var_1384: int;
  var vslice_dummy_var_1385: int;

  entry:
    out_structPtr888totalTime, out_SD4, out_irpSp_4, out_setFirstStatus_1, out_Tmp_385, out_Tmp_386, out_Tmp_387, out_Tmp_388, out_sdv_116, out_Tmp_389, out_oldIrql_11, out_sdv_119, out_useATimer, out_controlIrql_1, out_Tmp_391, out_Tmp_392, out_Tmp_393, out_Tmp_396, out_firstStatus_1, out_boogieTmp, out_vslice_dummy_var_71, out_vslice_dummy_var_72 := in_structPtr888totalTime, in_SD4, in_irpSp_4, in_setFirstStatus_1, in_Tmp_385, in_Tmp_386, in_Tmp_387, in_Tmp_388, in_sdv_116, in_Tmp_389, in_oldIrql_11, in_sdv_119, in_useATimer, in_controlIrql_1, in_Tmp_391, in_Tmp_392, in_Tmp_393, in_Tmp_396, in_firstStatus_1, in_boogieTmp, in_vslice_dummy_var_71, in_vslice_dummy_var_72;
    goto L13, exit;

  exit:
    return;

  L13:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc vslice_dummy_var_1380;
    call {:si_unique_call 1749} out_irpSp_4 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1380);
    assume {:nonnull} out_irpSp_4 != 0;
    assume out_irpSp_4 > 0;
    goto anon35_Then, anon35_Else;

  anon35_Else:
    call {:si_unique_call 1781} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_controlIrql_1;
    call {:si_unique_call 1782} sdv_KeAcquireSpinLock(0, out_Tmp_386);
    goto anon45_Else;

  anon45_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_controlIrql_1 := Mem_T.INT4[out_Tmp_386];
    call {:si_unique_call 1779} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_oldIrql_11;
    call {:si_unique_call 1780} IoAcquireCancelSpinLock(out_Tmp_386);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_oldIrql_11 := Mem_T.INT4[out_Tmp_386];
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_389;
    assume {:nonnull} out_Tmp_389 != 0;
    assume out_Tmp_389 > 0;
    goto anon46_Then, anon46_Else;

  anon46_Else:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_391;
    assume {:nonnull} out_Tmp_391 != 0;
    assume out_Tmp_391 > 0;
    call {:si_unique_call 1783} IoReleaseCancelSpinLock(out_oldIrql_11);
    call {:si_unique_call 1784} sdv_KeReleaseSpinLock(0, out_controlIrql_1);
    goto anon36_Then, anon36_Else;

  anon36_Else:
    assume {:partition} out_setFirstStatus_1 != 0;
    goto L40;

  L40:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    call {:si_unique_call 1750} MoxaGetNextWrite(CurrentWriteIrp__MOXA_DEVICE_EXTENSION(in_Extension_7), WriteQueue__MOXA_DEVICE_EXTENSION(in_Extension_7), in_newIrp_1, 1, in_Extension_7);
    assume {:nonnull} in_newIrp_1 != 0;
    assume in_newIrp_1 > 0;
    goto anon37_Then;

  anon37_Then:
    goto anon37_Then_dummy;

  anon37_Then_dummy:
    call {:si_unique_call 1785} {:si_old_unique_call 1} out_structPtr888totalTime, out_SD4, out_irpSp_4, out_setFirstStatus_1, out_Tmp_385, out_Tmp_386, out_Tmp_387, out_Tmp_388, out_sdv_116, out_Tmp_389, out_oldIrql_11, out_sdv_119, out_useATimer, out_controlIrql_1, out_Tmp_391, out_Tmp_392, out_Tmp_393, out_Tmp_396, out_firstStatus_1, out_boogieTmp, out_vslice_dummy_var_71, out_vslice_dummy_var_72 := MoxaStartWrite_loop_L13(out_structPtr888totalTime, out_SD4, out_irpSp_4, in_totalTime, out_setFirstStatus_1, out_Tmp_385, in_newIrp_1, out_Tmp_386, in_timeouts, out_Tmp_387, out_Tmp_388, out_sdv_116, out_Tmp_389, out_oldIrql_11, out_sdv_119, in_sdv_4, out_useATimer, out_controlIrql_1, out_Tmp_391, out_Tmp_392, out_Tmp_393, out_Tmp_396, out_firstStatus_1, in_Extension_7, out_boogieTmp, out_vslice_dummy_var_71, out_vslice_dummy_var_72);
    return;

  anon36_Then:
    assume {:partition} out_setFirstStatus_1 == 0;
    out_firstStatus_1 := -1073741536;
    out_setFirstStatus_1 := 1;
    goto L40;

  anon46_Then:
    call {:si_unique_call 1778} out_vslice_dummy_var_71 := KeSynchronizeExecution(0, li2bplFunctionConstant319, 0);
    goto anon38_Then, anon38_Else;

  anon38_Else:
    assume {:partition} out_setFirstStatus_1 != 0;
    goto L48;

  L48:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_392;
    assume {:nonnull} out_Tmp_392 != 0;
    assume out_Tmp_392 > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_393;
    assume {:nonnull} out_Tmp_393 != 0;
    assume out_Tmp_393 > 0;
    call {:si_unique_call 1751} IoReleaseCancelSpinLock(out_oldIrql_11);
    call {:si_unique_call 1752} sdv_KeReleaseSpinLock(0, out_controlIrql_1);
    goto L40;

  anon38_Then:
    assume {:partition} out_setFirstStatus_1 == 0;
    out_setFirstStatus_1 := 1;
    out_firstStatus_1 := 0;
    goto L48;

  anon35_Then:
    call {:si_unique_call 1770} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_oldIrql_11;
    call {:si_unique_call 1771} IoAcquireCancelSpinLock(out_Tmp_386);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_oldIrql_11 := Mem_T.INT4[out_Tmp_386];
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc vslice_dummy_var_1385;
    call {:si_unique_call 1772} out_sdv_119 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1385);
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} out_sdv_119 != 0;
    assume out_sdv_119 > 0;
    call {:si_unique_call 1773} IoReleaseCancelSpinLock(out_oldIrql_11);
    out_useATimer := 0;
    call {:si_unique_call 1774} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_controlIrql_1;
    call {:si_unique_call 1775} sdv_KeAcquireSpinLock(0, out_Tmp_386);
    goto anon47_Else;

  anon47_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_controlIrql_1 := Mem_T.INT4[out_Tmp_386];
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    call {:si_unique_call 1769} sdv_KeReleaseSpinLock(0, out_controlIrql_1);
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    goto anon39_Then, anon39_Else;

  anon39_Else:
    goto L74;

  L74:
    out_useATimer := 1;
    assume {:nonnull} out_irpSp_4 != 0;
    assume out_irpSp_4 > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    havoc vslice_dummy_var_1382;
    havoc vslice_dummy_var_1383;
    call {:si_unique_call 1761} out_structPtr888totalTime := RtlEnlargedUnsignedMultiply(vslice_dummy_var_1382, vslice_dummy_var_1383);
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    havoc vslice_dummy_var_1384;
    call {:si_unique_call 1762} out_SD4 := RtlConvertUlongToLargeInteger(vslice_dummy_var_1384);
    assume {:nonnull} out_SD4 != 0;
    assume out_SD4 > 0;
    assume {:nonnull} in_sdv_4 != 0;
    assume in_sdv_4 > 0;
    assume {:nonnull} out_SD4 != 0;
    assume out_SD4 > 0;
    assume {:nonnull} in_sdv_4 != 0;
    assume in_sdv_4 > 0;
    assume {:nonnull} out_SD4 != 0;
    assume out_SD4 > 0;
    assume {:nonnull} in_sdv_4 != 0;
    assume in_sdv_4 > 0;
    assume {:nonnull} out_SD4 != 0;
    assume out_SD4 > 0;
    assume {:nonnull} in_sdv_4 != 0;
    assume in_sdv_4 > 0;
    assume {:nonnull} out_SD4 != 0;
    assume out_SD4 > 0;
    assume {:nonnull} in_sdv_4 != 0;
    assume in_sdv_4 > 0;
    call {:si_unique_call 1763} out_structPtr888totalTime := RtlLargeIntegerAdd(in_totalTime, in_sdv_4);
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} out_structPtr888totalTime != 0;
    assume out_structPtr888totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    call {:si_unique_call 1764} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    call {:si_unique_call 1765} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    call {:si_unique_call 1766} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    call {:si_unique_call 1767} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_totalTime != 0;
    assume in_totalTime > 0;
    call {:si_unique_call 1768} out_boogieTmp := corral_nondet();
    goto L90;

  L90:
    call {:si_unique_call 1759} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_controlIrql_1;
    call {:si_unique_call 1760} sdv_KeAcquireSpinLock(0, out_Tmp_386);
    goto anon48_Else;

  anon48_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_controlIrql_1 := Mem_T.INT4[out_Tmp_386];
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc vslice_dummy_var_1381;
    call {:si_unique_call 1756} out_sdv_116 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1381);
    assume {:nonnull} out_sdv_116 != 0;
    assume out_sdv_116 > 0;
    call {:si_unique_call 1757} out_Tmp_386 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    Mem_T.INT4[out_Tmp_386] := out_oldIrql_11;
    call {:si_unique_call 1758} IoAcquireCancelSpinLock(out_Tmp_386);
    assume {:nonnull} out_Tmp_386 != 0;
    assume out_Tmp_386 > 0;
    out_oldIrql_11 := Mem_T.INT4[out_Tmp_386];
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_396;
    assume {:nonnull} out_Tmp_396 != 0;
    assume out_Tmp_396 > 0;
    goto anon49_Then, anon49_Else;

  anon49_Else:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_388;
    assume {:nonnull} out_Tmp_388 != 0;
    assume out_Tmp_388 > 0;
    call {:si_unique_call 1776} IoReleaseCancelSpinLock(out_oldIrql_11);
    call {:si_unique_call 1777} sdv_KeReleaseSpinLock(0, out_controlIrql_1);
    goto anon41_Then, anon41_Else;

  anon41_Else:
    assume {:partition} out_setFirstStatus_1 == 0;
    out_firstStatus_1 := -1073741536;
    out_setFirstStatus_1 := 1;
    goto L40;

  anon41_Then:
    assume {:partition} out_setFirstStatus_1 != 0;
    goto L40;

  anon49_Then:
    call {:si_unique_call 1755} out_vslice_dummy_var_72 := KeSynchronizeExecution(0, li2bplFunctionConstant320, 0);
    goto anon42_Else;

  anon42_Else:
    goto anon44_Then, anon44_Else;

  anon44_Else:
    assume {:partition} out_setFirstStatus_1 != 0;
    goto L118;

  L118:
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_387;
    assume {:nonnull} out_Tmp_387 != 0;
    assume out_Tmp_387 > 0;
    assume {:nonnull} in_Extension_7 != 0;
    assume in_Extension_7 > 0;
    havoc out_Tmp_385;
    assume {:nonnull} out_Tmp_385 != 0;
    assume out_Tmp_385 > 0;
    assume {:nonnull} out_irpSp_4 != 0;
    assume out_irpSp_4 > 0;
    call {:si_unique_call 1753} IoReleaseCancelSpinLock(out_oldIrql_11);
    call {:si_unique_call 1754} sdv_KeReleaseSpinLock(0, out_controlIrql_1);
    goto L40;

  anon44_Then:
    assume {:partition} out_setFirstStatus_1 == 0;
    out_setFirstStatus_1 := 1;
    out_firstStatus_1 := 0;
    goto L118;

  anon39_Then:
    assume {:nonnull} in_timeouts != 0;
    assume in_timeouts > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    goto L90;

  anon40_Then:
    goto L74;
}



procedure {:LoopProcedure} MoxaStartWrite_loop_L13(in_structPtr888totalTime: int, in_SD4: int, in_irpSp_4: int, in_totalTime: int, in_setFirstStatus_1: int, in_Tmp_385: int, in_newIrp_1: int, in_Tmp_386: int, in_timeouts: int, in_Tmp_387: int, in_Tmp_388: int, in_sdv_116: int, in_Tmp_389: int, in_oldIrql_11: int, in_sdv_119: int, in_sdv_4: int, in_useATimer: int, in_controlIrql_1: int, in_Tmp_391: int, in_Tmp_392: int, in_Tmp_393: int, in_Tmp_396: int, in_firstStatus_1: int, in_Extension_7: int, in_boogieTmp: int, in_vslice_dummy_var_71: int, in_vslice_dummy_var_72: int) returns (out_structPtr888totalTime: int, out_SD4: int, out_irpSp_4: int, out_setFirstStatus_1: int, out_Tmp_385: int, out_Tmp_386: int, out_Tmp_387: int, out_Tmp_388: int, out_sdv_116: int, out_Tmp_389: int, out_oldIrql_11: int, out_sdv_119: int, out_useATimer: int, out_controlIrql_1: int, out_Tmp_391: int, out_Tmp_392: int, out_Tmp_393: int, out_Tmp_396: int, out_firstStatus_1: int, out_boogieTmp: int, out_vslice_dummy_var_71: int, out_vslice_dummy_var_72: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_3) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2) || sdv_irql_previous_2 == old(sdv_irql_previous_3) || sdv_irql_previous_2 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous) || sdv_irql_previous == old(sdv_irql_previous_2) || sdv_irql_previous == old(sdv_irql_previous_3) || sdv_irql_previous == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4) || sdv_irql_previous_4 == old(sdv_irql_previous_3);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3) || sdv_irql_previous_3 == old(sdv_irql_previous_4);
  free ensures {:va_keep} out_setFirstStatus_1 == 1 || out_setFirstStatus_1 == in_setFirstStatus_1;
  free ensures {:va_keep} out_useATimer == 0 || out_useATimer == 1 || out_useATimer == in_useATimer;
  free ensures {:va_keep} out_firstStatus_1 == -1073741536 || out_firstStatus_1 == 0 || out_firstStatus_1 == in_firstStatus_1;
  free ensures {:va_keep} out_vslice_dummy_var_71 == 1 || out_vslice_dummy_var_71 == 0 || out_vslice_dummy_var_71 == in_vslice_dummy_var_71;
  free ensures {:va_keep} out_vslice_dummy_var_72 == 1 || out_vslice_dummy_var_72 == 0 || out_vslice_dummy_var_72 == in_vslice_dummy_var_72;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 6} MoxaRestoreDeviceState_loop_L44(in_i_1: int, in_Tmp_411: int, in_Tmp_414: int, in_Tmp_418: int, in_Tmp_423: int, in_PDevExt: int) returns (out_i_1: int, out_Tmp_411: int, out_Tmp_414: int, out_Tmp_418: int, out_Tmp_423: int)
{

  entry:
    out_i_1, out_Tmp_411, out_Tmp_414, out_Tmp_418, out_Tmp_423 := in_i_1, in_Tmp_411, in_Tmp_414, in_Tmp_418, in_Tmp_423;
    goto L44, exit;

  exit:
    return;

  L44:
    assume {:CounterLoop 6} {:Counter "i_1"} true;
    goto anon15_Else;

  anon15_Else:
    assume {:partition} 6 > out_i_1;
    out_Tmp_423 := out_i_1;
    assume {:nonnull} in_PDevExt != 0;
    assume in_PDevExt > 0;
    havoc out_Tmp_418;
    out_Tmp_411 := out_i_1;
    assume {:nonnull} in_PDevExt != 0;
    assume in_PDevExt > 0;
    out_Tmp_414 := SpecialChars__MOXA_DEVICE_EXTENSION(in_PDevExt);
    assume {:nonnull} out_Tmp_414 != 0;
    assume out_Tmp_414 > 0;
    assume {:nonnull} out_Tmp_418 != 0;
    assume out_Tmp_418 > 0;
    Mem_T.INT4[out_Tmp_418 + out_Tmp_423 * 4] := Mem_T.INT4[out_Tmp_414 + out_Tmp_411 * 4];
    out_i_1 := out_i_1 + 1;
    goto anon15_Else_dummy;

  anon15_Else_dummy:
    call {:si_unique_call 1786} {:si_old_unique_call 1} out_i_1, out_Tmp_411, out_Tmp_414, out_Tmp_418, out_Tmp_423 := MoxaRestoreDeviceState_loop_L44(out_i_1, out_Tmp_411, out_Tmp_414, out_Tmp_418, out_Tmp_423, in_PDevExt);
    return;
}



procedure {:LoopProcedure} MoxaRestoreDeviceState_loop_L44(in_i_1: int, in_Tmp_411: int, in_Tmp_414: int, in_Tmp_418: int, in_Tmp_423: int, in_PDevExt: int) returns (out_i_1: int, out_Tmp_411: int, out_Tmp_414: int, out_Tmp_418: int, out_Tmp_423: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} out_Tmp_414 == in_Tmp_414 || out_Tmp_414 == SpecialChars__MOXA_DEVICE_EXTENSION(in_PDevExt);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaStartPurge_loop_L5(in_oldIrql_13: int, in_Tmp_474: int, in_Tmp_475: int, in_Tmp_476: int, in_Tmp_477: int, in_mask_2: int, in_Tmp_478: int, in_newIrp_3: int, in_oldIrql_14: int, in_oldIrql_15: int, in_Extension_12: int) returns (out_oldIrql_13: int, out_Tmp_474: int, out_Tmp_475: int, out_Tmp_476: int, out_Tmp_477: int, out_mask_2: int, out_Tmp_478: int, out_oldIrql_14: int, out_oldIrql_15: int)
{
  var vslice_dummy_var_1386: int;
  var vslice_dummy_var_1387: int;
  var vslice_dummy_var_1388: int;
  var vslice_dummy_var_1389: int;
  var vslice_dummy_var_1390: int;

  entry:
    out_oldIrql_13, out_Tmp_474, out_Tmp_475, out_Tmp_476, out_Tmp_477, out_mask_2, out_Tmp_478, out_oldIrql_14, out_oldIrql_15 := in_oldIrql_13, in_Tmp_474, in_Tmp_475, in_Tmp_476, in_Tmp_477, in_mask_2, in_Tmp_478, in_oldIrql_14, in_oldIrql_15;
    goto L5, exit;

  exit:
    return;

  L5:
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc out_Tmp_474;
    assume {:nonnull} out_Tmp_474 != 0;
    assume out_Tmp_474 > 0;
    havoc out_Tmp_476;
    assume {:nonnull} out_Tmp_476 != 0;
    assume out_Tmp_476 > 0;
    out_mask_2 := Mem_T.INT4[out_Tmp_476];
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} BAND(out_mask_2, 1) != 0;
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc vslice_dummy_var_1389;
    call {:si_unique_call 1796} MoxaKillAllReadsOrWrites(vslice_dummy_var_1389, WriteQueue__MOXA_DEVICE_EXTENSION(in_Extension_12), CurrentWriteIrp__MOXA_DEVICE_EXTENSION(in_Extension_12));
    goto anon26_Else;

  anon26_Else:
    assume {:partition} yogi_error != 1;
    call {:si_unique_call 1794} out_Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    Mem_T.INT4[out_Tmp_478] := out_oldIrql_14;
    call {:si_unique_call 1795} sdv_KeAcquireSpinLock(0, out_Tmp_478);
    goto anon27_Else;

  anon27_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    out_oldIrql_14 := Mem_T.INT4[out_Tmp_478];
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc vslice_dummy_var_1388;
    call {:si_unique_call 1792} MoxaFunc(vslice_dummy_var_1388, 10, 1);
    call {:si_unique_call 1793} sdv_KeReleaseSpinLock(0, out_oldIrql_14);
    goto L7;

  L7:
    goto anon21_Then, anon21_Else;

  anon21_Else:
    assume {:partition} BAND(out_mask_2, 2) != 0;
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc vslice_dummy_var_1390;
    call {:si_unique_call 1797} MoxaKillAllReadsOrWrites(vslice_dummy_var_1390, ReadQueue__MOXA_DEVICE_EXTENSION(in_Extension_12), CurrentReadIrp__MOXA_DEVICE_EXTENSION(in_Extension_12));
    goto anon28_Else;

  anon28_Else:
    assume {:partition} yogi_error != 1;
    goto L22;

  L22:
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:partition} BAND(out_mask_2, 4) != 0;
    call {:si_unique_call 1798} out_Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    Mem_T.INT4[out_Tmp_478] := out_oldIrql_13;
    call {:si_unique_call 1799} sdv_KeAcquireSpinLock(0, out_Tmp_478);
    goto anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    out_oldIrql_13 := Mem_T.INT4[out_Tmp_478];
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc vslice_dummy_var_1387;
    call {:si_unique_call 1790} MoxaFunc(vslice_dummy_var_1387, 10, 1);
    call {:si_unique_call 1791} sdv_KeReleaseSpinLock(0, out_oldIrql_13);
    goto L26;

  L26:
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} BAND(out_mask_2, 8) != 0;
    call {:si_unique_call 1800} out_Tmp_478 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    Mem_T.INT4[out_Tmp_478] := out_oldIrql_15;
    call {:si_unique_call 1801} sdv_KeAcquireSpinLock(0, out_Tmp_478);
    goto anon30_Else;

  anon30_Else:
    assume {:partition} yogi_error != 1;
    assume {:nonnull} out_Tmp_478 != 0;
    assume out_Tmp_478 > 0;
    out_oldIrql_15 := Mem_T.INT4[out_Tmp_478];
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc vslice_dummy_var_1386;
    call {:si_unique_call 1788} MoxaFunc(vslice_dummy_var_1386, 10, 0);
    call {:si_unique_call 1789} sdv_KeReleaseSpinLock(0, out_oldIrql_15);
    goto L37;

  L37:
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc out_Tmp_477;
    assume {:nonnull} out_Tmp_477 != 0;
    assume out_Tmp_477 > 0;
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    havoc out_Tmp_475;
    assume {:nonnull} out_Tmp_475 != 0;
    assume out_Tmp_475 > 0;
    assume {:nonnull} in_Extension_12 != 0;
    assume in_Extension_12 > 0;
    call {:si_unique_call 1787} MoxaGetNextIrp(CurrentPurgeIrp__MOXA_DEVICE_EXTENSION(in_Extension_12), PurgeQueue__MOXA_DEVICE_EXTENSION(in_Extension_12), in_newIrp_3, 1, in_Extension_12);
    assume {:nonnull} in_newIrp_3 != 0;
    assume in_newIrp_3 > 0;
    goto anon24_Then;

  anon24_Then:
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    call {:si_unique_call 1802} {:si_old_unique_call 1} out_oldIrql_13, out_Tmp_474, out_Tmp_475, out_Tmp_476, out_Tmp_477, out_mask_2, out_Tmp_478, out_oldIrql_14, out_oldIrql_15 := MoxaStartPurge_loop_L5(out_oldIrql_13, out_Tmp_474, out_Tmp_475, out_Tmp_476, out_Tmp_477, out_mask_2, out_Tmp_478, in_newIrp_3, out_oldIrql_14, out_oldIrql_15, in_Extension_12);
    return;

  anon23_Then:
    assume {:partition} BAND(out_mask_2, 8) == 0;
    goto L37;

  anon22_Then:
    assume {:partition} BAND(out_mask_2, 4) == 0;
    goto L26;

  anon21_Then:
    assume {:partition} BAND(out_mask_2, 2) == 0;
    goto L22;

  anon25_Then:
    assume {:partition} BAND(out_mask_2, 1) == 0;
    goto L7;
}



procedure {:LoopProcedure} MoxaStartPurge_loop_L5(in_oldIrql_13: int, in_Tmp_474: int, in_Tmp_475: int, in_Tmp_476: int, in_Tmp_477: int, in_mask_2: int, in_Tmp_478: int, in_newIrp_3: int, in_oldIrql_14: int, in_oldIrql_15: int, in_Extension_12: int) returns (out_oldIrql_13: int, out_Tmp_474: int, out_Tmp_475: int, out_Tmp_476: int, out_Tmp_477: int, out_mask_2: int, out_Tmp_478: int, out_oldIrql_14: int, out_oldIrql_15: int);
  modifies alloc, Mem_T.INT4, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaFinishStartDevice_loop_L151(in_i_2: int, in_pDevExt_3: int, in_Tmp_500: int, in_Tmp_513: int, in_Tmp_522: int, in_Tmp_526: int, in_Tmp_531: int, in_Tmp_532: int, in_Tmp_538: int, in_Tmp_542: int, in_Tmp_544: int, in_Tmp_545: int) returns (out_i_2: int, out_Tmp_500: int, out_Tmp_513: int, out_Tmp_522: int, out_Tmp_526: int, out_Tmp_531: int, out_Tmp_532: int, out_Tmp_538: int, out_Tmp_542: int, out_Tmp_544: int, out_Tmp_545: int)
{

  entry:
    out_i_2, out_Tmp_500, out_Tmp_513, out_Tmp_522, out_Tmp_526, out_Tmp_531, out_Tmp_532, out_Tmp_538, out_Tmp_542, out_Tmp_544, out_Tmp_545 := in_i_2, in_Tmp_500, in_Tmp_513, in_Tmp_522, in_Tmp_526, in_Tmp_531, in_Tmp_532, in_Tmp_538, in_Tmp_542, in_Tmp_544, in_Tmp_545;
    goto L151, exit;

  exit:
    return;

  L151:
    assume {:CounterLoop 4} {:Counter "i_2"} true;
    goto anon85_Else;

  anon85_Else:
    assume {:partition} 4 > out_i_2;
    out_Tmp_544 := out_i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_538;
    assume {:nonnull} out_Tmp_538 != 0;
    assume out_Tmp_538 > 0;
    goto anon109_Then, anon109_Else;

  anon109_Else:
    out_Tmp_532 := out_i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_531;
    assume {:nonnull} in_pDevExt_3 != 0;
    assume in_pDevExt_3 > 0;
    havoc out_Tmp_513;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_545;
    assume {:nonnull} out_Tmp_531 != 0;
    assume out_Tmp_531 > 0;
    assume {:nonnull} out_Tmp_545 != 0;
    assume out_Tmp_545 > 0;
    goto anon110_Then, anon110_Else;

  anon110_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_531 + out_Tmp_532 * 4] == Mem_T.INT4[out_Tmp_545 + out_Tmp_513 * 4];
    out_Tmp_526 := out_i_2;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_500;
    assume {:nonnull} in_pDevExt_3 != 0;
    assume in_pDevExt_3 > 0;
    havoc out_Tmp_522;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_542;
    assume {:nonnull} out_Tmp_500 != 0;
    assume out_Tmp_500 > 0;
    assume {:nonnull} out_Tmp_542 != 0;
    assume out_Tmp_542 > 0;
    goto anon111_Else;

  anon111_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_500 + out_Tmp_526 * 4] != Mem_T.INT4[out_Tmp_542 + out_Tmp_522 * 4];
    goto L154;

  L154:
    out_i_2 := out_i_2 + 1;
    goto L154_dummy;

  L154_dummy:
    havoc out_i_2;
    return;

  anon110_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_531 + out_Tmp_532 * 4] != Mem_T.INT4[out_Tmp_545 + out_Tmp_513 * 4];
    goto L154;

  anon109_Then:
    goto L154;
}



procedure {:LoopProcedure} MoxaFinishStartDevice_loop_L151(in_i_2: int, in_pDevExt_3: int, in_Tmp_500: int, in_Tmp_513: int, in_Tmp_522: int, in_Tmp_526: int, in_Tmp_531: int, in_Tmp_532: int, in_Tmp_538: int, in_Tmp_542: int, in_Tmp_544: int, in_Tmp_545: int) returns (out_i_2: int, out_Tmp_500: int, out_Tmp_513: int, out_Tmp_522: int, out_Tmp_526: int, out_Tmp_531: int, out_Tmp_532: int, out_Tmp_538: int, out_Tmp_542: int, out_Tmp_544: int, out_Tmp_545: int);
  free ensures {:va_keep} out_Tmp_526 == in_i_2 || out_Tmp_526 == in_Tmp_526;
  free ensures {:va_keep} out_Tmp_532 == in_i_2 || out_Tmp_532 == in_Tmp_532;
  free ensures {:va_keep} out_Tmp_544 == in_i_2 || out_Tmp_544 == in_Tmp_544;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 5} MoxaPnpDispatch_loop_L123(in_Tmp_610: int, in_pDevExt_5: int, in_Tmp_612: int, in_cap: int, in_Tmp_613: int, in_pDevCaps: int, in_Tmp_614: int) returns (out_Tmp_610: int, out_Tmp_612: int, out_cap: int, out_Tmp_613: int, out_Tmp_614: int)
{

  entry:
    out_Tmp_610, out_Tmp_612, out_cap, out_Tmp_613, out_Tmp_614 := in_Tmp_610, in_Tmp_612, in_cap, in_Tmp_613, in_Tmp_614;
    goto L123, exit;

  exit:
    return;

  L123:
    assume {:CounterLoop 5} {:Counter "cap"} true;
    goto anon88_Else;

  anon88_Else:
    assume {:partition} 7 > out_cap;
    out_Tmp_610 := out_cap;
    assume {:nonnull} in_pDevExt_5 != 0;
    assume in_pDevExt_5 > 0;
    havoc out_Tmp_612;
    out_Tmp_613 := out_cap;
    assume {:nonnull} in_pDevCaps != 0;
    assume in_pDevCaps > 0;
    havoc out_Tmp_614;
    assume {:nonnull} out_Tmp_612 != 0;
    assume out_Tmp_612 > 0;
    assume {:nonnull} out_Tmp_614 != 0;
    assume out_Tmp_614 > 0;
    Mem_T.INT4[out_Tmp_612 + out_Tmp_610 * 4] := Mem_T.INT4[out_Tmp_614 + out_Tmp_613 * 4];
    out_cap := out_cap + 1;
    goto anon88_Else_dummy;

  anon88_Else_dummy:
    call {:si_unique_call 1803} {:si_old_unique_call 1} out_Tmp_610, out_Tmp_612, out_cap, out_Tmp_613, out_Tmp_614 := MoxaPnpDispatch_loop_L123(out_Tmp_610, in_pDevExt_5, out_Tmp_612, out_cap, out_Tmp_613, in_pDevCaps, out_Tmp_614);
    return;
}



procedure {:LoopProcedure} MoxaPnpDispatch_loop_L123(in_Tmp_610: int, in_pDevExt_5: int, in_Tmp_612: int, in_cap: int, in_Tmp_613: int, in_pDevCaps: int, in_Tmp_614: int) returns (out_Tmp_610: int, out_Tmp_612: int, out_cap: int, out_Tmp_613: int, out_Tmp_614: int);
  modifies Mem_T.INT4;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaWaitFinish1_loop_L5(in_cnt: int, in_Tmp_634: int, in_PortOfs_4: int) returns (out_cnt: int, out_Tmp_634: int)
{

  entry:
    out_cnt, out_Tmp_634 := in_cnt, in_Tmp_634;
    goto L5, exit;

  exit:
    return;

  L5:
    out_Tmp_634 := out_cnt;
    out_cnt := out_cnt - 1;
    goto anon6_Else;

  anon6_Else:
    assume {:partition} out_Tmp_634 != 0;
    assume {:nonnull} in_PortOfs_4 != 0;
    assume in_PortOfs_4 > 0;
    goto anon5_Else;

  anon5_Else:
    assume {:partition} Mem_T.INT4[in_PortOfs_4] != 0;
    call {:si_unique_call 1804} MoxaDelay(1);
    goto anon5_Else_dummy;

  anon5_Else_dummy:
    call {:si_unique_call 1805} {:si_old_unique_call 1} out_cnt, out_Tmp_634 := MoxaWaitFinish1_loop_L5(out_cnt, out_Tmp_634, in_PortOfs_4);
    return;
}



procedure {:LoopProcedure} MoxaWaitFinish1_loop_L5(in_cnt: int, in_Tmp_634: int, in_PortOfs_4: int) returns (out_cnt: int, out_Tmp_634: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaUnstallIrps_loop_L13(in_Tmp_643: int, in_sdv_221: int, in_Tmp_645: int, in_oldIrql_17: int, in_pIrpStack_5: int, in_Tmp_646: int, in_pIrp: int, in_pDevObj_1: int, in_pDrvObj: int, in_pIrpLink: int, in_vslice_dummy_var_134: int, in_vslice_dummy_var_135: int) returns (out_Tmp_643: int, out_sdv_221: int, out_Tmp_645: int, out_oldIrql_17: int, out_pIrpStack_5: int, out_Tmp_646: int, out_pIrp: int, out_pDevObj_1: int, out_pDrvObj: int, out_pIrpLink: int, out_vslice_dummy_var_134: int, out_vslice_dummy_var_135: int)
{

  entry:
    out_Tmp_643, out_sdv_221, out_Tmp_645, out_oldIrql_17, out_pIrpStack_5, out_Tmp_646, out_pIrp, out_pDevObj_1, out_pDrvObj, out_pIrpLink, out_vslice_dummy_var_134, out_vslice_dummy_var_135 := in_Tmp_643, in_sdv_221, in_Tmp_645, in_oldIrql_17, in_pIrpStack_5, in_Tmp_646, in_pIrp, in_pDevObj_1, in_pDrvObj, in_pIrpLink, in_vslice_dummy_var_134, in_vslice_dummy_var_135;
    goto L13, exit;

  exit:
    return;

  L13:
    goto anon59_Else;

  anon59_Else:
    call {:si_unique_call 1808} out_sdv_221 := sdv_containing_record(out_pIrpLink, 88);
    out_pIrp := out_sdv_221;
    assume {:nonnull} out_pIrp != 0;
    assume out_pIrp > 0;
    havoc out_pIrpLink;
    call {:si_unique_call 1809} out_vslice_dummy_var_134 := sdv_RemoveEntryList(0);
    call {:si_unique_call 1810} out_pIrpStack_5 := sdv_IoGetCurrentIrpStackLocation(out_pIrp);
    assume {:nonnull} out_pIrpStack_5 != 0;
    assume out_pIrpStack_5 > 0;
    havoc out_pDevObj_1;
    assume {:nonnull} out_pDevObj_1 != 0;
    assume out_pDevObj_1 > 0;
    havoc out_pDrvObj;
    call {:si_unique_call 1811} out_vslice_dummy_var_135 := sdv_IoSetCancelRoutine(out_pIrp, 0);
    call {:si_unique_call 1812} IoReleaseCancelSpinLock(out_oldIrql_17);
    assume {:nonnull} out_pIrpStack_5 != 0;
    assume out_pIrpStack_5 > 0;
    havoc out_Tmp_645;
    assume {:nonnull} out_pDrvObj != 0;
    assume out_pDrvObj > 0;
    havoc out_Tmp_643;
    goto anon60_Then, anon60_Else;

  anon60_Else:
    assume out_Tmp_645 != 27;
    goto anon61_Then, anon61_Else;

  anon61_Else:
    assume out_Tmp_645 != 26;
    goto anon62_Then, anon62_Else;

  anon62_Else:
    assume out_Tmp_645 != 25;
    goto anon63_Then, anon63_Else;

  anon63_Else:
    assume out_Tmp_645 != 24;
    goto anon64_Then, anon64_Else;

  anon64_Else:
    assume out_Tmp_645 != 23;
    goto anon65_Then, anon65_Else;

  anon65_Else:
    assume out_Tmp_645 != 22;
    goto anon66_Then, anon66_Else;

  anon66_Else:
    assume out_Tmp_645 != 21;
    goto anon67_Then, anon67_Else;

  anon67_Else:
    assume out_Tmp_645 != 20;
    goto anon68_Then, anon68_Else;

  anon68_Else:
    assume out_Tmp_645 != 19;
    goto anon69_Then, anon69_Else;

  anon69_Else:
    assume out_Tmp_645 != 18;
    goto anon70_Then, anon70_Else;

  anon70_Else:
    assume out_Tmp_645 != 17;
    goto anon71_Then, anon71_Else;

  anon71_Else:
    assume out_Tmp_645 != 16;
    goto anon72_Then, anon72_Else;

  anon72_Else:
    assume out_Tmp_645 != 15;
    goto anon73_Then, anon73_Else;

  anon73_Else:
    assume out_Tmp_645 != 14;
    goto anon74_Then, anon74_Else;

  anon74_Else:
    assume out_Tmp_645 != 13;
    goto anon75_Then, anon75_Else;

  anon75_Else:
    assume out_Tmp_645 != 12;
    goto anon76_Then, anon76_Else;

  anon76_Else:
    assume out_Tmp_645 != 11;
    goto anon77_Then, anon77_Else;

  anon77_Else:
    assume out_Tmp_645 != 10;
    goto anon78_Then, anon78_Else;

  anon78_Else:
    assume out_Tmp_645 != 9;
    goto anon79_Then, anon79_Else;

  anon79_Else:
    assume out_Tmp_645 != 8;
    goto anon80_Then, anon80_Else;

  anon80_Else:
    assume out_Tmp_645 != 7;
    goto anon81_Then, anon81_Else;

  anon81_Else:
    assume out_Tmp_645 != 6;
    goto anon82_Then, anon82_Else;

  anon82_Else:
    assume out_Tmp_645 != 5;
    goto anon83_Then, anon83_Else;

  anon83_Else:
    assume out_Tmp_645 != 4;
    goto anon84_Then, anon84_Else;

  anon84_Else:
    assume out_Tmp_645 != 3;
    goto anon85_Then, anon85_Else;

  anon85_Else:
    assume out_Tmp_645 != 2;
    goto anon86_Then, anon86_Else;

  anon86_Else:
    assume out_Tmp_645 != 1;
    goto anon87_Then;

  anon87_Then:
    assume out_Tmp_645 == 0;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643] == 0;
    goto L40;

  L40:
    call {:si_unique_call 1806} out_Tmp_646 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_646 != 0;
    assume out_Tmp_646 > 0;
    Mem_T.INT4[out_Tmp_646] := out_oldIrql_17;
    call {:si_unique_call 1807} IoAcquireCancelSpinLock(out_Tmp_646);
    assume {:nonnull} out_Tmp_646 != 0;
    assume out_Tmp_646 > 0;
    out_oldIrql_17 := Mem_T.INT4[out_Tmp_646];
    goto L40_dummy;

  L40_dummy:
    call {:si_unique_call 1813} {:si_old_unique_call 1} out_Tmp_643, out_sdv_221, out_Tmp_645, out_oldIrql_17, out_pIrpStack_5, out_Tmp_646, out_pIrp, out_pDevObj_1, out_pDrvObj, out_pIrpLink, out_vslice_dummy_var_134, out_vslice_dummy_var_135 := MoxaUnstallIrps_loop_L13(out_Tmp_643, out_sdv_221, out_Tmp_645, out_oldIrql_17, out_pIrpStack_5, out_Tmp_646, out_pIrp, out_pDevObj_1, out_pDrvObj, out_pIrpLink, out_vslice_dummy_var_134, out_vslice_dummy_var_135);
    return;

  anon86_Then:
    assume out_Tmp_645 == 1;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 1 * 4] == 0;
    goto L40;

  anon85_Then:
    assume out_Tmp_645 == 2;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 2 * 4] == 0;
    goto L40;

  anon84_Then:
    assume out_Tmp_645 == 3;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 3 * 4] == 0;
    goto L40;

  anon83_Then:
    assume out_Tmp_645 == 4;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 4 * 4] == 0;
    goto L40;

  anon82_Then:
    assume out_Tmp_645 == 5;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 5 * 4] == 0;
    goto L40;

  anon81_Then:
    assume out_Tmp_645 == 6;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 6 * 4] == 0;
    goto L40;

  anon80_Then:
    assume out_Tmp_645 == 7;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 7 * 4] == 0;
    goto L40;

  anon79_Then:
    assume out_Tmp_645 == 8;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 8 * 4] == 0;
    goto L40;

  anon78_Then:
    assume out_Tmp_645 == 9;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 9 * 4] == 0;
    goto L40;

  anon77_Then:
    assume out_Tmp_645 == 10;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 10 * 4] == 0;
    goto L40;

  anon76_Then:
    assume out_Tmp_645 == 11;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 11 * 4] == 0;
    goto L40;

  anon75_Then:
    assume out_Tmp_645 == 12;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 12 * 4] == 0;
    goto L40;

  anon74_Then:
    assume out_Tmp_645 == 13;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 13 * 4] == 0;
    goto L40;

  anon73_Then:
    assume out_Tmp_645 == 14;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 14 * 4] == 0;
    goto L40;

  anon72_Then:
    assume out_Tmp_645 == 15;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 15 * 4] == 0;
    goto L40;

  anon71_Then:
    assume out_Tmp_645 == 16;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 16 * 4] == 0;
    goto L40;

  anon70_Then:
    assume out_Tmp_645 == 17;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 17 * 4] == 0;
    goto L40;

  anon69_Then:
    assume out_Tmp_645 == 18;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 18 * 4] == 0;
    goto L40;

  anon68_Then:
    assume out_Tmp_645 == 19;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 19 * 4] == 0;
    goto L40;

  anon67_Then:
    assume out_Tmp_645 == 20;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 20 * 4] == 0;
    goto L40;

  anon66_Then:
    assume out_Tmp_645 == 21;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 21 * 4] == 0;
    goto L40;

  anon65_Then:
    assume out_Tmp_645 == 22;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 22 * 4] == 0;
    goto L40;

  anon64_Then:
    assume out_Tmp_645 == 23;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 23 * 4] == 0;
    goto L40;

  anon63_Then:
    assume out_Tmp_645 == 24;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 24 * 4] == 0;
    goto L40;

  anon62_Then:
    assume out_Tmp_645 == 25;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 25 * 4] == 0;
    goto L40;

  anon61_Then:
    assume out_Tmp_645 == 26;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 26 * 4] == 0;
    goto L40;

  anon60_Then:
    assume out_Tmp_645 == 27;
    assume {:nonnull} out_Tmp_643 != 0;
    assume out_Tmp_643 > 0;
    assume Mem_T.INT4[out_Tmp_643 + 27 * 4] == 0;
    goto L40;
}



procedure {:LoopProcedure} MoxaUnstallIrps_loop_L13(in_Tmp_643: int, in_sdv_221: int, in_Tmp_645: int, in_oldIrql_17: int, in_pIrpStack_5: int, in_Tmp_646: int, in_pIrp: int, in_pDevObj_1: int, in_pDrvObj: int, in_pIrpLink: int, in_vslice_dummy_var_134: int, in_vslice_dummy_var_135: int) returns (out_Tmp_643: int, out_sdv_221: int, out_Tmp_645: int, out_oldIrql_17: int, out_pIrpStack_5: int, out_Tmp_646: int, out_pIrp: int, out_pDevObj_1: int, out_pDrvObj: int, out_pIrpLink: int, out_vslice_dummy_var_134: int, out_vslice_dummy_var_135: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelRoutine__IRP;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_current == 2 || sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} out_vslice_dummy_var_134 == 1 || out_vslice_dummy_var_134 == 0 || out_vslice_dummy_var_134 == in_vslice_dummy_var_134;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaKillAllReadsOrWrites_loop_L8(in_currentLastIrp: int, in_cancelIrql: int, in_sdv_226: int, in_sdv_227: int, in_cancelRoutine_1: int, in_Tmp_654: int, in_DeviceObject_11: int, in_QueueToClean: int, in_vslice_dummy_var_137: int) returns (out_currentLastIrp: int, out_cancelIrql: int, out_sdv_226: int, out_sdv_227: int, out_cancelRoutine_1: int, out_Tmp_654: int, out_vslice_dummy_var_137: int)
{
  var vslice_dummy_var_1391: int;

  entry:
    out_currentLastIrp, out_cancelIrql, out_sdv_226, out_sdv_227, out_cancelRoutine_1, out_Tmp_654, out_vslice_dummy_var_137 := in_currentLastIrp, in_cancelIrql, in_sdv_226, in_sdv_227, in_cancelRoutine_1, in_Tmp_654, in_vslice_dummy_var_137;
    goto L8, exit;

  exit:
    return;

  L8:
    call {:si_unique_call 1814} out_sdv_226 := sdv_IsListEmpty(0);
    goto anon29_Else;

  anon29_Else:
    assume {:partition} out_sdv_226 == 0;
    assume {:nonnull} in_QueueToClean != 0;
    assume in_QueueToClean > 0;
    havoc vslice_dummy_var_1391;
    call {:si_unique_call 1819} out_sdv_227 := sdv_containing_record(vslice_dummy_var_1391, 88);
    out_currentLastIrp := out_sdv_227;
    call {:si_unique_call 1820} out_vslice_dummy_var_137 := sdv_RemoveEntryList(0);
    assume {:nonnull} out_currentLastIrp != 0;
    assume out_currentLastIrp > 0;
    out_cancelRoutine_1 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(out_currentLastIrp)];
    assume {:nonnull} out_currentLastIrp != 0;
    assume out_currentLastIrp > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(out_currentLastIrp)] := out_cancelIrql;
    assume {:nonnull} out_currentLastIrp != 0;
    assume out_currentLastIrp > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(out_currentLastIrp)] := 0;
    assume {:nonnull} out_currentLastIrp != 0;
    assume out_currentLastIrp > 0;
    goto anon40_Then, anon40_Else;

  anon40_Else:
    assume {:partition} out_cancelRoutine_1 != 0;
    goto anon31_Then, anon31_Else;

  anon31_Else:
    goto anon34_Then, anon34_Else;

  anon34_Else:
    goto anon35_Then, anon35_Else;

  anon35_Else:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_1 == li2bplFunctionConstant321;
    call {:si_unique_call 1822} MoxaCancelCurrentWrite(in_DeviceObject_11, out_currentLastIrp);
    goto anon42_Else;

  anon42_Else:
    assume {:partition} yogi_error != 1;
    goto L43;

  L43:
    call {:si_unique_call 1815} out_Tmp_654 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_654 != 0;
    assume out_Tmp_654 > 0;
    Mem_T.INT4[out_Tmp_654] := out_cancelIrql;
    call {:si_unique_call 1816} IoAcquireCancelSpinLock(out_Tmp_654);
    assume {:nonnull} out_Tmp_654 != 0;
    assume out_Tmp_654 > 0;
    out_cancelIrql := Mem_T.INT4[out_Tmp_654];
    goto L43_dummy;

  L43_dummy:
    goto L_BAF_0;

  L_BAF_0:
    call {:si_unique_call 1823} {:si_old_unique_call 1} out_currentLastIrp, out_cancelIrql, out_sdv_226, out_sdv_227, out_cancelRoutine_1, out_Tmp_654, out_vslice_dummy_var_137 := MoxaKillAllReadsOrWrites_loop_L8(out_currentLastIrp, out_cancelIrql, out_sdv_226, out_sdv_227, out_cancelRoutine_1, out_Tmp_654, in_DeviceObject_11, in_QueueToClean, out_vslice_dummy_var_137);
    return;

  anon35_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_1 == li2bplFunctionConstant188;
    call {:si_unique_call 1817} MoxaCancelQueued(in_DeviceObject_11, out_currentLastIrp);
    goto L43;

  anon34_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_1 == li2bplFunctionConstant418;
    call {:si_unique_call 1821} MoxaCancelWait(in_DeviceObject_11, out_currentLastIrp);
    goto anon41_Else;

  anon41_Else:
    assume {:partition} yogi_error != 1;
    goto L43;

  anon31_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_1 == li2bplFunctionConstant202;
    call {:si_unique_call 1818} MoxaFilterCancelQueued(in_DeviceObject_11, out_currentLastIrp);
    goto L43;

  anon40_Then:
    assume {:partition} out_cancelRoutine_1 == 0;
    goto anon40_Then_dummy;

  anon40_Then_dummy:
    goto L_BAF_0;
}



procedure {:LoopProcedure} MoxaKillAllReadsOrWrites_loop_L8(in_currentLastIrp: int, in_cancelIrql: int, in_sdv_226: int, in_sdv_227: int, in_cancelRoutine_1: int, in_Tmp_654: int, in_DeviceObject_11: int, in_QueueToClean: int, in_vslice_dummy_var_137: int) returns (out_currentLastIrp: int, out_cancelIrql: int, out_sdv_226: int, out_sdv_227: int, out_cancelRoutine_1: int, out_Tmp_654: int, out_vslice_dummy_var_137: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_current == 2 || sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} out_sdv_226 == 1 || out_sdv_226 == 0 || out_sdv_226 == in_sdv_226;
  free ensures {:va_keep} out_vslice_dummy_var_137 == 1 || out_vslice_dummy_var_137 == 0 || out_vslice_dummy_var_137 == in_vslice_dummy_var_137;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaCleanInterruptShareLists_loop_L28(in_interruptEntry_1: int, in_dispatch_2: int, in_cisrsw_2: int, in_sdv_247: int, in_cardNo_2: int, in_pDevExt_8: int) returns (out_interruptEntry_1: int, out_dispatch_2: int, out_cisrsw_2: int, out_sdv_247: int, out_cardNo_2: int)
{

  entry:
    out_interruptEntry_1, out_dispatch_2, out_cisrsw_2, out_sdv_247, out_cardNo_2 := in_interruptEntry_1, in_dispatch_2, in_cisrsw_2, in_sdv_247, in_cardNo_2;
    goto L28, exit;

  exit:
    return;

  L28:
    call {:si_unique_call 1824} out_sdv_247 := sdv_containing_record(out_interruptEntry_1, 8);
    out_cisrsw_2 := out_sdv_247;
    goto anon25_Else;

  anon25_Else:
    assume {:partition} out_cisrsw_2 != 0;
    assume {:nonnull} out_cisrsw_2 != 0;
    assume out_cisrsw_2 > 0;
    out_dispatch_2 := Dispatch__MOXA_CISR_SW(out_cisrsw_2);
    assume {:nonnull} out_dispatch_2 != 0;
    assume out_dispatch_2 > 0;
    havoc out_cardNo_2;
    assume {:nonnull} in_pDevExt_8 != 0;
    assume in_pDevExt_8 > 0;
    goto anon26_Then;

  anon26_Then:
    assume {:nonnull} out_interruptEntry_1 != 0;
    assume out_interruptEntry_1 > 0;
    havoc out_interruptEntry_1;
    goto anon27_Then;

  anon27_Then:
    goto anon27_Then_dummy;

  anon27_Then_dummy:
    havoc out_interruptEntry_1;
    return;
}



procedure {:LoopProcedure} MoxaCleanInterruptShareLists_loop_L28(in_interruptEntry_1: int, in_dispatch_2: int, in_cisrsw_2: int, in_sdv_247: int, in_cardNo_2: int, in_pDevExt_8: int) returns (out_interruptEntry_1: int, out_dispatch_2: int, out_cisrsw_2: int, out_sdv_247: int, out_cardNo_2: int);
  free ensures {:va_keep} out_dispatch_2 == in_dispatch_2 || out_dispatch_2 == Dispatch__MOXA_CISR_SW(in_interruptEntry_1);
  free ensures {:va_keep} out_cisrsw_2 == in_interruptEntry_1 || out_cisrsw_2 == in_cisrsw_2;
  free ensures {:va_keep} out_sdv_247 == in_interruptEntry_1 || out_sdv_247 == in_sdv_247;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaCleanInterruptShareLists_loop_L18(in_i_3: int, in_Tmp_673: int, in_Tmp_674: int, in_globalData_1: int, in_pDevExt1: int, in_port_2: int, in_Tmp_679: int, in_Tmp_680: int, in_pDevExt_8: int) returns (out_i_3: int, out_Tmp_673: int, out_Tmp_674: int, out_pDevExt1: int, out_port_2: int, out_Tmp_679: int, out_Tmp_680: int)
{

  entry:
    out_i_3, out_Tmp_673, out_Tmp_674, out_pDevExt1, out_port_2, out_Tmp_679, out_Tmp_680 := in_i_3, in_Tmp_673, in_Tmp_674, in_pDevExt1, in_port_2, in_Tmp_679, in_Tmp_680;
    goto L18, exit;

  exit:
    return;

  L18:
    assume {:nonnull} in_pDevExt_8 != 0;
    assume in_pDevExt_8 > 0;
    havoc out_Tmp_673;
    assume {:nonnull} in_globalData_1 != 0;
    assume in_globalData_1 > 0;
    havoc out_Tmp_679;
    assume {:nonnull} out_Tmp_679 != 0;
    assume out_Tmp_679 > 0;
    goto anon22_Else;

  anon22_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_679 + out_Tmp_673 * 4] > out_i_3;
    assume {:nonnull} in_pDevExt_8 != 0;
    assume in_pDevExt_8 > 0;
    havoc out_port_2;
    out_Tmp_680 := out_port_2;
    assume {:nonnull} in_globalData_1 != 0;
    assume in_globalData_1 > 0;
    havoc out_Tmp_674;
    assume {:nonnull} out_Tmp_674 != 0;
    assume out_Tmp_674 > 0;
    havoc out_pDevExt1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} out_pDevExt1 != 0;
    assume {:nonnull} out_pDevExt1 != 0;
    assume out_pDevExt1 > 0;
    assume {:nonnull} in_pDevExt_8 != 0;
    assume in_pDevExt_8 > 0;
    goto anon20_Else;

  anon20_Else:
    goto L23;

  L23:
    out_i_3 := out_i_3 + 1;
    goto L23_dummy;

  L23_dummy:
    havoc out_i_3;
    return;

  anon23_Then:
    assume {:partition} out_pDevExt1 == 0;
    goto L23;
}



procedure {:LoopProcedure} MoxaCleanInterruptShareLists_loop_L18(in_i_3: int, in_Tmp_673: int, in_Tmp_674: int, in_globalData_1: int, in_pDevExt1: int, in_port_2: int, in_Tmp_679: int, in_Tmp_680: int, in_pDevExt_8: int) returns (out_i_3: int, out_Tmp_673: int, out_Tmp_674: int, out_pDevExt1: int, out_port_2: int, out_Tmp_679: int, out_Tmp_680: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaReleaseResources_loop_L38(in_Tmp_738: int, in_pDevObj_2: int) returns (out_Tmp_738: int, out_pDevObj_2: int)
{

  entry:
    out_Tmp_738, out_pDevObj_2 := in_Tmp_738, in_pDevObj_2;
    goto L38, exit;

  exit:
    return;

  L38:
    goto anon47_Else;

  anon47_Else:
    assume {:partition} out_pDevObj_2 != 0;
    assume {:nonnull} out_pDevObj_2 != 0;
    assume out_pDevObj_2 > 0;
    havoc out_Tmp_738;
    assume {:nonnull} out_Tmp_738 != 0;
    assume out_Tmp_738 > 0;
    goto anon59_Then;

  anon59_Then:
    assume {:nonnull} out_pDevObj_2 != 0;
    assume out_pDevObj_2 > 0;
    havoc out_pDevObj_2;
    goto anon59_Then_dummy;

  anon59_Then_dummy:
    havoc out_pDevObj_2;
    return;
}



procedure {:LoopProcedure} MoxaReleaseResources_loop_L38(in_Tmp_738: int, in_pDevObj_2: int) returns (out_Tmp_738: int, out_pDevObj_2: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaReleaseResources_loop_L25(in_i_4: int, in_Tmp_715: int, in_Tmp_725: int, in_pDevExt_10: int) returns (out_i_4: int, out_Tmp_715: int, out_Tmp_725: int)
{

  entry:
    out_i_4, out_Tmp_715, out_Tmp_725 := in_i_4, in_Tmp_715, in_Tmp_725;
    goto L25, exit;

  exit:
    return;

  L25:
    assume {:CounterLoop 4} {:Counter "i_4"} true;
    goto anon44_Else;

  anon44_Else:
    assume {:partition} 4 > out_i_4;
    out_Tmp_715 := out_i_4;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_725;
    assume {:nonnull} out_Tmp_725 != 0;
    assume out_Tmp_725 > 0;
    goto anon58_Then, anon58_Else;

  anon58_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_725 + out_Tmp_715 * 4] != 0;
    assume {:nonnull} in_pDevExt_10 != 0;
    assume in_pDevExt_10 > 0;
    goto anon46_Else;

  anon46_Else:
    goto L28;

  L28:
    out_i_4 := out_i_4 + 1;
    goto L28_dummy;

  L28_dummy:
    havoc out_i_4;
    return;

  anon58_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_725 + out_Tmp_715 * 4] == 0;
    goto L28;
}



procedure {:LoopProcedure} MoxaReleaseResources_loop_L25(in_i_4: int, in_Tmp_715: int, in_Tmp_725: int, in_pDevExt_10: int) returns (out_i_4: int, out_Tmp_715: int, out_Tmp_725: int);
  free ensures {:va_keep} out_Tmp_715 == in_i_4 || out_Tmp_715 == in_Tmp_715;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaReleaseResources_loop_L14(in_i_4: int, in_Tmp_713: int, in_Tmp_717: int, in_port_3: int, in_pDevExt1_1: int, in_Tmp_734: int, in_Tmp_740: int, in_pDevExt_10: int) returns (out_i_4: int, out_Tmp_713: int, out_Tmp_717: int, out_port_3: int, out_pDevExt1_1: int, out_Tmp_734: int, out_Tmp_740: int)
{

  entry:
    out_i_4, out_Tmp_713, out_Tmp_717, out_port_3, out_pDevExt1_1, out_Tmp_734, out_Tmp_740 := in_i_4, in_Tmp_713, in_Tmp_717, in_port_3, in_pDevExt1_1, in_Tmp_734, in_Tmp_740;
    goto L14, exit;

  exit:
    return;

  L14:
    assume {:nonnull} in_pDevExt_10 != 0;
    assume in_pDevExt_10 > 0;
    havoc out_Tmp_713;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_734;
    assume {:nonnull} out_Tmp_734 != 0;
    assume out_Tmp_734 > 0;
    goto anon55_Else;

  anon55_Else:
    assume {:partition} Mem_T.INT4[out_Tmp_734 + out_Tmp_713 * 4] > out_i_4;
    assume {:nonnull} in_pDevExt_10 != 0;
    assume in_pDevExt_10 > 0;
    havoc out_port_3;
    out_Tmp_740 := out_port_3;
    assume {:nonnull} MoxaGlobalData != 0;
    assume MoxaGlobalData > 0;
    havoc out_Tmp_717;
    assume {:nonnull} out_Tmp_717 != 0;
    assume out_Tmp_717 > 0;
    havoc out_pDevExt1_1;
    goto anon56_Then, anon56_Else;

  anon56_Else:
    assume {:partition} out_pDevExt1_1 != 0;
    assume {:nonnull} out_pDevExt1_1 != 0;
    assume out_pDevExt1_1 > 0;
    assume {:nonnull} in_pDevExt_10 != 0;
    assume in_pDevExt_10 > 0;
    goto anon43_Else;

  anon43_Else:
    goto L19;

  L19:
    out_i_4 := out_i_4 + 1;
    goto L19_dummy;

  L19_dummy:
    havoc out_i_4;
    return;

  anon56_Then:
    assume {:partition} out_pDevExt1_1 == 0;
    goto L19;
}



procedure {:LoopProcedure} MoxaReleaseResources_loop_L14(in_i_4: int, in_Tmp_713: int, in_Tmp_717: int, in_port_3: int, in_pDevExt1_1: int, in_Tmp_734: int, in_Tmp_740: int, in_pDevExt_10: int) returns (out_i_4: int, out_Tmp_713: int, out_Tmp_717: int, out_port_3: int, out_pDevExt1_1: int, out_Tmp_734: int, out_Tmp_740: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaKillAllStalled_loop_L10(in_currentLastIrp_1: int, in_cancelIrql_1: int, in_pDevExt_11: int, in_sdv_284: int, in_Tmp_764: int, in_sdv_285: int, in_cancelRoutine_3: int, in_PDevObj_12: int, in_vslice_dummy_var_171: int) returns (out_currentLastIrp_1: int, out_cancelIrql_1: int, out_sdv_284: int, out_Tmp_764: int, out_sdv_285: int, out_cancelRoutine_3: int, out_vslice_dummy_var_171: int)
{
  var vslice_dummy_var_1392: int;

  entry:
    out_currentLastIrp_1, out_cancelIrql_1, out_sdv_284, out_Tmp_764, out_sdv_285, out_cancelRoutine_3, out_vslice_dummy_var_171 := in_currentLastIrp_1, in_cancelIrql_1, in_sdv_284, in_Tmp_764, in_sdv_285, in_cancelRoutine_3, in_vslice_dummy_var_171;
    goto L10, exit;

  exit:
    return;

  L10:
    call {:si_unique_call 1825} out_sdv_284 := sdv_IsListEmpty(0);
    goto anon13_Else;

  anon13_Else:
    assume {:partition} out_sdv_284 == 0;
    assume {:nonnull} in_pDevExt_11 != 0;
    assume in_pDevExt_11 > 0;
    havoc vslice_dummy_var_1392;
    call {:si_unique_call 1830} out_sdv_285 := sdv_containing_record(vslice_dummy_var_1392, 88);
    out_currentLastIrp_1 := out_sdv_285;
    call {:si_unique_call 1831} out_vslice_dummy_var_171 := sdv_RemoveEntryList(0);
    assume {:nonnull} out_currentLastIrp_1 != 0;
    assume out_currentLastIrp_1 > 0;
    out_cancelRoutine_3 := Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(out_currentLastIrp_1)];
    assume {:nonnull} out_currentLastIrp_1 != 0;
    assume out_currentLastIrp_1 > 0;
    Mem_T.CancelIrql__IRP[CancelIrql__IRP(out_currentLastIrp_1)] := out_cancelIrql_1;
    assume {:nonnull} out_currentLastIrp_1 != 0;
    assume out_currentLastIrp_1 > 0;
    Mem_T.CancelRoutine__IRP[CancelRoutine__IRP(out_currentLastIrp_1)] := 0;
    assume {:nonnull} out_currentLastIrp_1 != 0;
    assume out_currentLastIrp_1 > 0;
    goto anon16_Then, anon16_Else;

  anon16_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_3 == li2bplFunctionConstant321;
    call {:si_unique_call 1833} MoxaCancelCurrentWrite(in_PDevObj_12, out_currentLastIrp_1);
    goto anon18_Else;

  anon18_Else:
    assume {:partition} yogi_error != 1;
    goto L32;

  L32:
    call {:si_unique_call 1826} out_Tmp_764 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_764 != 0;
    assume out_Tmp_764 > 0;
    Mem_T.INT4[out_Tmp_764] := out_cancelIrql_1;
    call {:si_unique_call 1827} IoAcquireCancelSpinLock(out_Tmp_764);
    assume {:nonnull} out_Tmp_764 != 0;
    assume out_Tmp_764 > 0;
    out_cancelIrql_1 := Mem_T.INT4[out_Tmp_764];
    goto L32_dummy;

  L32_dummy:
    call {:si_unique_call 1834} {:si_old_unique_call 1} out_currentLastIrp_1, out_cancelIrql_1, out_sdv_284, out_Tmp_764, out_sdv_285, out_cancelRoutine_3, out_vslice_dummy_var_171 := MoxaKillAllStalled_loop_L10(out_currentLastIrp_1, out_cancelIrql_1, in_pDevExt_11, out_sdv_284, out_Tmp_764, out_sdv_285, out_cancelRoutine_3, in_PDevObj_12, out_vslice_dummy_var_171);
    return;

  anon15_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_3 == li2bplFunctionConstant188;
    call {:si_unique_call 1828} MoxaCancelQueued(in_PDevObj_12, out_currentLastIrp_1);
    goto L32;

  anon14_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_3 == li2bplFunctionConstant418;
    call {:si_unique_call 1832} MoxaCancelWait(in_PDevObj_12, out_currentLastIrp_1);
    goto anon17_Else;

  anon17_Else:
    assume {:partition} yogi_error != 1;
    goto L32;

  anon16_Then:
    assume {:IndirectCall} true;
    assume out_cancelRoutine_3 == li2bplFunctionConstant202;
    call {:si_unique_call 1829} MoxaFilterCancelQueued(in_PDevObj_12, out_currentLastIrp_1);
    goto L32;
}



procedure {:LoopProcedure} MoxaKillAllStalled_loop_L10(in_currentLastIrp_1: int, in_cancelIrql_1: int, in_pDevExt_11: int, in_sdv_284: int, in_Tmp_764: int, in_sdv_285: int, in_cancelRoutine_3: int, in_PDevObj_12: int, in_vslice_dummy_var_171: int) returns (out_currentLastIrp_1: int, out_cancelIrql_1: int, out_sdv_284: int, out_Tmp_764: int, out_sdv_285: int, out_cancelRoutine_3: int, out_vslice_dummy_var_171: int);
  modifies alloc, Mem_T.INT4, sdv_irql_previous_5, sdv_irql_previous_4, sdv_irql_previous_3, sdv_irql_previous_2, sdv_irql_previous, sdv_irql_current, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} sdv_irql_current == 2 || sdv_irql_current == old(sdv_irql_current);
  free ensures {:va_keep} out_sdv_284 == 1 || out_sdv_284 == 0 || out_sdv_284 == in_sdv_284;
  free ensures {:va_keep} out_vslice_dummy_var_171 == 1 || out_vslice_dummy_var_171 == 0 || out_vslice_dummy_var_171 == in_vslice_dummy_var_171;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaWaitFinish_loop_L42(in_newTc: int, in_s_p_e_c_i_a_l_2: int)
{

  entry:
    goto L42, exit;

  exit:
    return;

  L42:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_2 != 0;
    assume in_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_2 != 0;
    assume in_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_2 != 0;
    assume in_s_p_e_c_i_a_l_2 > 0;
    goto anon22_Then;

  anon22_Then:
    goto anon22_Then_dummy;

  anon22_Then_dummy:
    call {:si_unique_call 1835} {:si_old_unique_call 1} MoxaWaitFinish_loop_L42(in_newTc, in_s_p_e_c_i_a_l_2);
    return;
}



procedure {:LoopProcedure} MoxaWaitFinish_loop_L42(in_newTc: int, in_s_p_e_c_i_a_l_2: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaWaitFinish_loop_L40(in_count_6: int, in_Tmp_792: int, in_newTc: int, in_s_p_e_c_i_a_l_2: int, in_targetTc_1: int, in_boogieTmp: int) returns (out_count_6: int, out_Tmp_792: int, out_s_p_e_c_i_a_l_2: int, out_boogieTmp: int)
{

  entry:
    out_count_6, out_Tmp_792, out_s_p_e_c_i_a_l_2, out_boogieTmp := in_count_6, in_Tmp_792, in_s_p_e_c_i_a_l_2, in_boogieTmp;
    goto L40, exit;

  exit:
    return;

  L40:
    out_Tmp_792 := KeTickCount;
    assume {:nonnull} out_Tmp_792 != 0;
    assume out_Tmp_792 > 0;
    havoc out_s_p_e_c_i_a_l_2;
    goto L42;

  L42:
    call {:si_unique_call 1841} MoxaWaitFinish_loop_L42(in_newTc, out_s_p_e_c_i_a_l_2);
    goto L42_last;

  L42_last:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1836} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1837} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1838} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1839} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1840} out_boogieTmp := corral_nondet();
    out_count_6 := out_count_6 + 1;
    goto anon23_Then;

  anon23_Then:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon19_Then;

  anon19_Then:
    goto anon19_Then_dummy;

  anon19_Then_dummy:
    call {:si_unique_call 1842} {:si_old_unique_call 1} out_count_6, out_Tmp_792, out_s_p_e_c_i_a_l_2, out_boogieTmp := MoxaWaitFinish_loop_L40(out_count_6, out_Tmp_792, in_newTc, out_s_p_e_c_i_a_l_2, in_targetTc_1, out_boogieTmp);
    return;

  anon17_Then:
    goto L64;

  anon22_Then:
    assume false;
    return;
}



procedure {:LoopProcedure} MoxaWaitFinish_loop_L40(in_count_6: int, in_Tmp_792: int, in_newTc: int, in_s_p_e_c_i_a_l_2: int, in_targetTc_1: int, in_boogieTmp: int) returns (out_count_6: int, out_Tmp_792: int, out_s_p_e_c_i_a_l_2: int, out_boogieTmp: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaWaitFinish_loop_L38(in_SD1_2: int, in_count_6: int, in_cnt_1: int, in_interval_1: int, in_Tmp_792: int, in_newTc: int, in_s_p_e_c_i_a_l_2: int, in_Tmp_793: int, in_targetTc_1: int, in_PortOfs_8: int, in_boogieTmp: int) returns (out_SD1_2: int, out_count_6: int, out_cnt_1: int, out_Tmp_792: int, out_s_p_e_c_i_a_l_2: int, out_Tmp_793: int, out_boogieTmp: int)
{

  entry:
    out_SD1_2, out_count_6, out_cnt_1, out_Tmp_792, out_s_p_e_c_i_a_l_2, out_Tmp_793, out_boogieTmp := in_SD1_2, in_count_6, in_cnt_1, in_Tmp_792, in_s_p_e_c_i_a_l_2, in_Tmp_793, in_boogieTmp;
    goto L38, exit;

  exit:
    return;

  L38:
    out_count_6 := 0;
    goto L40;

  L40:
    call {:si_unique_call 1850} out_count_6, out_Tmp_792, out_s_p_e_c_i_a_l_2, out_boogieTmp := MoxaWaitFinish_loop_L40(out_count_6, out_Tmp_792, in_newTc, out_s_p_e_c_i_a_l_2, in_targetTc_1, out_boogieTmp);
    goto L40_last;

  L40_last:
    out_Tmp_792 := KeTickCount;
    assume {:nonnull} out_Tmp_792 != 0;
    assume out_Tmp_792 > 0;
    havoc out_s_p_e_c_i_a_l_2;
    goto L42;

  L42:
    call {:si_unique_call 1849} MoxaWaitFinish_loop_L42(in_newTc, out_s_p_e_c_i_a_l_2);
    goto L42_last;

  L42_last:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_2 != 0;
    assume out_s_p_e_c_i_a_l_2 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1844} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1845} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1846} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1847} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    call {:si_unique_call 1848} out_boogieTmp := corral_nondet();
    out_count_6 := out_count_6 + 1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    goto L56;

  L56:
    assume {:nonnull} in_PortOfs_8 != 0;
    assume in_PortOfs_8 > 0;
    goto anon18_Else;

  anon18_Else:
    assume {:partition} Mem_T.INT4[in_PortOfs_8] != 0;
    call {:si_unique_call 1843} out_SD1_2 := RtlLargeIntegerAdd(in_targetTc_1, in_interval_1);
    assume {:nonnull} out_SD1_2 != 0;
    assume out_SD1_2 > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    assume {:nonnull} out_SD1_2 != 0;
    assume out_SD1_2 > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    assume {:nonnull} out_SD1_2 != 0;
    assume out_SD1_2 > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    assume {:nonnull} out_SD1_2 != 0;
    assume out_SD1_2 > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    assume {:nonnull} out_SD1_2 != 0;
    assume out_SD1_2 > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    out_Tmp_793 := out_cnt_1;
    out_cnt_1 := out_cnt_1 - 1;
    goto anon24_Then;

  anon24_Then:
    assume {:partition} out_Tmp_793 != 0;
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    call {:si_unique_call 1851} {:si_old_unique_call 1} out_SD1_2, out_count_6, out_cnt_1, out_Tmp_792, out_s_p_e_c_i_a_l_2, out_Tmp_793, out_boogieTmp := MoxaWaitFinish_loop_L38(out_SD1_2, out_count_6, out_cnt_1, in_interval_1, out_Tmp_792, in_newTc, out_s_p_e_c_i_a_l_2, out_Tmp_793, in_targetTc_1, in_PortOfs_8, out_boogieTmp);
    return;

  anon23_Then:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} in_newTc != 0;
    assume in_newTc > 0;
    assume {:nonnull} in_targetTc_1 != 0;
    assume in_targetTc_1 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    goto L56;

  anon19_Then:
    assume false;
    return;

  anon20_Then:
    goto L56;

  anon17_Then:
    goto L64;

  anon22_Then:
    assume false;
    return;
}



procedure {:LoopProcedure} MoxaWaitFinish_loop_L38(in_SD1_2: int, in_count_6: int, in_cnt_1: int, in_interval_1: int, in_Tmp_792: int, in_newTc: int, in_s_p_e_c_i_a_l_2: int, in_Tmp_793: int, in_targetTc_1: int, in_PortOfs_8: int, in_boogieTmp: int) returns (out_SD1_2: int, out_count_6: int, out_cnt_1: int, out_Tmp_792: int, out_s_p_e_c_i_a_l_2: int, out_Tmp_793: int, out_boogieTmp: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaWaitFinish_loop_L15(in_s_p_e_c_i_a_l_1: int, in_currTc: int)
{

  entry:
    goto L15, exit;

  exit:
    return;

  L15:
    assume {:nonnull} in_currTc != 0;
    assume in_currTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_1 != 0;
    assume in_s_p_e_c_i_a_l_1 > 0;
    assume {:nonnull} in_currTc != 0;
    assume in_currTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_1 != 0;
    assume in_s_p_e_c_i_a_l_1 > 0;
    assume {:nonnull} in_currTc != 0;
    assume in_currTc > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_1 != 0;
    assume in_s_p_e_c_i_a_l_1 > 0;
    goto anon21_Then;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    call {:si_unique_call 1852} {:si_old_unique_call 1} MoxaWaitFinish_loop_L15(in_s_p_e_c_i_a_l_1, in_currTc);
    return;
}



procedure {:LoopProcedure} MoxaWaitFinish_loop_L15(in_s_p_e_c_i_a_l_1: int, in_currTc: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaDumbWaitFinish_loop_L42(in_newTc_1: int, in_s_p_e_c_i_a_l_4: int)
{

  entry:
    goto L42, exit;

  exit:
    return;

  L42:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_4 != 0;
    assume in_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_4 != 0;
    assume in_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_4 != 0;
    assume in_s_p_e_c_i_a_l_4 > 0;
    goto anon22_Then;

  anon22_Then:
    goto anon22_Then_dummy;

  anon22_Then_dummy:
    call {:si_unique_call 1853} {:si_old_unique_call 1} MoxaDumbWaitFinish_loop_L42(in_newTc_1, in_s_p_e_c_i_a_l_4);
    return;
}



procedure {:LoopProcedure} MoxaDumbWaitFinish_loop_L42(in_newTc_1: int, in_s_p_e_c_i_a_l_4: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaDumbWaitFinish_loop_L40(in_count_8: int, in_newTc_1: int, in_s_p_e_c_i_a_l_4: int, in_targetTc: int, in_Tmp_810: int, in_boogieTmp: int) returns (out_count_8: int, out_s_p_e_c_i_a_l_4: int, out_Tmp_810: int, out_boogieTmp: int)
{

  entry:
    out_count_8, out_s_p_e_c_i_a_l_4, out_Tmp_810, out_boogieTmp := in_count_8, in_s_p_e_c_i_a_l_4, in_Tmp_810, in_boogieTmp;
    goto L40, exit;

  exit:
    return;

  L40:
    out_Tmp_810 := KeTickCount;
    assume {:nonnull} out_Tmp_810 != 0;
    assume out_Tmp_810 > 0;
    havoc out_s_p_e_c_i_a_l_4;
    goto L42;

  L42:
    call {:si_unique_call 1859} MoxaDumbWaitFinish_loop_L42(in_newTc_1, out_s_p_e_c_i_a_l_4);
    goto L42_last;

  L42_last:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1854} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1855} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1856} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1857} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1858} out_boogieTmp := corral_nondet();
    out_count_8 := out_count_8 + 1;
    goto anon23_Then;

  anon23_Then:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon19_Then;

  anon19_Then:
    goto anon19_Then_dummy;

  anon19_Then_dummy:
    call {:si_unique_call 1860} {:si_old_unique_call 1} out_count_8, out_s_p_e_c_i_a_l_4, out_Tmp_810, out_boogieTmp := MoxaDumbWaitFinish_loop_L40(out_count_8, in_newTc_1, out_s_p_e_c_i_a_l_4, in_targetTc, out_Tmp_810, out_boogieTmp);
    return;

  anon17_Then:
    goto L64;

  anon22_Then:
    assume false;
    return;
}



procedure {:LoopProcedure} MoxaDumbWaitFinish_loop_L40(in_count_8: int, in_newTc_1: int, in_s_p_e_c_i_a_l_4: int, in_targetTc: int, in_Tmp_810: int, in_boogieTmp: int) returns (out_count_8: int, out_s_p_e_c_i_a_l_4: int, out_Tmp_810: int, out_boogieTmp: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaDumbWaitFinish_loop_L38(in_structPtr888targetTc: int, in_count_8: int, in_cnt_2: int, in_interval: int, in_newTc_1: int, in_s_p_e_c_i_a_l_4: int, in_targetTc: int, in_Tmp_809: int, in_Tmp_810: int, in_PortOfs_9: int, in_boogieTmp: int) returns (out_structPtr888targetTc: int, out_count_8: int, out_cnt_2: int, out_s_p_e_c_i_a_l_4: int, out_Tmp_809: int, out_Tmp_810: int, out_boogieTmp: int)
{

  entry:
    out_structPtr888targetTc, out_count_8, out_cnt_2, out_s_p_e_c_i_a_l_4, out_Tmp_809, out_Tmp_810, out_boogieTmp := in_structPtr888targetTc, in_count_8, in_cnt_2, in_s_p_e_c_i_a_l_4, in_Tmp_809, in_Tmp_810, in_boogieTmp;
    goto L38, exit;

  exit:
    return;

  L38:
    out_count_8 := 0;
    goto L40;

  L40:
    call {:si_unique_call 1868} out_count_8, out_s_p_e_c_i_a_l_4, out_Tmp_810, out_boogieTmp := MoxaDumbWaitFinish_loop_L40(out_count_8, in_newTc_1, out_s_p_e_c_i_a_l_4, in_targetTc, out_Tmp_810, out_boogieTmp);
    goto L40_last;

  L40_last:
    out_Tmp_810 := KeTickCount;
    assume {:nonnull} out_Tmp_810 != 0;
    assume out_Tmp_810 > 0;
    havoc out_s_p_e_c_i_a_l_4;
    goto L42;

  L42:
    call {:si_unique_call 1867} MoxaDumbWaitFinish_loop_L42(in_newTc_1, out_s_p_e_c_i_a_l_4);
    goto L42_last;

  L42_last:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} out_s_p_e_c_i_a_l_4 != 0;
    assume out_s_p_e_c_i_a_l_4 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1862} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1863} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1864} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1865} out_boogieTmp := corral_nondet();
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    call {:si_unique_call 1866} out_boogieTmp := corral_nondet();
    out_count_8 := out_count_8 + 1;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    goto L56;

  L56:
    assume {:nonnull} in_PortOfs_9 != 0;
    assume in_PortOfs_9 > 0;
    goto anon18_Else;

  anon18_Else:
    assume {:partition} Mem_T.INT4[in_PortOfs_9] != 0;
    call {:si_unique_call 1861} out_structPtr888targetTc := RtlLargeIntegerAdd(in_targetTc, in_interval);
    assume {:nonnull} out_structPtr888targetTc != 0;
    assume out_structPtr888targetTc > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    assume {:nonnull} out_structPtr888targetTc != 0;
    assume out_structPtr888targetTc > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    assume {:nonnull} out_structPtr888targetTc != 0;
    assume out_structPtr888targetTc > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    assume {:nonnull} out_structPtr888targetTc != 0;
    assume out_structPtr888targetTc > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    assume {:nonnull} out_structPtr888targetTc != 0;
    assume out_structPtr888targetTc > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    out_Tmp_809 := out_cnt_2;
    out_cnt_2 := out_cnt_2 - 1;
    goto anon24_Then;

  anon24_Then:
    assume {:partition} out_Tmp_809 != 0;
    goto anon24_Then_dummy;

  anon24_Then_dummy:
    call {:si_unique_call 1869} {:si_old_unique_call 1} out_structPtr888targetTc, out_count_8, out_cnt_2, out_s_p_e_c_i_a_l_4, out_Tmp_809, out_Tmp_810, out_boogieTmp := MoxaDumbWaitFinish_loop_L38(out_structPtr888targetTc, out_count_8, out_cnt_2, in_interval, in_newTc_1, out_s_p_e_c_i_a_l_4, in_targetTc, out_Tmp_809, out_Tmp_810, in_PortOfs_9, out_boogieTmp);
    return;

  anon23_Then:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    goto L64;

  L64:
    assume {:nonnull} in_newTc_1 != 0;
    assume in_newTc_1 > 0;
    assume {:nonnull} in_targetTc != 0;
    assume in_targetTc > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    goto L56;

  anon19_Then:
    assume false;
    return;

  anon20_Then:
    goto L56;

  anon17_Then:
    goto L64;

  anon22_Then:
    assume false;
    return;
}



procedure {:LoopProcedure} MoxaDumbWaitFinish_loop_L38(in_structPtr888targetTc: int, in_count_8: int, in_cnt_2: int, in_interval: int, in_newTc_1: int, in_s_p_e_c_i_a_l_4: int, in_targetTc: int, in_Tmp_809: int, in_Tmp_810: int, in_PortOfs_9: int, in_boogieTmp: int) returns (out_structPtr888targetTc: int, out_count_8: int, out_cnt_2: int, out_s_p_e_c_i_a_l_4: int, out_Tmp_809: int, out_Tmp_810: int, out_boogieTmp: int);
  modifies alloc;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaDumbWaitFinish_loop_L15(in_s_p_e_c_i_a_l_3: int, in_currTc_1: int)
{

  entry:
    goto L15, exit;

  exit:
    return;

  L15:
    assume {:nonnull} in_currTc_1 != 0;
    assume in_currTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_3 != 0;
    assume in_s_p_e_c_i_a_l_3 > 0;
    assume {:nonnull} in_currTc_1 != 0;
    assume in_currTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_3 != 0;
    assume in_s_p_e_c_i_a_l_3 > 0;
    assume {:nonnull} in_currTc_1 != 0;
    assume in_currTc_1 > 0;
    assume {:nonnull} in_s_p_e_c_i_a_l_3 != 0;
    assume in_s_p_e_c_i_a_l_3 > 0;
    goto anon21_Then;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    call {:si_unique_call 1870} {:si_old_unique_call 1} MoxaDumbWaitFinish_loop_L15(in_s_p_e_c_i_a_l_3, in_currTc_1);
    return;
}



procedure {:LoopProcedure} MoxaDumbWaitFinish_loop_L15(in_s_p_e_c_i_a_l_3: int, in_currTc_1: int);
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaStartMask_loop_L8(in_Tmp_828: int, in_Tmp_829: int, in_Tmp_830: int, in_irpSp_8: int, in_Tmp_831: int, in_setFirstStatus_2: int, in_newIrp_5: int, in_oldIrql_26: int, in_sdv_321: int, in_sdv_322: int, in_Tmp_832: int, in_Tmp_833: int, in_firstStatus_2: int, in_Extension_19: int, in_vslice_dummy_var_208: int, in_vslice_dummy_var_209: int, in_vslice_dummy_var_210: int) returns (out_Tmp_828: int, out_Tmp_829: int, out_Tmp_830: int, out_irpSp_8: int, out_Tmp_831: int, out_setFirstStatus_2: int, out_oldIrql_26: int, out_sdv_321: int, out_sdv_322: int, out_Tmp_832: int, out_Tmp_833: int, out_firstStatus_2: int, out_vslice_dummy_var_208: int, out_vslice_dummy_var_209: int, out_vslice_dummy_var_210: int)
{
  var vslice_dummy_var_1393: int;
  var vslice_dummy_var_1394: int;
  var vslice_dummy_var_1395: int;
  var vslice_dummy_var_1396: int;

  entry:
    out_Tmp_828, out_Tmp_829, out_Tmp_830, out_irpSp_8, out_Tmp_831, out_setFirstStatus_2, out_oldIrql_26, out_sdv_321, out_sdv_322, out_Tmp_832, out_Tmp_833, out_firstStatus_2, out_vslice_dummy_var_208, out_vslice_dummy_var_209, out_vslice_dummy_var_210 := in_Tmp_828, in_Tmp_829, in_Tmp_830, in_irpSp_8, in_Tmp_831, in_setFirstStatus_2, in_oldIrql_26, in_sdv_321, in_sdv_322, in_Tmp_832, in_Tmp_833, in_firstStatus_2, in_vslice_dummy_var_208, in_vslice_dummy_var_209, in_vslice_dummy_var_210;
    goto L8, exit;

  exit:
    return;

  L8:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc vslice_dummy_var_1393;
    call {:si_unique_call 1871} out_irpSp_8 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1393);
    assume {:nonnull} out_irpSp_8 != 0;
    assume out_irpSp_8 > 0;
    goto anon19_Then, anon19_Else;

  anon19_Else:
    call {:si_unique_call 1885} out_vslice_dummy_var_208 := KeSynchronizeExecution(0, li2bplFunctionConstant417, 0);
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc out_Tmp_833;
    assume {:nonnull} out_Tmp_833 != 0;
    assume out_Tmp_833 > 0;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} out_setFirstStatus_2 != 0;
    goto L20;

  L20:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    call {:si_unique_call 1872} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(in_Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(in_Extension_19), in_newIrp_5, 1, in_Extension_19);
    goto L23;

  L23:
    assume {:nonnull} in_newIrp_5 != 0;
    assume in_newIrp_5 > 0;
    goto anon21_Then;

  anon21_Then:
    goto anon21_Then_dummy;

  anon21_Then_dummy:
    call {:si_unique_call 1886} {:si_old_unique_call 1} out_Tmp_828, out_Tmp_829, out_Tmp_830, out_irpSp_8, out_Tmp_831, out_setFirstStatus_2, out_oldIrql_26, out_sdv_321, out_sdv_322, out_Tmp_832, out_Tmp_833, out_firstStatus_2, out_vslice_dummy_var_208, out_vslice_dummy_var_209, out_vslice_dummy_var_210 := MoxaStartMask_loop_L8(out_Tmp_828, out_Tmp_829, out_Tmp_830, out_irpSp_8, out_Tmp_831, out_setFirstStatus_2, in_newIrp_5, out_oldIrql_26, out_sdv_321, out_sdv_322, out_Tmp_832, out_Tmp_833, out_firstStatus_2, in_Extension_19, out_vslice_dummy_var_208, out_vslice_dummy_var_209, out_vslice_dummy_var_210);
    return;

  anon25_Then:
    assume {:partition} out_setFirstStatus_2 == 0;
    out_firstStatus_2 := 0;
    out_setFirstStatus_2 := 1;
    goto L20;

  anon19_Then:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    goto anon20_Then, anon20_Else;

  anon20_Else:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    call {:si_unique_call 1882} out_Tmp_832 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_832 != 0;
    assume out_Tmp_832 > 0;
    Mem_T.INT4[out_Tmp_832] := out_oldIrql_26;
    call {:si_unique_call 1883} IoAcquireCancelSpinLock(out_Tmp_832);
    assume {:nonnull} out_Tmp_832 != 0;
    assume out_Tmp_832 > 0;
    out_oldIrql_26 := Mem_T.INT4[out_Tmp_832];
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc out_Tmp_830;
    assume {:nonnull} out_Tmp_830 != 0;
    assume out_Tmp_830 > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc out_Tmp_831;
    assume {:nonnull} out_Tmp_831 != 0;
    assume out_Tmp_831 > 0;
    call {:si_unique_call 1884} IoReleaseCancelSpinLock(out_oldIrql_26);
    goto anon24_Then, anon24_Else;

  anon24_Else:
    assume {:partition} out_setFirstStatus_2 != 0;
    goto L40;

  L40:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    call {:si_unique_call 1873} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(in_Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(in_Extension_19), in_newIrp_5, 1, in_Extension_19);
    goto L23;

  anon24_Then:
    assume {:partition} out_setFirstStatus_2 == 0;
    out_firstStatus_2 := -1073741536;
    out_setFirstStatus_2 := 1;
    goto L40;

  anon27_Then:
    goto anon23_Then, anon23_Else;

  anon23_Else:
    assume {:partition} out_setFirstStatus_2 != 0;
    goto L45;

  L45:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc vslice_dummy_var_1394;
    call {:si_unique_call 1874} out_sdv_321 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1394);
    assume {:nonnull} out_sdv_321 != 0;
    assume out_sdv_321 > 0;
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc vslice_dummy_var_1395;
    call {:si_unique_call 1875} out_vslice_dummy_var_209 := sdv_IoSetCancelRoutine(vslice_dummy_var_1395, li2bplFunctionConstant418);
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc vslice_dummy_var_1396;
    call {:si_unique_call 1876} out_sdv_322 := sdv_IoGetCurrentIrpStackLocation(vslice_dummy_var_1396);
    assume {:nonnull} out_sdv_322 != 0;
    assume out_sdv_322 > 0;
    out_Tmp_829 := Argument4_unnamed_tag_41(Others_unnamed_tag_9(Parameters__IO_STACK_LOCATION(out_sdv_322)));
    assume {:nonnull} out_sdv_322 != 0;
    assume out_sdv_322 > 0;
    assume {:nonnull} out_Tmp_829 != 0;
    assume out_Tmp_829 > 0;
    assume {:nonnull} out_sdv_322 != 0;
    assume out_sdv_322 > 0;
    call {:si_unique_call 1877} out_vslice_dummy_var_210 := KeSynchronizeExecution(0, li2bplFunctionConstant419, 0);
    call {:si_unique_call 1878} IoReleaseCancelSpinLock(out_oldIrql_26);
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    call {:si_unique_call 1879} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(in_Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(in_Extension_19), in_newIrp_5, 0, in_Extension_19);
    goto L23;

  anon23_Then:
    assume {:partition} out_setFirstStatus_2 == 0;
    out_firstStatus_2 := 259;
    out_setFirstStatus_2 := 1;
    call {:si_unique_call 1881} sdv_IoMarkIrpPending(0);
    goto L45;

  anon22_Then:
    goto L26;

  L26:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    havoc out_Tmp_828;
    assume {:nonnull} out_Tmp_828 != 0;
    assume out_Tmp_828 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} out_setFirstStatus_2 != 0;
    goto L72;

  L72:
    assume {:nonnull} in_Extension_19 != 0;
    assume in_Extension_19 > 0;
    call {:si_unique_call 1880} MoxaGetNextIrp(CurrentMaskIrp__MOXA_DEVICE_EXTENSION(in_Extension_19), MaskQueue__MOXA_DEVICE_EXTENSION(in_Extension_19), in_newIrp_5, 1, in_Extension_19);
    goto L23;

  anon26_Then:
    assume {:partition} out_setFirstStatus_2 == 0;
    out_firstStatus_2 := -1073741811;
    out_setFirstStatus_2 := 1;
    goto L72;

  anon20_Then:
    goto L26;
}



procedure {:LoopProcedure} MoxaStartMask_loop_L8(in_Tmp_828: int, in_Tmp_829: int, in_Tmp_830: int, in_irpSp_8: int, in_Tmp_831: int, in_setFirstStatus_2: int, in_newIrp_5: int, in_oldIrql_26: int, in_sdv_321: int, in_sdv_322: int, in_Tmp_832: int, in_Tmp_833: int, in_firstStatus_2: int, in_Extension_19: int, in_vslice_dummy_var_208: int, in_vslice_dummy_var_209: int, in_vslice_dummy_var_210: int) returns (out_Tmp_828: int, out_Tmp_829: int, out_Tmp_830: int, out_irpSp_8: int, out_Tmp_831: int, out_setFirstStatus_2: int, out_oldIrql_26: int, out_sdv_321: int, out_sdv_322: int, out_Tmp_832: int, out_Tmp_833: int, out_firstStatus_2: int, out_vslice_dummy_var_208: int, out_vslice_dummy_var_209: int, out_vslice_dummy_var_210: int);
  modifies alloc, Mem_T.INT4, Mem_T.CancelRoutine__IRP, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} out_setFirstStatus_2 == 1 || out_setFirstStatus_2 == in_setFirstStatus_2;
  free ensures {:va_keep} out_firstStatus_2 == 0 || out_firstStatus_2 == -1073741536 || out_firstStatus_2 == 259 || out_firstStatus_2 == -1073741811 || out_firstStatus_2 == in_firstStatus_2;
  free ensures {:va_keep} out_vslice_dummy_var_208 == 1 || out_vslice_dummy_var_208 == 0 || out_vslice_dummy_var_208 == in_vslice_dummy_var_208;
  free ensures {:va_keep} out_vslice_dummy_var_210 == 1 || out_vslice_dummy_var_210 == 0 || out_vslice_dummy_var_210 == in_vslice_dummy_var_210;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:SIextraRecBound 2} MoxaTimeOutProcIsr#0_loop_L9(in_Tmp_302: int, in_count_4: int, in_Tmp_303: int, in_next: int, in_ofs_9: int, in_lenMask: int, in_Tmp_304: int, in_Tmp_305: int, in_rptr: int, in_oldIrql_6: int, in_Tmp_307: int, in_extension_10: int, in_wptr: int, in_vslice_dummy_var_256: int, in_vslice_dummy_var_257: int) returns (out_Tmp_302: int, out_count_4: int, out_Tmp_303: int, out_next: int, out_ofs_9: int, out_lenMask: int, out_Tmp_304: int, out_Tmp_305: int, out_rptr: int, out_oldIrql_6: int, out_Tmp_307: int, out_extension_10: int, out_wptr: int, out_vslice_dummy_var_256: int, out_vslice_dummy_var_257: int)
{

  entry:
    out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_256, out_vslice_dummy_var_257 := in_Tmp_302, in_count_4, in_Tmp_303, in_next, in_ofs_9, in_lenMask, in_Tmp_304, in_Tmp_305, in_rptr, in_oldIrql_6, in_Tmp_307, in_extension_10, in_wptr, in_vslice_dummy_var_256, in_vslice_dummy_var_257;
    goto L9, exit;

  exit:
    return;

  L9:
    goto anon21_Else;

  anon21_Else:
    assume {:partition} out_next != 0;
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_extension_10;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} out_extension_10 != 0;
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    havoc out_Tmp_307;
    assume {:nonnull} out_Tmp_307 != 0;
    assume out_Tmp_307 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_307], 256) != 0;
    call {:si_unique_call 1889} out_Tmp_305 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_305 != 0;
    assume out_Tmp_305 > 0;
    Mem_T.INT4[out_Tmp_305] := out_oldIrql_6;
    call {:si_unique_call 1890} IoAcquireCancelSpinLock(out_Tmp_305);
    assume {:nonnull} out_Tmp_305 != 0;
    assume out_Tmp_305 > 0;
    out_oldIrql_6 := Mem_T.INT4[out_Tmp_305];
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    havoc out_ofs_9;
    out_rptr := out_ofs_9;
    out_wptr := out_ofs_9;
    out_Tmp_303 := out_ofs_9;
    assume {:nonnull} out_Tmp_303 != 0;
    assume out_Tmp_303 > 0;
    out_lenMask := Mem_T.INT4[out_Tmp_303];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} Mem_T.INT4[out_wptr] >= Mem_T.INT4[out_rptr];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    out_Tmp_302 := Mem_T.INT4[out_wptr] - Mem_T.INT4[out_rptr];
    goto L34;

  L34:
    out_count_4 := out_Tmp_302;
    out_Tmp_304 := out_ofs_9;
    assume {:nonnull} out_Tmp_304 != 0;
    assume out_Tmp_304 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} out_count_4 >= Mem_T.INT4[out_Tmp_304];
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    call {:si_unique_call 1888} out_vslice_dummy_var_257 := KeSynchronizeExecution(0, li2bplFunctionConstant306, 0);
    goto L36;

  L36:
    call {:si_unique_call 1887} IoReleaseCancelSpinLock(out_oldIrql_6);
    goto L17;

  L17:
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_next;
    goto L17_dummy;

  L17_dummy:
    goto L_BAF_1;

  L_BAF_1:
    call {:si_unique_call 1892} {:si_old_unique_call 1} out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_256, out_vslice_dummy_var_257 := MoxaTimeOutProcIsr#0_loop_L9(out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_256, out_vslice_dummy_var_257);
    return;

  anon23_Then:
    call {:si_unique_call 1891} out_vslice_dummy_var_256 := MoxaIsrGetData#0(out_extension_10);
    goto anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    goto L36;

  anon28_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_304] > out_count_4;
    goto L36;

  anon27_Then:
    assume {:partition} Mem_T.INT4[out_rptr] > Mem_T.INT4[out_wptr];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    out_Tmp_302 := Mem_T.INT4[out_wptr] - Mem_T.INT4[out_rptr] + out_lenMask + 1;
    goto L34;

  anon26_Then:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_307], 256) == 0;
    goto L17;

  anon22_Then:
    goto L17;

  anon25_Then:
    assume {:partition} out_extension_10 == 0;
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_next;
    goto anon25_Then_dummy;

  anon25_Then_dummy:
    goto L_BAF_1;
}



procedure {:LoopProcedure} MoxaTimeOutProcIsr#0_loop_L9(in_Tmp_302: int, in_count_4: int, in_Tmp_303: int, in_next: int, in_ofs_9: int, in_lenMask: int, in_Tmp_304: int, in_Tmp_305: int, in_rptr: int, in_oldIrql_6: int, in_Tmp_307: int, in_extension_10: int, in_wptr: int, in_vslice_dummy_var_256: int, in_vslice_dummy_var_257: int) returns (out_Tmp_302: int, out_count_4: int, out_Tmp_303: int, out_next: int, out_ofs_9: int, out_lenMask: int, out_Tmp_304: int, out_Tmp_305: int, out_rptr: int, out_oldIrql_6: int, out_Tmp_307: int, out_extension_10: int, out_wptr: int, out_vslice_dummy_var_256: int, out_vslice_dummy_var_257: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, Mem_T.INT4, sdv_irql_previous_5;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} old(sdv_irql_previous) == sdv_irql_previous;
  free ensures {:va_keep} sdv_irql_previous_5 == old(sdv_irql_previous_5) || sdv_irql_previous_5 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_2 == old(sdv_irql_previous_2);
  free ensures {:va_keep} sdv_irql_previous == old(sdv_irql_previous);
  free ensures {:va_keep} sdv_irql_previous_4 == old(sdv_irql_previous_4);
  free ensures {:va_keep} sdv_irql_previous_3 == old(sdv_irql_previous_3);
  free ensures {:va_keep} out_vslice_dummy_var_256 == 0 || out_vslice_dummy_var_256 == in_vslice_dummy_var_256;
  free ensures {:va_keep} out_vslice_dummy_var_257 == 1 || out_vslice_dummy_var_257 == 0 || out_vslice_dummy_var_257 == in_vslice_dummy_var_257;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation MoxaTimeOutProcIsr#1_loop_L9(in_Tmp_302: int, in_count_4: int, in_Tmp_303: int, in_next: int, in_ofs_9: int, in_lenMask: int, in_Tmp_304: int, in_Tmp_305: int, in_rptr: int, in_oldIrql_6: int, in_Tmp_307: int, in_extension_10: int, in_wptr: int, in_vslice_dummy_var_259: int, in_vslice_dummy_var_260: int) returns (out_Tmp_302: int, out_count_4: int, out_Tmp_303: int, out_next: int, out_ofs_9: int, out_lenMask: int, out_Tmp_304: int, out_Tmp_305: int, out_rptr: int, out_oldIrql_6: int, out_Tmp_307: int, out_extension_10: int, out_wptr: int, out_vslice_dummy_var_259: int, out_vslice_dummy_var_260: int)
{

  entry:
    out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_259, out_vslice_dummy_var_260 := in_Tmp_302, in_count_4, in_Tmp_303, in_next, in_ofs_9, in_lenMask, in_Tmp_304, in_Tmp_305, in_rptr, in_oldIrql_6, in_Tmp_307, in_extension_10, in_wptr, in_vslice_dummy_var_259, in_vslice_dummy_var_260;
    goto L9, exit;

  exit:
    return;

  L9:
    goto anon21_Else;

  anon21_Else:
    assume {:partition} out_next != 0;
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_extension_10;
    goto anon25_Then, anon25_Else;

  anon25_Else:
    assume {:partition} out_extension_10 != 0;
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    goto anon22_Then, anon22_Else;

  anon22_Else:
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    havoc out_Tmp_307;
    assume {:nonnull} out_Tmp_307 != 0;
    assume out_Tmp_307 > 0;
    goto anon26_Then, anon26_Else;

  anon26_Else:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_307], 256) != 0;
    call {:si_unique_call 1895} out_Tmp_305 := __HAVOC_malloc(4);
    assume {:nonnull} out_Tmp_305 != 0;
    assume out_Tmp_305 > 0;
    Mem_T.INT4[out_Tmp_305] := out_oldIrql_6;
    call {:si_unique_call 1896} IoAcquireCancelSpinLock(out_Tmp_305);
    assume {:nonnull} out_Tmp_305 != 0;
    assume out_Tmp_305 > 0;
    out_oldIrql_6 := Mem_T.INT4[out_Tmp_305];
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    havoc out_ofs_9;
    out_rptr := out_ofs_9;
    out_wptr := out_ofs_9;
    out_Tmp_303 := out_ofs_9;
    assume {:nonnull} out_Tmp_303 != 0;
    assume out_Tmp_303 > 0;
    out_lenMask := Mem_T.INT4[out_Tmp_303];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    goto anon27_Then, anon27_Else;

  anon27_Else:
    assume {:partition} Mem_T.INT4[out_wptr] >= Mem_T.INT4[out_rptr];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    out_Tmp_302 := Mem_T.INT4[out_wptr] - Mem_T.INT4[out_rptr];
    goto L34;

  L34:
    out_count_4 := out_Tmp_302;
    out_Tmp_304 := out_ofs_9;
    assume {:nonnull} out_Tmp_304 != 0;
    assume out_Tmp_304 > 0;
    goto anon28_Then, anon28_Else;

  anon28_Else:
    assume {:partition} out_count_4 >= Mem_T.INT4[out_Tmp_304];
    assume {:nonnull} out_extension_10 != 0;
    assume out_extension_10 > 0;
    goto anon23_Then, anon23_Else;

  anon23_Else:
    call {:si_unique_call 1894} out_vslice_dummy_var_260 := KeSynchronizeExecution(0, li2bplFunctionConstant306, 0);
    goto L36;

  L36:
    call {:si_unique_call 1893} IoReleaseCancelSpinLock(out_oldIrql_6);
    goto L17;

  L17:
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_next;
    goto L17_dummy;

  L17_dummy:
    goto L_BAF_2;

  L_BAF_2:
    call {:si_unique_call 1898} {:si_old_unique_call 1} out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_259, out_vslice_dummy_var_260 := MoxaTimeOutProcIsr#1_loop_L9(out_Tmp_302, out_count_4, out_Tmp_303, out_next, out_ofs_9, out_lenMask, out_Tmp_304, out_Tmp_305, out_rptr, out_oldIrql_6, out_Tmp_307, out_extension_10, out_wptr, out_vslice_dummy_var_259, out_vslice_dummy_var_260);
    return;

  anon23_Then:
    call {:si_unique_call 1897} out_vslice_dummy_var_259 := MoxaIsrGetData#1(out_extension_10);
    goto anon29_Else;

  anon29_Else:
    assume {:partition} yogi_error != 1;
    goto L36;

  anon28_Then:
    assume {:partition} Mem_T.INT4[out_Tmp_304] > out_count_4;
    goto L36;

  anon27_Then:
    assume {:partition} Mem_T.INT4[out_rptr] > Mem_T.INT4[out_wptr];
    assume {:nonnull} out_rptr != 0;
    assume out_rptr > 0;
    assume {:nonnull} out_wptr != 0;
    assume out_wptr > 0;
    out_Tmp_302 := Mem_T.INT4[out_wptr] - Mem_T.INT4[out_rptr] + out_lenMask + 1;
    goto L34;

  anon26_Then:
    assume {:partition} BAND(Mem_T.INT4[out_Tmp_307], 256) == 0;
    goto L17;

  anon22_Then:
    goto L17;

  anon25_Then:
    assume {:partition} out_extension_10 == 0;
    assume {:nonnull} out_next != 0;
    assume out_next > 0;
    havoc out_next;
    goto anon25_Then_dummy;

  anon25_Then_dummy:
    goto L_BAF_2;
}



procedure {:LoopProcedure} MoxaTimeOutProcIsr#1_loop_L9(in_Tmp_302: int, in_count_4: int, in_Tmp_303: int, in_next: int, in_ofs_9: int, in_lenMask: int, in_Tmp_304: int, in_Tmp_305: int, in_rptr: int, in_oldIrql_6: int, in_Tmp_307: int, in_extension_10: int, in_wptr: int, in_vslice_dummy_var_259: int, in_vslice_dummy_var_260: int) returns (out_Tmp_302: int, out_count_4: int, out_Tmp_303: int, out_next: int, out_ofs_9: int, out_lenMask: int, out_Tmp_304: int, out_Tmp_305: int, out_rptr: int, out_oldIrql_6: int, out_Tmp_307: int, out_extension_10: int, out_wptr: int, out_vslice_dummy_var_259: int, out_vslice_dummy_var_260: int);
  modifies alloc, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, Mem_T.INT4, sdv_irql_previous_5, Mem_T.CancelIrql__IRP, Mem_T.CancelRoutine__IRP, yogi_error;
  free ensures {:va_keep} yogi_error == 0;
  free ensures {:va_keep} old(sdv_irql_current) == sdv_irql_current;
  free ensures {:va_keep} yogi_error == 1 || yogi_error == old(yogi_error);
  free ensures {:va_keep} out_vslice_dummy_var_260 == 1 || out_vslice_dummy_var_260 == 0 || out_vslice_dummy_var_260 == in_vslice_dummy_var_260;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



procedure fakeMain() returns (Tmp_925: int, dup_assertVar: bool);
  modifies alloc, yogi_error, Mem_T.INT4, Mem_T.CurrentStackLocation_unnamed_tag_7, sdv_irql_current, sdv_irql_previous, sdv_irql_previous_2, sdv_irql_previous_3, sdv_irql_previous_4, sdv_irql_previous_5, Mem_T.CancelRoutine__IRP, Mem_T.MinorFunction__IO_STACK_LOCATION, Mem_T.Type_unnamed_tag_38, Mem_T.CancelIrql__IRP;
  free ensures {:va_keep} old(yogi_error) == 0;
  free ensures {:va_keep} alloc >= old(alloc);



implementation {:entrypoint} fakeMain() returns (Tmp_925: int, dup_assertVar: bool)
{

  start:
    call Tmp_925, dup_assertVar := main();
    assume {:OldAssert} !dup_assertVar;
    return;
}


